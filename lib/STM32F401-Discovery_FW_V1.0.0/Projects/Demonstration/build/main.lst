
build/main.elf:     file format elf32-littlearm

SYMBOL TABLE:
08000000 l    d  .isr_vector	00000000 .isr_vector
08000188 l    d  .text	00000000 .text
08006a3c l    d  .rodata	00000000 .rodata
08006b2c l    d  .init_array	00000000 .init_array
08006b34 l    d  .fini_array	00000000 .fini_array
20000000 l    d  .data	00000000 .data
200005a0 l    d  .bss	00000000 .bss
20000d10 l    d  ._user_heap_stack	00000000 ._user_heap_stack
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 /var/folders/yq/clzbzy1n1xj4t983g7hdfgzw0000gn/T//ccCJCtx7.o
080068ea l       .text	00000000 LoopCopyDataInit
080068e2 l       .text	00000000 CopyDataInit
08006902 l       .text	00000000 LoopFillZerobss
080068fc l       .text	00000000 FillZerobss
08006928 l       .text	00000000 Infinite_Loop
00000000 l    df *ABS*	00000000 crtstuff.c
08006a24 l     O .text	00000000 __EH_FRAME_BEGIN__
08000188 l     F .text	00000000 __do_global_dtors_aux
200005a0 l       .bss	00000000 completed.7857
08006b34 l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
080001ac l     F .text	00000000 frame_dummy
200005a4 l       .bss	00000000 object.7862
08006b30 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 stm32f4xx_adc.c
00000000 l    df *ABS*	00000000 stm32f4xx_dma.c
00000000 l    df *ABS*	00000000 stm32f4xx_exti.c
00000000 l    df *ABS*	00000000 stm32f4xx_flash.c
00000000 l    df *ABS*	00000000 stm32f4xx_gpio.c
00000000 l    df *ABS*	00000000 stm32f4xx_i2c.c
00000000 l    df *ABS*	00000000 stm32f4xx_rcc.c
20000000 l     O .data	00000010 APBAHBPrescTable
00000000 l    df *ABS*	00000000 stm32f4xx_spi.c
00000000 l    df *ABS*	00000000 stm32f4xx_syscfg.c
00000000 l    df *ABS*	00000000 stm32f4xx_tim.c
00000000 l    df *ABS*	00000000 misc.c
00000000 l    df *ABS*	00000000 main.c
08002f9c l     F .text	00000310 Demo_Exec
00000000 l    df *ABS*	00000000 stm32f401_discovery.c
00000000 l    df *ABS*	00000000 stm32f401_discovery_audio_codec.c
08003534 l     F .text	00000234 Codec_WriteRegister
08003768 l     F .text	0000001c Codec_VolumeCtrl
08003784 l     F .text	00000028 Codec_Reset
00000000 l    df *ABS*	00000000 stm32f401_discovery_l3gd20.c
08003b40 l     F .text	0000005c L3GD20_SendByte
00000000 l    df *ABS*	00000000 stm32f401_discovery_lsm303dlhc.c
08003e0c l     F .text	00000138 LSM303DLHC_LowLevel_Init
00000000 l    df *ABS*	00000000 stm32f4xx_it.c
200005c6 l     O .bss	00000004 HID_Buffer.8927
00000000 l    df *ABS*	00000000 system_stm32f4xx.c
00000000 l    df *ABS*	00000000 usb_bsp.c
00000000 l    df *ABS*	00000000 usbd_desc.c
00000000 l    df *ABS*	00000000 usbd_usr.c
00000000 l    df *ABS*	00000000 selftest.c
00000000 l    df *ABS*	00000000 usbd_hid_core.c
080052c4 l     F .text	0000000c USBD_HID_GetCfgDesc
080052d0 l     F .text	0000000c USBD_HID_DataIn
080052dc l     F .text	000000b8 USBD_HID_Setup
08005394 l     F .text	00000016 USBD_HID_DeInit
080053aa l     F .text	0000001e USBD_HID_Init
200005d4 l     O .bss	00000004 USBD_HID_Protocol
200000ae l     O .data	0000004a HID_MOUSE_ReportDesc
200005d8 l     O .bss	00000004 USBD_HID_IdleState
200005dc l     O .bss	00000004 USBD_HID_AltSet
200000f8 l     O .data	00000022 USBD_HID_CfgDesc
00000000 l    df *ABS*	00000000 usbd_core.c
080053e2 l     F .text	00000016 USBD_Resume
080053f8 l     F .text	0000001c USBD_Suspend
08005414 l     F .text	00000010 USBD_SOF
08005424 l     F .text	0000000e USBD_IsoINIncomplete
08005432 l     F .text	0000000e USBD_IsoOUTIncomplete
08005440 l     F .text	0000002e USBD_Reset
0800546e l     F .text	0000004a USBD_SetupStage
080054b8 l     F .text	000000b4 USBD_DataInStage
0800556c l     F .text	00000074 USBD_DataOutStage
00000000 l    df *ABS*	00000000 usbd_ioreq.c
00000000 l    df *ABS*	00000000 usbd_req.c
200005ec l     O .bss	00000001 cfgidx.8051
00000000 l    df *ABS*	00000000 usb_core.c
08005aa4 l     F .text	0000004c USB_OTG_CoreReset.isra.1
00000000 l    df *ABS*	00000000 usb_dcd.c
00000000 l    df *ABS*	00000000 usb_dcd_int.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0800692c l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 /usr/local/toolchains/gcc-arm-none-eabi-4_8-2014q1/bin/../lib/gcc/arm-none-eabi/4.8.3/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 /usr/local/toolchains/gcc-arm-none-eabi-4_8-2014q1/bin/../lib/gcc/arm-none-eabi/4.8.3/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 impure.c
20000178 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 
00000400 l       *ABS*	00000000 _Min_Stack_Size
08006b38 l       .fini_array	00000000 __fini_array_end
200005a0 l       .bss	00000000 __bss_start__
20000d10 l       .bss	00000000 __bss_end__
00000000 l       *ABS*	00000000 _Min_Heap_Size
00000000 l       *UND*	00000000 software_init_hook
08006b34 l       .fini_array	00000000 __fini_array_start
08006b34 l       .init_array	00000000 __init_array_end
00000000 l       *UND*	00000000 hardware_init_hook
08006b2c l       .init_array	00000000 __preinit_array_end
00000000 l       *UND*	00000000 __stack
08006b2c l       .init_array	00000000 __init_array_start
00000000 l       *UND*	00000000 _exit
08006b2c l       .init_array	00000000 __preinit_array_start
00000000 l       *UND*	00000000 free
0800234c g     F .text	00000012 TIM_TimeBaseStructInit
08006928  w    F .text	00000004 RTC_Alarm_IRQHandler
08003b9c g     F .text	00000040 L3GD20_Write
08006928  w    F .text	00000004 EXTI2_IRQHandler
2000007c g     O .data	00000012 USBD_DeviceDesc
080048a0 g     F .text	00000024 USBD_USR_ProductStrDescriptor
0800340c g     F .text	0000004c STM_EVAL_LEDInit
0800206c g     F .text	0000001a SYSCFG_DeInit
080017cc g     F .text	0000000c RCC_HSICmd
20000034 g     O .data	00000004 AUDIO_MAL_DMA_CLOCK
080026b8 g     F .text	00000014 TIM_ForcedOC2Config
080061da g     F .text	00000010 USB_OTG_ReadDevOutEP_itr
08000ab0 g     F .text	00000020 FLASH_Unlock
08001828 g     F .text	0000000c RCC_PLLCmd
08004860 g     F .text	0000000a USB_OTG_BSP_mDelay
080003c8 g     F .text	00000014 ADC_ContinuousModeCmd
08004924 g     F .text	00000002 USBD_USR_DeviceConnected
08004456 g     F .text	00000002 DebugMon_Handler
0800269c g     F .text	00000004 TIM_SetCompare2
08000764 g     F .text	00000014 DMA_Cmd
20000148 g     O .data	00000004 USBD_DCD_INT_fops
08001834 g     F .text	00000014 RCC_PLLI2SConfig
08001278 g     F .text	00000028 GPIO_PinAFConfig
2000004c g     O .data	00000004 AUDIO_MAL_DMA_DREG
0800629c g     F .text	0000009c DCD_Init
08002c24 g     F .text	0000001a TIM_SelectCOM
08003da8 g     F .text	00000034 L3GD20_FilterConfig
2000003c g     O .data	00000004 AUDIO_MAL_DMA_STREAM
08001c50 g     F .text	0000000c RCC_ClearITPendingBit
20000bf8 g     O .bss	00000004 CurrentPos
080015d0 g     F .text	0000001a I2C_TransmitPEC
08001244 g     F .text	0000000c GPIO_ReadOutputDataBit
2000011c g     O .data	0000002c USBD_HID_cb
08002844 g     F .text	00000020 TIM_CCxCmd
08002ba8 g     F .text	0000001a TIM_SetIC4Prescaler
080008ac g     F .text	00000054 DMA_GetITStatus
08002c40 g     F .text	0000001a TIM_CCPreloadControl
08006928  w    F .text	00000004 TIM1_CC_IRQHandler
080015c8 g     F .text	00000006 I2C_ReceiveData
08001fa4 g     F .text	00000004 SPI_I2S_SendData
08006928  w    F .text	00000004 DMA2_Stream5_IRQHandler
0800444c g     F .text	00000002 HardFault_Handler
08000e20 g     F .text	00000040 FLASH_ProgramWord
080034a4 g     F .text	0000007c STM_EVAL_PBInit
08004e3c g     F .text	0000019c Audio_Test
08006928  w    F .text	00000004 DMA1_Stream5_IRQHandler
080016ac g     F .text	00000010 I2C_GetLastEvent
08000414 g     F .text	00000014 ADC_DMACmd
08000f34 g     F .text	0000002c FLASH_OB_PCROPConfig
08000aa0 g     F .text	00000010 FLASH_DataCacheReset
080026f0 g     F .text	00000010 TIM_OC1PreloadConfig
08005cf4 g     F .text	00000038 USB_OTG_FlushRxFifo
0800445c g     F .text	000001b4 SysTick_Handler
08000ae0 g     F .text	00000020 FLASH_OB_Unlock
08002ec8 g     F .text	00000078 NVIC_Init
080015a8 g     F .text	0000001a I2C_ARPCmd
08001b08 g     F .text	00000018 RCC_AHB2PeriphResetCmd
080014c4 g     F .text	00000012 I2C_OwnAddress2Config
08006928  w    F .text	00000004 PVD_IRQHandler
0800057c g     F .text	0000001c ADC_GetITStatus
08006928  w    F .text	00000004 SDIO_IRQHandler
08006928  w    F .text	00000004 TAMP_STAMP_IRQHandler
08001f38 g     F .text	0000001a SPI_TIModeCmd
08006b38 g       *ABS*	00000000 _sidata
0800637a g     F .text	00000030 DCD_EP_Close
08001f9c g     F .text	00000006 SPI_I2S_ReceiveData
08004458 g     F .text	00000002 PendSV_Handler
08001c5c g     F .text	000000d0 SPI_I2S_DeInit
0800444a g     F .text	00000002 NMI_Handler
08006b2c g       .init_array	00000000 __exidx_end
08006338 g     F .text	00000042 DCD_EP_Open
08001fdc g     F .text	00000006 SPI_GetCRCPolynomial
08006928  w    F .text	00000004 EXTI3_IRQHandler
08002dbc g     F .text	00000022 TIM_ETRClockMode2Config
20000ccc g     O .bss	00000004 SET_TEST_MODE
08001be0 g     F .text	00000018 RCC_ITConfig
080027d0 g     F .text	00000010 TIM_OC1NPolarityConfig
08001854 g     F .text	00000018 RCC_PLLSAIConfig
080026a8 g     F .text	00000010 TIM_ForcedOC1Config
08005720 g     F .text	00000258 USBD_StdDevReq
08000e60 g     F .text	00000040 FLASH_ProgramHalfWord
080033f8 g     F .text	00000014 L3GD20_TIMEOUT_UserCallback
08002cb0 g     F .text	00000014 TIM_DMACmd
08002d94 g     F .text	00000028 TIM_ETRClockMode1Config
0800142c g     F .text	0000001a I2C_AnalogFilterCmd
08001edc g     F .text	0000001e SPI_BiDirectionalLineConfig
08004904 g     F .text	0000001c USBD_USR_InterfaceStrDescriptor
0800519c g     F .text	000000d0 LSM303DLHC_MEMS_Test
08002b90 g     F .text	00000016 TIM_SetIC3Prescaler
08006928  w    F .text	00000004 TIM1_UP_TIM10_IRQHandler
08001af0 g     F .text	00000018 RCC_AHB1PeriphResetCmd
080027a0 g     F .text	00000010 TIM_ClearOC3Ref
08000264 g     F .text	00000028 ADC_CommonInit
08006a3c g       .text	00000000 _etext
08000f8c g     F .text	00000018 FLASH_OB_RDPConfig
200005a0 g       .bss	00000000 _sbss
08000568 g     F .text	0000000c ADC_GetFlagStatus
200005e4 g     O .bss	00000004 USBD_ep_status
20000c74 g     O .bss	00000002 ConvData1
080018ac g     F .text	00000014 RCC_SYSCLKConfig
080006d0 g     F .text	00000070 DMA_Init
20000090 g     O .data	0000001c USR_cb
08006928  w    F .text	00000004 I2C3_ER_IRQHandler
08000934 g     F .text	0000001c EXTI_DeInit
08001780 g     F .text	00000038 RCC_WaitForHSEStartUp
08000fa4 g     F .text	00000028 FLASH_OB_UserConfig
080064a2 g     F .text	00000010 DCD_DevDisconnect
080007a4 g     F .text	00000006 DMA_GetCurrDataCounter
08000ba4 g     F .text	00000010 FLASH_OB_GetBOR
08000778 g     F .text	00000014 DMA_PeriphIncOffsetSizeConfig
0800051c g     F .text	00000014 ADC_InjectedDiscModeCmd
20000020 g     O .data	00000004 BUTTON_PORT
08000b54 g     F .text	00000010 FLASH_OB_GetUser
080019d8 g     F .text	0000000c RCC_BackupResetCmd
08004928 g     F .text	00000002 USBD_USR_DeviceSuspended
0800186c g     F .text	0000000c RCC_PLLSAICmd
08006ac2 g     O .rodata	00000060 sinebuf
08002c04 g     F .text	00000020 TIM_CtrlPWMOutputs
08001680 g     F .text	00000014 I2C_ITConfig
08002f40 g     F .text	00000014 NVIC_SetVectorTable
08000298 g     F .text	00000014 ADC_Cmd
08000bcc g     F .text	00000014 FLASH_GetFlagStatus
080002c4 g     F .text	0000000c ADC_AnalogWatchdogSingleChannelConfig
080059a8 g     F .text	000000c0 USBD_StdEPReq
080002ec g     F .text	0000001c ADC_VBATCmd
080003dc g     F .text	00000010 ADC_DiscModeChannelCountConfig
08001878 g     F .text	0000000c RCC_ClockSecuritySystemCmd
08004610 g     F .text	00000010 EXTI0_IRQHandler
08006928  w    F .text	00000004 I2C2_EV_IRQHandler
08001c2c g     F .text	00000010 RCC_ClearFlag
08000a58 g     F .text	0000001c FLASH_InstructionCacheCmd
08002410 g     F .text	0000001a TIM_Cmd
08006928  w    F .text	00000004 DMA1_Stream2_IRQHandler
20000028 g     O .data	00000004 AudioRemSize
08005684 g     F .text	0000001e USBD_CtlSendStatus
08002724 g     F .text	00000014 TIM_OC4PreloadConfig
08006928  w    F .text	00000004 FPU_IRQHandler
08005978 g     F .text	00000030 USBD_StdItfReq
20000058 g     O .data	00000004 SystemCoreClock
080037ac g     F .text	0000007c EVAL_AUDIO_SetAudioInterface
08000598 g     F .text	00000008 ADC_ClearITPendingBit
08000b64 g     F .text	0000000c FLASH_OB_GetWRP
20000030 g     O .data	00000004 AUDIO_MAL_DMA_FLAG_TE
080056c0 g     F .text	00000044 USBD_ParseSetupRequest
08003f44 g     F .text	000000b4 LSM303DLHC_I2C_Config
08001770 g     F .text	00000010 RCC_HSEConfig
00000000  w      *UND*	00000000 malloc
08002c80 g     F .text	00000008 TIM_ClearFlag
080064b4 g     F .text	00000428 USBD_OTG_ISR_Handler
08001270 g     F .text	00000008 GPIO_ToggleBits
08001fa8 g     F .text	0000001a SPI_CalculateCRC
08002ca0 g     F .text	00000008 TIM_ClearITPendingBit
08004452 g     F .text	00000002 UsageFault_Handler
080007a0 g     F .text	00000004 DMA_SetCurrDataCounter
200005d0 g     O .bss	00000002 counter0
08002380 g     F .text	00000004 TIM_GetCounter
08002024 g     F .text	00000008 SPI_I2S_ClearFlag
08001ad8 g     F .text	00000018 RCC_APB2PeriphClockCmd
200005c0 g     O .bss	00000004 AUDIO_MAL_DMA_CHANNEL
08001630 g     F .text	0000001a I2C_DMACmd
08002b54 g     F .text	00000004 TIM_GetCapture3
08005b38 g     F .text	000000d0 USB_OTG_SelectCore
08006928  w    F .text	00000004 DMA2_Stream2_IRQHandler
080015ec g     F .text	0000001e I2C_PECPositionConfig
0800113c g     F .text	000000bc GPIO_Init
08001804 g     F .text	00000024 RCC_PLLConfig
0800647a g     F .text	00000018 DCD_EP_Flush
08005d2c g     F .text	0000002a USB_OTG_SetCurrentMode
200005c5 g     O .bss	00000001 TempAcceleration
08000b00 g     F .text	00000010 FLASH_OB_Lock
080007d8 g     F .text	0000000a DMA_MemoryTargetConfig
08006a4c g     O .rodata	00000008 GPIO_PIN
20000000 g       .data	00000000 _sdata
08006928  w    F .text	00000004 SPI1_IRQHandler
080002ac g     F .text	00000010 ADC_AnalogWatchdogCmd
08002b4c g     F .text	00000004 TIM_GetCapture1
08001b98 g     F .text	00000018 RCC_AHB3PeriphClockLPModeCmd
08005d64 g     F .text	0000000a USB_OTG_ReadCoreItr
08002f6c g     F .text	00000018 SysTick_CLKSourceConfig
0800126c g     F .text	00000004 GPIO_Write
08000a74 g     F .text	0000001c FLASH_DataCacheCmd
08004920 g     F .text	00000002 USBD_USR_DeviceReset
08005630 g     F .text	0000000e USBD_ClrCfg
08001250 g     F .text	00000006 GPIO_ReadOutputData
0800253c g     F .text	0000008c TIM_OC3Init
080017d8 g     F .text	00000020 RCC_LSEConfig
08006928  w    F .text	00000004 TIM1_BRK_TIM9_IRQHandler
080055e0 g     F .text	00000038 USBD_Init
0800160c g     F .text	0000001a I2C_CalculatePEC
080019cc g     F .text	0000000c RCC_RTCCLKCmd
08000458 g     F .text	0000005a ADC_InjectedChannelConfig
08003ff8 g     F .text	00000294 LSM303DLHC_Read
08000900 g     F .text	00000034 DMA_ClearITPendingBit
080020f8 g     F .text	000001b8 TIM_DeInit
08001ac0 g     F .text	00000018 RCC_APB1PeriphClockCmd
08001c3c g     F .text	00000014 RCC_GetITStatus
08006b2c g       .init_array	00000000 __exidx_start
08006928  w    F .text	00000004 DMA2_Stream3_IRQHandler
08006b28 g     O .rodata	00000004 _global_impure_ptr
0800202c g     F .text	0000002a SPI_I2S_GetITStatus
08005672 g     F .text	00000012 USBD_CtlContinueRx
08002c74 g     F .text	0000000c TIM_GetFlagStatus
08001a90 g     F .text	00000018 RCC_AHB2PeriphClockCmd
08002018 g     F .text	0000000c SPI_I2S_GetFlagStatus
200005d2 g     O .bss	00000002 counter1
08000308 g     F .text	00000096 ADC_RegularChannelConfig
08001a54 g     F .text	00000018 RCC_LTDCCLKDivConfig
080033d0 g     F .text	00000028 Fail_Handler
0800275c g     F .text	00000010 TIM_OC3FastConfig
080015c4 g     F .text	00000004 I2C_SendData
08000b10 g     F .text	00000014 FLASH_OB_PCROPSelectionConfig
08000400 g     F .text	00000006 ADC_GetConversionValue
08002cc4 g     F .text	0000001a TIM_SelectCCDMA
08003ddc g     F .text	0000002e L3GD20_FilterCmd
08000b24 g     F .text	00000018 FLASH_OB_BootConfig
08000bb4 g     F .text	00000018 FLASH_ITConfig
08006928  w    F .text	00000004 USART6_IRQHandler
20000054 g     O .data	00000004 LSM303DLHC_Timeout
08006a24 g     F .text	00000000 _init
080020dc g     F .text	0000000c SYSCFG_CompensationCellCmd
08000740 g     F .text	00000022 DMA_StructInit
080023f8 g     F .text	00000016 TIM_SetClockDivision
08001ea8 g     F .text	0000001a I2S_Cmd
08001884 g     F .text	00000014 RCC_MCO1Config
08001f1c g     F .text	0000001a SPI_SSOutputCmd
08001a24 g     F .text	00000018 RCC_SAIBlockACLKConfig
08001ec4 g     F .text	00000016 SPI_DataSizeConfig
08000ad0 g     F .text	00000010 FLASH_Lock
0800130c g     F .text	000000e0 I2C_Init
080007fc g     F .text	0000003c DMA_GetFlagStatus
080002bc g     F .text	00000006 ADC_AnalogWatchdogThresholdsConfig
08000a24 g     F .text	0000000c EXTI_ClearITPendingBit
200005f0 g     O .bss	00000004 TimingDelay
08000ddc g     F .text	00000044 FLASH_ProgramDoubleWord
0800694c g     F .text	00000030 __libc_fini_array
20000d10 g       .bss	00000000 _ebss
080061ea g     F .text	0000000c USB_OTG_ReadDevAllInEPItr
0800242c g     F .text	00000080 TIM_OC1Init
08002714 g     F .text	00000010 TIM_OC3PreloadConfig
080068dc  w    F .text	00000038 Reset_Handler
0800617c g     F .text	00000028 USB_OTG_EPSetStall
0800123c g     F .text	00000006 GPIO_ReadInputData
0800237c g     F .text	00000004 TIM_SetAutoreload
08004884 g     F .text	0000001c USBD_USR_ManufacturerStrDescriptor
200005f4 g     O .bss	00000006 Buffer_Y
080053c8 g     F .text	0000001a USBD_HID_SendReport
0800043c g     F .text	0000001c ADC_MultiModeDMARequestAfterLastTransferCmd
200005bf g     O .bss	00000001 UserButtonPressed
08001bf8 g     F .text	00000034 RCC_GetFlagStatus
0800492a g     F .text	00000002 USBD_USR_DeviceResumed
0800428c g     F .text	00000120 LSM303DLHC_Write
08006928  w    F .text	00000004 DMA2_Stream0_IRQHandler
08006254 g     F .text	00000048 USB_OTG_StopDevice
200005fa g     O .bss	00000001 Y_Offset
08001258 g     F .text	00000004 GPIO_SetBits
08006928  w    F .text	00000004 TIM4_IRQHandler
080009f0 g     F .text	00000014 EXTI_GetFlagStatus
080004dc g     F .text	0000000c ADC_ExternalTrigInjectedConvConfig
080018c0 g     F .text	00000010 RCC_GetSYSCLKSource
080023c4 g     F .text	0000001a TIM_ARRPreloadConfig
08001260 g     F .text	0000000a GPIO_WriteBit
08004770 g     F .text	000000b0 USB_OTG_BSP_Init
08000508 g     F .text	00000014 ADC_AutoInjectedConvCmd
20000c78 g     O .bss	00000018 ADC_InitStructure
080048c4 g     F .text	00000024 USBD_USR_SerialStrDescriptor
0800145c g     F .text	0000001a I2C_GenerateSTART
080013ec g     F .text	00000022 I2C_StructInit
08006084 g     F .text	000000f8 USB_OTG_EP0StartXfer
00000000  w      *UND*	00000000 __deregister_frame_info
080056a2 g     F .text	0000001e USBD_CtlReceiveStatus
200005c4 g     O .bss	00000001 OutputDev
08006928  w    F .text	00000004 I2C1_EV_IRQHandler
080019f0 g     F .text	00000018 RCC_SAIPLLI2SClkDivConfig
08006928  w    F .text	00000004 DMA1_Stream6_IRQHandler
0800484c g     F .text	00000014 USB_OTG_BSP_uDelay
08002c88 g     F .text	00000016 TIM_GetITStatus
08001b20 g     F .text	00000018 RCC_AHB3PeriphResetCmd
08005d6e g     F .text	0000000c USB_OTG_InitDevSpeed
08004fd8 g     F .text	000000e8 Microphone_MEMS_Test
08005f80 g     F .text	00000104 USB_OTG_EPStartXfer
0800190c g     F .text	00000090 RCC_GetClocksFreq
08003bdc g     F .text	00000188 L3GD20_Init
08006928  w    F .text	00000004 DMA1_Stream1_IRQHandler
08000a3c g     F .text	0000001c FLASH_PrefetchBufferCmd
08005704 g     F .text	0000001c USBD_CtlError
08002648 g     F .text	00000050 TIM_SelectOCxM
08001bc8 g     F .text	00000018 RCC_APB2PeriphClockLPModeCmd
08001568 g     F .text	0000001e I2C_NACKPositionConfig
080009e0 g     F .text	00000010 EXTI_GenerateSWInterrupt
08005270 g     F .text	00000050 EVAL_AUDIO_GetSampleCallBack
20000010 g     O .data	00000010 GPIO_PORT
08002eac g     F .text	00000006 TIM_RemapConfig
08006928  w    F .text	00000004 TIM3_IRQHandler
08006928  w    F .text	00000004 RCC_IRQHandler
08006446 g     F .text	00000034 DCD_EP_ClrStall
080003a0 g     F .text	0000000a ADC_SoftwareStartConv
08002738 g     F .text	00000010 TIM_OC1FastConfig
08006928 g       .text	00000004 Default_Handler
08004922 g     F .text	00000002 USBD_USR_DeviceConfigured
08000bec g     F .text	00000040 FLASH_GetStatus
08000a04 g     F .text	0000000c EXTI_ClearFlag
080016bc g     F .text	00000036 I2C_GetFlagStatus
08000be0 g     F .text	0000000c FLASH_ClearFlag
0800164c g     F .text	0000001a I2C_DMALastTransferCmd
08000c2c g     F .text	00000026 FLASH_WaitForLastOperation
0800199c g     F .text	00000030 RCC_RTCCLKConfig
08002700 g     F .text	00000014 TIM_OC2PreloadConfig
08002de0 g     F .text	00000010 TIM_SelectInputTrigger
08000b7c g     F .text	0000000c FLASH_OB_GetPCROP
0800492c g     F .text	00000038 USBD_USR_Init
08006928  w    F .text	00000004 EXTI15_10_IRQHandler
08003470 g     F .text	00000018 STM_EVAL_LEDOff
08002c5c g     F .text	00000014 TIM_ITConfig
0800697c g     F .text	000000a8 __register_exitproc
08001588 g     F .text	0000001e I2C_SMBusAlertConfig
080024ac g     F .text	00000090 TIM_OC2Init
08006928  w    F .text	00000004 ADC_IRQHandler
08001a6c g     F .text	0000000c RCC_TIMCLKPresConfig
08000950 g     F .text	00000080 EXTI_Init
080061ce g     F .text	0000000c USB_OTG_ReadDevAllOutEp_itr
0800440a g     F .text	00000040 LSM303DLHC_AccFilterConfig
08000408 g     F .text	0000000c ADC_GetMultiModeConversionValue
08005d56 g     F .text	0000000e USB_OTG_IsDeviceMode
08001848 g     F .text	0000000c RCC_PLLI2SCmd
08005af0 g     F .text	00000026 USB_OTG_WritePacket
20000050 g     O .data	00000004 L3GD20Timeout
08003a68 g     F .text	000000b4 DMA1_Stream7_IRQHandler
08002360 g     F .text	00000006 TIM_PrescalerConfig
08001efc g     F .text	00000020 SPI_NSSInternalSoftwareConfig
080012a0 g     F .text	0000006c I2C_DeInit
08000a90 g     F .text	00000010 FLASH_InstructionCacheReset
20000048 g     O .data	00000004 AUDIO_MAL_DMA_FLAG_HT
08006412 g     F .text	00000034 DCD_EP_Stall
08001410 g     F .text	0000001a I2C_Cmd
0800125c g     F .text	00000004 GPIO_ResetBits
08002830 g     F .text	00000014 TIM_OC4PolarityConfig
08002df0 g     F .text	00000016 TIM_SelectOutputTrigger
08001448 g     F .text	00000012 I2C_DigitalFilterConfig
200005ca g     O .bss	00000001 Counter
08000b3c g     F .text	00000018 FLASH_OB_BORConfig
080016f4 g     F .text	00000008 I2C_ClearFlag
080061a4 g     F .text	0000002a USB_OTG_EPClearStall
08001fc4 g     F .text	0000000c SPI_TransmitCRC
08006928  w    F .text	00000004 TIM5_IRQHandler
080026a0 g     F .text	00000004 TIM_SetCompare3
08006928  w    F .text	00000004 DMA2_Stream7_IRQHandler
080025c8 g     F .text	0000006c TIM_OC4Init
08006928  w    F .text	00000004 I2C3_EV_IRQHandler
080007f4 g     F .text	00000008 DMA_GetFIFOStatus
08006a3c g     O .rodata	00000010 GPIO_CLK
080003ac g     F .text	00000008 ADC_GetSoftwareStartConvStatus
080004f4 g     F .text	0000000a ADC_SoftwareStartInjectedConv
08000f60 g     F .text	0000002c FLASH_OB_PCROP1Config
08002e90 g     F .text	0000001a TIM_SelectHallSensor
08006928  w    F .text	00000004 EXTI9_5_IRQHandler
080050c0 g     F .text	000000dc LSM303DLHC_CompassReadAcc
20000024 g     O .data	00000004 AUDIO_MAL_DMA_FLAG_FE
080063aa g     F .text	00000036 DCD_EP_PrepareRx
08000fcc g     F .text	00000014 FLASH_OB_Launch
08006928  w    F .text	00000004 RTC_WKUP_IRQHandler
200005fb g     O .bss	00000001 X_Offset
08001bb0 g     F .text	00000018 RCC_APB1PeriphClockLPModeCmd
08005eea g     F .text	00000058 USB_OTG_EPActivate
080052c0 g     F .text	00000002 Codec_TIMEOUT_UserCallback
08001494 g     F .text	00000012 I2C_Send7bitAddress
08002b5c g     F .text	00000016 TIM_SetIC1Prescaler
08001e78 g     F .text	00000012 I2S_StructInit
08005618 g     F .text	00000018 USBD_SetCfg
08001a08 g     F .text	0000001c RCC_SAIPLLSAIClkDivConfig
200005ce g     O .bss	00000002 Left_Right
08000d80 g     F .text	0000005c FLASH_EraseAllBank2Sectors
08001548 g     F .text	0000001e I2C_FastModeDutyCycleConfig
08000a10 g     F .text	00000014 EXTI_GetITStatus
08000b94 g     F .text	00000010 FLASH_OB_GetRDP
080026dc g     F .text	00000014 TIM_ForcedOC4Config
08006928  w    F .text	00000004 SPI2_IRQHandler
20000bfc g     O .bss	0000003c AUDIO_MAL_DMA_InitStructure
08000a30 g     F .text	0000000c FLASH_SetLatency
08002088 g     F .text	0000000c SYSCFG_MemoryRemapConfig
080007c4 g     F .text	00000014 DMA_DoubleBufferModeCmd
0800486c g     F .text	0000000c USBD_USR_DeviceDescriptor
0800444e g     F .text	00000002 MemManage_Handler
080017b8 g     F .text	00000014 RCC_AdjustHSICalibrationValue
080032ac g     F .text	00000110 main
08002058 g     F .text	00000012 SPI_I2S_ClearITPendingBit
080007e4 g     F .text	00000008 DMA_GetCurrentMemoryTarget
08006928  w    F .text	00000004 DMA1_Stream0_IRQHandler
08002cf0 g     F .text	0000001a TIM_ITRxExternalClockConfig
08000c54 g     F .text	00000074 FLASH_EraseSector
08002808 g     F .text	00000014 TIM_OC3PolarityConfig
08005db8 g     F .text	000000e8 USB_OTG_CoreInitDev
08005cb4 g     F .text	00000040 USB_OTG_FlushTxFifo
080070d8 g       *ABS*	00000000 _siccmram
08001b68 g     F .text	00000018 RCC_AHB1PeriphClockLPModeCmd
08004454 g     F .text	00000002 SVC_Handler
08001fe4 g     F .text	00000014 SPI_I2S_DMACmd
08002ce0 g     F .text	0000000e TIM_InternalClockConfig
080027c0 g     F .text	00000010 TIM_OC1PolarityConfig
08002748 g     F .text	00000014 TIM_OC2FastConfig
080018e4 g     F .text	00000014 RCC_PCLK1Config
08003d64 g     F .text	00000044 L3GD20_Read
08003828 g     F .text	00000240 EVAL_AUDIO_Init
080009d0 g     F .text	0000000e EXTI_StructInit
080007ec g     F .text	00000008 DMA_GetCmdStatus
00000000  w      *UND*	00000000 __libc_fini
08002378 g     F .text	00000004 TIM_SetCounter
080043ac g     F .text	0000005e LSM303DLHC_AccInit
20000078 g     O .data	00000004 USBD_LangIDDesc
08005ca4 g     F .text	0000000e USB_OTG_DisableGlobalInt
08006928  w    F .text	00000004 EXTI4_IRQHandler
200005bc g     O .bss	00000002 PrescalerValue
080061f6 g     F .text	0000003e USB_OTG_EP0_OutStart
080018f8 g     F .text	00000014 RCC_PCLK2Config
080026a4 g     F .text	00000004 TIM_SetCompare4
080014f4 g     F .text	0000001a I2C_GeneralCallCmd
08002b50 g     F .text	00000004 TIM_GetCapture2
08005c08 g     F .text	0000008e USB_OTG_CoreInit
200005e0 g     O .bss	00000004 USBD_cfg_status
08001e8c g     F .text	0000001a SPI_Cmd
08002384 g     F .text	00000006 TIM_GetPrescaler
08002790 g     F .text	00000010 TIM_ClearOC2Ref
08004964 g     F .text	000000a8 L3GD20_MEMS_Test
08001510 g     F .text	0000001a I2C_SoftwareResetCmd
0800465c g     F .text	00000114 SystemInit
200005e8 g     O .bss	00000004 USBD_default_cfg
20000038 g     O .data	00000004 AUDIO_MAL_DMA_FLAG_DME
200005cc g     O .bss	00000002 count
08002884 g     F .text	00000168 TIM_ICInit
08000fe0 g     F .text	0000015c GPIO_DeInit
080063e0 g     F .text	00000032 DCD_EP_Tx
08006a30 g     F .text	00000000 _fini
080004b4 g     F .text	00000010 ADC_InjectedSequencerLengthConfig
08000cc8 g     F .text	0000005c FLASH_EraseAllSectors
080020d0 g     F .text	0000000c SYSCFG_ETH_MediaInterfaceConfig
08001720 g     F .text	00000050 RCC_DeInit
20000044 g     O .data	00000004 AUDIO_MAL_DMA_IRQ
080029ec g     F .text	00000010 TIM_ICStructInit
08006940 g     F .text	0000000c atexit
080029fc g     F .text	0000014e TIM_PWMIConfig
08001898 g     F .text	00000014 RCC_MCO2Config
080007ac g     F .text	00000018 DMA_DoubleBufferModeConfig
10000000 g       .data	00000000 _eccmram
200000ac g     O .data	00000002 count1
0800028c g     F .text	0000000c ADC_CommonStructInit
08004926 g     F .text	00000002 USBD_USR_DeviceDisconnected
08000250 g     F .text	00000014 ADC_StructInit
0800054c g     F .text	0000001a ADC_ITConfig
08004820 g     F .text	0000002c USB_OTG_BSP_EnableInterrupt
080020e8 g     F .text	00000010 SYSCFG_GetCompensationCellStatus
080027f4 g     F .text	00000014 TIM_OC2NPolarityConfig
08002f54 g     F .text	00000018 NVIC_SystemLPConfig
08005660 g     F .text	00000012 USBD_CtlContinueSendData
08002780 g     F .text	00000010 TIM_ClearOC1Ref
08006928  w    F .text	00000004 WWDG_IRQHandler
08004878 g     F .text	0000000c USBD_USR_LangIDStrDescriptor
08001b80 g     F .text	00000018 RCC_AHB2PeriphClockLPModeCmd
08005ea0 g     F .text	00000020 USB_OTG_GetDeviceSpeed
08001b38 g     F .text	00000018 RCC_APB1PeriphResetCmd
08000574 g     F .text	00000006 ADC_ClearFlag
08000edc g     F .text	0000002c FLASH_OB_WRPConfig
200005fc g     O .bss	000005f4 USB_OTG_dev
0800086c g     F .text	00000040 DMA_ITConfig
08002f84 g     F .text	00000018 Delay
080016fc g     F .text	0000001c I2C_GetITStatus
08003520 g     F .text	00000014 STM_EVAL_PBGetState
08006928  w    F .text	00000004 TIM2_IRQHandler
200005be g     O .bss	00000001 DemoEnterCondition
080023a8 g     F .text	0000001a TIM_UpdateRequestConfig
080026cc g     F .text	00000010 TIM_ForcedOC3Config
08001f54 g     F .text	00000046 I2S_FullDuplexConfig
08002d0c g     F .text	00000088 TIM_TIxExternalClockConfig
0800152c g     F .text	0000001a I2C_StretchClockCmd
080011f8 g     F .text	00000012 GPIO_StructInit
08001a3c g     F .text	00000018 RCC_SAIBlockBCLKConfig
08003488 g     F .text	0000001c STM_EVAL_LEDToggle
08004620 g     F .text	00000030 OTG_FS_WKUP_IRQHandler
08006928  w    F .text	00000004 TIM1_TRG_COM_TIM11_IRQHandler
080001dc g     F .text	0000001a ADC_DeInit
08005a68 g     F .text	0000003c USBD_GetString
08002bf0 g     F .text	00000012 TIM_BDTRStructInit
08002634 g     F .text	00000014 TIM_OCStructInit
08000ea0 g     F .text	0000003c FLASH_ProgramByte
0800281c g     F .text	00000014 TIM_OC3NPolarityConfig
080001f8 g     F .text	00000058 ADC_Init
2000ffff g       *ABS*	00000000 _estack
08002864 g     F .text	00000020 TIM_CCxNCmd
080004c4 g     F .text	00000016 ADC_SetInjectedOffset
08006928  w    F .text	00000004 EXTI1_IRQHandler
08002e20 g     F .text	00000016 TIM_SelectMasterSlaveMode
08001668 g     F .text	00000018 I2C_ReadRegister
20000bf0 g     O .bss	00000006 Buffer_X
08002094 g     F .text	0000000c SYSCFG_MemorySwappingBank
080002d0 g     F .text	0000001c ADC_TempSensorVrefintCmd
08001fd0 g     F .text	0000000c SPI_GetCRC
200005a0 g       .data	00000000 _edata
08002b58 g     F .text	00000004 TIM_GetCapture4
08000d24 g     F .text	0000005c FLASH_EraseAllBank1Sectors
10000000 g       .data	00000000 _sccmram
08005d7c g     F .text	0000003c USB_OTG_EnableDevInt
080022b0 g     F .text	0000009c TIM_TimeBaseInit
08000530 g     F .text	0000001a ADC_GetInjectedConversionValue
08006928  w    F .text	00000004 USART2_IRQHandler
080048e8 g     F .text	0000001c USBD_USR_ConfigStrDescriptor
080020a0 g     F .text	0000002e SYSCFG_EXTILineConfig
080004e8 g     F .text	0000000c ADC_ExternalTrigInjectedConvEdgeConfig
08000b88 g     F .text	0000000c FLASH_OB_GetPCROP1
08000000 g     O .isr_vector	00000000 g_pfnVectors
08001628 g     F .text	00000008 I2C_GetPEC
0800563e g     F .text	00000022 USBD_CtlSendData
08002ca8 g     F .text	00000008 TIM_DMAConfig
080003ec g     F .text	00000014 ADC_DiscModeCmd
08001ff8 g     F .text	0000001e SPI_I2S_ITConfig
20000c90 g     O .bss	00000010 RCC_Clocks
08006928  w    F .text	00000004 I2C2_ER_IRQHandler
08005ec0 g     F .text	0000002a USB_OTG_EP0Activate
08002c70 g     F .text	00000004 TIM_GenerateEvent
080014d8 g     F .text	0000001a I2C_DualAddressCmd
08005b16 g     F .text	00000022 USB_OTG_ReadPacket
08006928  w    F .text	00000004 DMA2_Stream1_IRQHandler
080033bc g     F .text	00000014 TimingDelay_Decrement
08000838 g     F .text	00000034 DMA_ClearFlag
080003b4 g     F .text	00000014 ADC_EOCOnEachRegularChannelCmd
20000040 g     O .data	00000004 AUDIO_MAL_DMA_FLAG_TC
08002bc4 g     F .text	0000002a TIM_BDTRConfig
08006492 g     F .text	00000010 DCD_EP_SetAddress
08001aa8 g     F .text	00000018 RCC_AHB3PeriphClockCmd
080019e4 g     F .text	0000000c RCC_I2SCLKConfig
08006928  w    F .text	00000004 FLASH_IRQHandler
08006234 g     F .text	00000020 USB_OTG_UngateClock
20000cd0 g     O .bss	00000040 USBD_StrDesc
20000c38 g     O .bss	0000003c DMA_InitStructure
08006928  w    F .text	00000004 DMA2_Stream4_IRQHandler
0800120c g     F .text	00000024 GPIO_PinLockConfig
08004450 g     F .text	00000002 BusFault_Handler
08001a78 g     F .text	00000018 RCC_AHB1PeriphClockCmd
08006928  w    F .text	00000004 USART1_IRQHandler
0800526c g     F .text	00000002 EVAL_AUDIO_TransferComplete_CallBack
080017f8 g     F .text	0000000c RCC_LSICmd
080014a8 g     F .text	0000001a I2C_AcknowledgeConfig
08004650 g     F .text	0000000c OTG_FS_IRQHandler
08002b74 g     F .text	0000001a TIM_SetIC2Prescaler
08003b1c g     F .text	00000024 SPI3_IRQHandler
08002e38 g     F .text	00000018 TIM_ETRConfig
08006928  w    F .text	00000004 DMA1_Stream4_IRQHandler
08001694 g     F .text	00000018 I2C_CheckEvent
08001b50 g     F .text	00000018 RCC_APB2PeriphResetCmd
08002e08 g     F .text	00000016 TIM_SelectSlaveMode
08001478 g     F .text	0000001a I2C_GenerateSTOP
2000002c g     O .data	00000004 CODECTimeout
08006928  w    F .text	00000004 I2C1_ER_IRQHandler
08001e60 g     F .text	00000018 SPI_StructInit
08001d2c g     F .text	00000052 SPI_Init
08002eb4 g     F .text	00000014 NVIC_PriorityGroupConfig
08003458 g     F .text	00000018 STM_EVAL_LEDOn
080005a0 g     F .text	00000130 DMA_DeInit
20000ca0 g     O .bss	00000010 ADC_CommonInitStructure
20000cb0 g     O .bss	00000018 pBuffer
080027b0 g     F .text	00000010 TIM_ClearOC4Ref
080023e0 g     F .text	00000016 TIM_SelectOnePulseMode
08000428 g     F .text	00000014 ADC_DMARequestAfterLastTransferCmd
08002e50 g     F .text	0000003e TIM_EncoderInterfaceConfig
00000000  w      *UND*	00000000 _Jv_RegisterClasses
2000005c g     O .data	0000001c USR_desc
08000500 g     F .text	00000008 ADC_GetSoftwareStartInjectedConvCmdStatus
08001718 g     F .text	00000008 I2C_ClearITPendingBit
08002698 g     F .text	00000004 TIM_SetCompare1
0800078c g     F .text	00000014 DMA_FlowControllerConfig
08005f42 g     F .text	0000003e USB_OTG_EPDeactivate
080027e0 g     F .text	00000014 TIM_OC2PolarityConfig
08000f08 g     F .text	0000002c FLASH_OB_WRP1Config
0800238c g     F .text	0000001a TIM_UpdateDisableConfig
08001230 g     F .text	0000000c GPIO_ReadInputDataBit
00000000  w      *UND*	00000000 __register_frame_info
0800276c g     F .text	00000014 TIM_OC4FastConfig
08006928  w    F .text	00000004 DMA2_Stream6_IRQHandler
2000014c g     O .data	0000002c USBD_DCD_INT_cb
20000cc8 g     O .bss	00000002 ConvData2
08001d80 g     F .text	000000e0 I2S_Init
080018d0 g     F .text	00000014 RCC_HCLKConfig
08006928  w    F .text	00000004 DMA1_Stream3_IRQHandler
08004a0c g     F .text	00000430 USB_Test
08000b70 g     F .text	0000000c FLASH_OB_GetWRP1
08002368 g     F .text	00000010 TIM_CounterModeConfig
08005c96 g     F .text	0000000e USB_OTG_EnableGlobalInt



Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	; (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b113      	cbz	r3, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2301      	movs	r3, #1
 800019c:	7023      	strb	r3, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	200005a0 	.word	0x200005a0
 80001a4:	00000000 	.word	0x00000000
 80001a8:	08006a24 	.word	0x08006a24

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b06      	ldr	r3, [pc, #24]	; (80001c8 <frame_dummy+0x1c>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4806      	ldr	r0, [pc, #24]	; (80001cc <frame_dummy+0x20>)
 80001b4:	4906      	ldr	r1, [pc, #24]	; (80001d0 <frame_dummy+0x24>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	4806      	ldr	r0, [pc, #24]	; (80001d4 <frame_dummy+0x28>)
 80001bc:	6803      	ldr	r3, [r0, #0]
 80001be:	b113      	cbz	r3, 80001c6 <frame_dummy+0x1a>
 80001c0:	4b05      	ldr	r3, [pc, #20]	; (80001d8 <frame_dummy+0x2c>)
 80001c2:	b103      	cbz	r3, 80001c6 <frame_dummy+0x1a>
 80001c4:	4798      	blx	r3
 80001c6:	bd08      	pop	{r3, pc}
 80001c8:	00000000 	.word	0x00000000
 80001cc:	08006a24 	.word	0x08006a24
 80001d0:	200005a4 	.word	0x200005a4
 80001d4:	200005a0 	.word	0x200005a0
 80001d8:	00000000 	.word	0x00000000

080001dc <ADC_DeInit>:
  *         values.
  * @param  None
  * @retval None
  */
void ADC_DeInit(void)
{
 80001dc:	b508      	push	{r3, lr}
  /* Enable all ADCs reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
 80001de:	f44f 7080 	mov.w	r0, #256	; 0x100
 80001e2:	2101      	movs	r1, #1
 80001e4:	f001 fcb4 	bl	8001b50 <RCC_APB2PeriphResetCmd>
  
  /* Release all ADCs from reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
 80001e8:	f44f 7080 	mov.w	r0, #256	; 0x100
 80001ec:	2100      	movs	r1, #0
}
 80001ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* Enable all ADCs reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
  
  /* Release all ADCs from reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
 80001f2:	f001 bcad 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
 80001f6:	bf00      	nop

080001f8 <ADC_Init>:
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 80001f8:	6842      	ldr	r2, [r0, #4]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 80001fa:	f8d1 c00c 	ldr.w	ip, [r1, #12]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 80001fe:	4b13      	ldr	r3, [pc, #76]	; (800024c <ADC_Init+0x54>)
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8000200:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
  
  /* Clear RES and SCAN bits */
  tmpreg1 &= CR1_CLEAR_MASK;
 8000204:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8000208:	680c      	ldr	r4, [r1, #0]
 800020a:	f891 8004 	ldrb.w	r8, [r1, #4]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 800020e:	690f      	ldr	r7, [r1, #16]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 8000210:	688e      	ldr	r6, [r1, #8]
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 8000212:	794d      	ldrb	r5, [r1, #5]
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
  
  /* Clear RES and SCAN bits */
  tmpreg1 &= CR1_CLEAR_MASK;
 8000214:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8000218:	4322      	orrs	r2, r4
 800021a:	ea42 2208 	orr.w	r2, r2, r8, lsl #8
                                   ADC_InitStruct->ADC_Resolution);
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 800021e:	6042      	str	r2, [r0, #4]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 8000220:	6884      	ldr	r4, [r0, #8]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8000222:	ea4c 0207 	orr.w	r2, ip, r7
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 8000226:	4332      	orrs	r2, r6
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 8000228:	4023      	ands	r3, r4
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 800022a:	4313      	orrs	r3, r2
 800022c:	ea43 0345 	orr.w	r3, r3, r5, lsl #1
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8000230:	6083      	str	r3, [r0, #8]
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 8000232:	7d0b      	ldrb	r3, [r1, #20]
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8000234:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 8000236:	3b01      	subs	r3, #1
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 8000238:	b2db      	uxtb	r3, r3
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 800023a:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 800023e:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8000242:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 8000244:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8000248:	4770      	bx	lr
 800024a:	bf00      	nop
 800024c:	c0fff7fd 	.word	0xc0fff7fd

08000250 <ADC_StructInit>:
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8000250:	2300      	movs	r3, #0

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;

  /* Initialize the ADC_NbrOfConversion member */
  ADC_InitStruct->ADC_NbrOfConversion = 1;
 8000252:	2201      	movs	r2, #1
 8000254:	7502      	strb	r2, [r0, #20]
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8000256:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8000258:	7103      	strb	r3, [r0, #4]

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 800025a:	7143      	strb	r3, [r0, #5]

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 800025c:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 800025e:	60c3      	str	r3, [r0, #12]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8000260:	6103      	str	r3, [r0, #16]
 8000262:	4770      	bx	lr

08000264 <ADC_CommonInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 8000264:	b470      	push	{r4, r5, r6}
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8000266:	e890 0042 	ldmia.w	r0, {r1, r6}
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 800026a:	4a06      	ldr	r2, [pc, #24]	; (8000284 <ADC_CommonInit+0x20>)
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
                        ADC_CommonInitStruct->ADC_Prescaler | 
 800026c:	6885      	ldr	r5, [r0, #8]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 800026e:	68c4      	ldr	r4, [r0, #12]
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 8000270:	4b05      	ldr	r3, [pc, #20]	; (8000288 <ADC_CommonInit+0x24>)
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 8000272:	6850      	ldr	r0, [r2, #4]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8000274:	4331      	orrs	r1, r6
                        ADC_CommonInitStruct->ADC_Prescaler | 
 8000276:	4329      	orrs	r1, r5
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8000278:	4321      	orrs	r1, r4
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 800027a:	4003      	ands	r3, r0
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 800027c:	430b      	orrs	r3, r1
                        ADC_CommonInitStruct->ADC_Prescaler | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 800027e:	6053      	str	r3, [r2, #4]
}
 8000280:	bc70      	pop	{r4, r5, r6}
 8000282:	4770      	bx	lr
 8000284:	40012300 	.word	0x40012300
 8000288:	fffc30e0 	.word	0xfffc30e0

0800028c <ADC_CommonStructInit>:
  * @retval None
  */
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
 800028c:	2300      	movs	r3, #0
 800028e:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_Prescaler member */
  ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
 8000290:	6043      	str	r3, [r0, #4]

  /* Initialize the ADC_DMAAccessMode member */
  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8000292:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_TwoSamplingDelay member */
  ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 8000294:	60c3      	str	r3, [r0, #12]
 8000296:	4770      	bx	lr

08000298 <ADC_Cmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 8000298:	6883      	ldr	r3, [r0, #8]
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800029a:	b919      	cbnz	r1, 80002a4 <ADC_Cmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 800029c:	f023 0301 	bic.w	r3, r3, #1
 80002a0:	6083      	str	r3, [r0, #8]
 80002a2:	4770      	bx	lr
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 80002a4:	f043 0301 	orr.w	r3, r3, #1
 80002a8:	6083      	str	r3, [r0, #8]
 80002aa:	4770      	bx	lr

080002ac <ADC_AnalogWatchdogCmd>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 80002ac:	6843      	ldr	r3, [r0, #4]
  
  /* Clear AWDEN, JAWDEN and AWDSGL bits */
  tmpreg &= CR1_AWDMode_RESET;
 80002ae:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 80002b2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
 80002b6:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 80002b8:	6041      	str	r1, [r0, #4]
 80002ba:	4770      	bx	lr

080002bc <ADC_AnalogWatchdogThresholdsConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  
  /* Set the ADCx high threshold */
  ADCx->HTR = HighThreshold;
 80002bc:	6241      	str	r1, [r0, #36]	; 0x24
  
  /* Set the ADCx low threshold */
  ADCx->LTR = LowThreshold;
 80002be:	6282      	str	r2, [r0, #40]	; 0x28
 80002c0:	4770      	bx	lr
 80002c2:	bf00      	nop

080002c4 <ADC_AnalogWatchdogSingleChannelConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 80002c4:	6843      	ldr	r3, [r0, #4]
  
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= CR1_AWDCH_RESET;
 80002c6:	f023 031f 	bic.w	r3, r3, #31
  
  /* Set the Analog watchdog channel */
  tmpreg |= ADC_Channel;
 80002ca:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 80002cc:	6041      	str	r1, [r0, #4]
 80002ce:	4770      	bx	lr

080002d0 <ADC_TempSensorVrefintCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
 80002d0:	4b05      	ldr	r3, [pc, #20]	; (80002e8 <ADC_TempSensorVrefintCmd+0x18>)
 80002d2:	685a      	ldr	r2, [r3, #4]
  */
void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80002d4:	b918      	cbnz	r0, 80002de <ADC_TempSensorVrefintCmd+0xe>
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
  }
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
 80002d6:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 80002da:	605a      	str	r2, [r3, #4]
 80002dc:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
 80002de:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80002e2:	605a      	str	r2, [r3, #4]
 80002e4:	4770      	bx	lr
 80002e6:	bf00      	nop
 80002e8:	40012300 	.word	0x40012300

080002ec <ADC_VBATCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
 80002ec:	4b05      	ldr	r3, [pc, #20]	; (8000304 <ADC_VBATCmd+0x18>)
 80002ee:	685a      	ldr	r2, [r3, #4]
  */
void ADC_VBATCmd(FunctionalState NewState)                             
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80002f0:	b918      	cbnz	r0, 80002fa <ADC_VBATCmd+0xe>
    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
  }
  else
  {
    /* Disable the VBAT channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
 80002f2:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 80002f6:	605a      	str	r2, [r3, #4]
 80002f8:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
 80002fa:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80002fe:	605a      	str	r2, [r3, #4]
 8000300:	4770      	bx	lr
 8000302:	bf00      	nop
 8000304:	40012300 	.word	0x40012300

08000308 <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8000308:	2909      	cmp	r1, #9
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 800030a:	b470      	push	{r4, r5, r6}
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 800030c:	d91e      	bls.n	800034c <ADC_RegularChannelConfig+0x44>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 800030e:	f1a1 040a 	sub.w	r4, r1, #10
 8000312:	eb04 0444 	add.w	r4, r4, r4, lsl #1
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8000316:	68c5      	ldr	r5, [r0, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 8000318:	2607      	movs	r6, #7
 800031a:	40a6      	lsls	r6, r4
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 800031c:	fa03 f404 	lsl.w	r4, r3, r4
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8000320:	ea25 0306 	bic.w	r3, r5, r6
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8000324:	4323      	orrs	r3, r4
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8000326:	2a06      	cmp	r2, #6
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8000328:	60c3      	str	r3, [r0, #12]
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 800032a:	d91c      	bls.n	8000366 <ADC_RegularChannelConfig+0x5e>
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 800032c:	2a0c      	cmp	r2, #12
 800032e:	d928      	bls.n	8000382 <ADC_RegularChannelConfig+0x7a>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 8000330:	3a0d      	subs	r2, #13
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8000332:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 8000334:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8000338:	231f      	movs	r3, #31
 800033a:	4093      	lsls	r3, r2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 800033c:	ea24 0303 	bic.w	r3, r4, r3
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 8000340:	fa01 f202 	lsl.w	r2, r1, r2
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8000344:	431a      	orrs	r2, r3
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 8000346:	62c2      	str	r2, [r0, #44]	; 0x2c
  }
}
 8000348:	bc70      	pop	{r4, r5, r6}
 800034a:	4770      	bx	lr
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 800034c:	eb01 0441 	add.w	r4, r1, r1, lsl #1
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8000350:	6905      	ldr	r5, [r0, #16]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 8000352:	2607      	movs	r6, #7
 8000354:	40a6      	lsls	r6, r4
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8000356:	fa03 f404 	lsl.w	r4, r3, r4
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 800035a:	ea25 0306 	bic.w	r3, r5, r6
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 800035e:	4323      	orrs	r3, r4
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8000360:	2a06      	cmp	r2, #6
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8000362:	6103      	str	r3, [r0, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8000364:	d8e2      	bhi.n	800032c <ADC_RegularChannelConfig+0x24>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 8000366:	3a01      	subs	r2, #1
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8000368:	6b44      	ldr	r4, [r0, #52]	; 0x34
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 800036a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800036e:	231f      	movs	r3, #31
 8000370:	4093      	lsls	r3, r2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8000372:	ea24 0303 	bic.w	r3, r4, r3
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 8000376:	fa01 f202 	lsl.w	r2, r1, r2
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800037a:	431a      	orrs	r2, r3
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 800037c:	6342      	str	r2, [r0, #52]	; 0x34
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 800037e:	bc70      	pop	{r4, r5, r6}
 8000380:	4770      	bx	lr
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 8000382:	3a07      	subs	r2, #7
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8000384:	6b04      	ldr	r4, [r0, #48]	; 0x30
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 8000386:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800038a:	231f      	movs	r3, #31
 800038c:	4093      	lsls	r3, r2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 800038e:	ea24 0303 	bic.w	r3, r4, r3
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 8000392:	fa01 f202 	lsl.w	r2, r1, r2
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8000396:	431a      	orrs	r2, r3
    
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8000398:	6302      	str	r2, [r0, #48]	; 0x30
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 800039a:	bc70      	pop	{r4, r5, r6}
 800039c:	4770      	bx	lr
 800039e:	bf00      	nop

080003a0 <ADC_SoftwareStartConv>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80003a0:	6883      	ldr	r3, [r0, #8]
 80003a2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80003a6:	6083      	str	r3, [r0, #8]
 80003a8:	4770      	bx	lr
 80003aa:	bf00      	nop

080003ac <ADC_GetSoftwareStartConvStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of SWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
 80003ac:	6880      	ldr	r0, [r0, #8]
    bitstatus = RESET;
  }
  
  /* Return the SWSTART bit status */
  return  bitstatus;
}
 80003ae:	f3c0 7080 	ubfx	r0, r0, #30, #1
 80003b2:	4770      	bx	lr

080003b4 <ADC_EOCOnEachRegularChannelCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
 80003b4:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80003b6:	b919      	cbnz	r1, 80003c0 <ADC_EOCOnEachRegularChannelCmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
  }
  else
  {
    /* Disable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
 80003b8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80003bc:	6083      	str	r3, [r0, #8]
 80003be:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
 80003c0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80003c4:	6083      	str	r3, [r0, #8]
 80003c6:	4770      	bx	lr

080003c8 <ADC_ContinuousModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC continuous conversion mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
 80003c8:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80003ca:	b919      	cbnz	r1, 80003d4 <ADC_ContinuousModeCmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
  }
  else
  {
    /* Disable the selected ADC continuous conversion mode */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
 80003cc:	f023 0302 	bic.w	r3, r3, #2
 80003d0:	6083      	str	r3, [r0, #8]
 80003d2:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC continuous conversion mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
 80003d4:	f043 0302 	orr.w	r3, r3, #2
 80003d8:	6083      	str	r3, [r0, #8]
 80003da:	4770      	bx	lr

080003dc <ADC_DiscModeChannelCountConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
 80003dc:	6843      	ldr	r3, [r0, #4]
  
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_RESET;
  
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
 80003de:	3901      	subs	r1, #1
  
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
  
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_RESET;
 80003e0:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
  
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 13;
 80003e4:	ea43 3141 	orr.w	r1, r3, r1, lsl #13
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg1;
 80003e8:	6041      	str	r1, [r0, #4]
 80003ea:	4770      	bx	lr

080003ec <ADC_DiscModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80003ec:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80003ee:	b919      	cbnz	r1, 80003f8 <ADC_DiscModeCmd+0xc>
    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
 80003f0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80003f4:	6043      	str	r3, [r0, #4]
 80003f6:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80003f8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80003fc:	6043      	str	r3, [r0, #4]
 80003fe:	4770      	bx	lr

08000400 <ADC_GetConversionValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 8000400:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
 8000402:	b280      	uxth	r0, r0
 8000404:	4770      	bx	lr
 8000406:	bf00      	nop

08000408 <ADC_GetMultiModeConversionValue>:
  *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
  */
uint32_t ADC_GetMultiModeConversionValue(void)
{
  /* Return the multi mode conversion value */
  return (*(__IO uint32_t *) CDR_ADDRESS);
 8000408:	4b01      	ldr	r3, [pc, #4]	; (8000410 <ADC_GetMultiModeConversionValue+0x8>)
 800040a:	6818      	ldr	r0, [r3, #0]
}
 800040c:	4770      	bx	lr
 800040e:	bf00      	nop
 8000410:	40012308 	.word	0x40012308

08000414 <ADC_DMACmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 8000414:	6883      	ldr	r3, [r0, #8]
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000416:	b919      	cbnz	r1, 8000420 <ADC_DMACmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
 8000418:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800041c:	6083      	str	r3, [r0, #8]
 800041e:	4770      	bx	lr
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 8000420:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000424:	6083      	str	r3, [r0, #8]
 8000426:	4770      	bx	lr

08000428 <ADC_DMARequestAfterLastTransferCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
 8000428:	6883      	ldr	r3, [r0, #8]
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800042a:	b919      	cbnz	r1, 8000434 <ADC_DMARequestAfterLastTransferCmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
 800042c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000430:	6083      	str	r3, [r0, #8]
 8000432:	4770      	bx	lr
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
 8000434:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000438:	6083      	str	r3, [r0, #8]
 800043a:	4770      	bx	lr

0800043c <ADC_MultiModeDMARequestAfterLastTransferCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
 800043c:	4b05      	ldr	r3, [pc, #20]	; (8000454 <ADC_MultiModeDMARequestAfterLastTransferCmd+0x18>)
 800043e:	685a      	ldr	r2, [r3, #4]
  */
void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000440:	b918      	cbnz	r0, 800044a <ADC_MultiModeDMARequestAfterLastTransferCmd+0xe>
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
 8000442:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8000446:	605a      	str	r2, [r3, #4]
 8000448:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
 800044a:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800044e:	605a      	str	r2, [r3, #4]
 8000450:	4770      	bx	lr
 8000452:	bf00      	nop
 8000454:	40012300 	.word	0x40012300

08000458 <ADC_InjectedChannelConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8000458:	2909      	cmp	r1, #9
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 800045a:	b470      	push	{r4, r5, r6}
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 800045c:	d81b      	bhi.n	8000496 <ADC_InjectedChannelConfig+0x3e>
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 800045e:	eb01 0441 	add.w	r4, r1, r1, lsl #1
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8000462:	6905      	ldr	r5, [r0, #16]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 8000464:	2607      	movs	r6, #7
 8000466:	40a6      	lsls	r6, r4
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8000468:	fa03 f404 	lsl.w	r4, r3, r4
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 800046c:	ea25 0306 	bic.w	r3, r5, r6
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8000470:	4323      	orrs	r3, r4
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8000472:	6103      	str	r3, [r0, #16]
  }
  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 8000474:	6b83      	ldr	r3, [r0, #56]	; 0x38
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 8000476:	3202      	adds	r2, #2
  }
  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
 8000478:	f3c3 5401 	ubfx	r4, r3, #20, #2
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 800047c:	1b12      	subs	r2, r2, r4
 800047e:	b2d2      	uxtb	r2, r2
 8000480:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8000484:	241f      	movs	r4, #31
 8000486:	4094      	lsls	r4, r2
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
 8000488:	ea23 0304 	bic.w	r3, r3, r4
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 800048c:	4091      	lsls	r1, r2
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
 800048e:	430b      	orrs	r3, r1
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 8000490:	6383      	str	r3, [r0, #56]	; 0x38
}
 8000492:	bc70      	pop	{r4, r5, r6}
 8000494:	4770      	bx	lr
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
 8000496:	f1a1 040a 	sub.w	r4, r1, #10
 800049a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 800049e:	68c5      	ldr	r5, [r0, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
 80004a0:	2607      	movs	r6, #7
 80004a2:	40a6      	lsls	r6, r4
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
 80004a4:	fa03 f404 	lsl.w	r4, r3, r4
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 80004a8:	ea25 0306 	bic.w	r3, r5, r6
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 80004ac:	4323      	orrs	r3, r4
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 80004ae:	60c3      	str	r3, [r0, #12]
 80004b0:	e7e0      	b.n	8000474 <ADC_InjectedChannelConfig+0x1c>
 80004b2:	bf00      	nop

080004b4 <ADC_InjectedSequencerLengthConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 80004b4:	6b83      	ldr	r3, [r0, #56]	; 0x38
  
  /* Clear the old injected sequence length JL bits */
  tmpreg1 &= JSQR_JL_RESET;
  
  /* Set the injected sequence length JL bits */
  tmpreg2 = Length - 1; 
 80004b6:	3901      	subs	r1, #1
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  
  /* Clear the old injected sequence length JL bits */
  tmpreg1 &= JSQR_JL_RESET;
 80004b8:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
  
  /* Set the injected sequence length JL bits */
  tmpreg2 = Length - 1; 
  tmpreg1 |= tmpreg2 << 20;
 80004bc:	ea43 5101 	orr.w	r1, r3, r1, lsl #20
  
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 80004c0:	6381      	str	r1, [r0, #56]	; 0x38
 80004c2:	4770      	bx	lr

080004c4 <ADC_SetInjectedOffset>:
  * @param  Offset: the offset value for the selected ADC injected channel
  *          This parameter must be a 12bit value.
  * @retval None
  */
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
{
 80004c4:	b082      	sub	sp, #8
    __IO uint32_t tmp = 0;
 80004c6:	2300      	movs	r3, #0
 80004c8:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_OFFSET(Offset));
  
  tmp = (uint32_t)ADCx;
 80004ca:	9001      	str	r0, [sp, #4]
  tmp += ADC_InjectedChannel;
 80004cc:	9b01      	ldr	r3, [sp, #4]
 80004ce:	4419      	add	r1, r3
 80004d0:	9101      	str	r1, [sp, #4]
  
  /* Set the selected injected channel data offset */
 *(__IO uint32_t *) tmp = (uint32_t)Offset;
 80004d2:	9b01      	ldr	r3, [sp, #4]
 80004d4:	601a      	str	r2, [r3, #0]
}
 80004d6:	b002      	add	sp, #8
 80004d8:	4770      	bx	lr
 80004da:	bf00      	nop

080004dc <ADC_ExternalTrigInjectedConvConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
  
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 80004dc:	6883      	ldr	r3, [r0, #8]
  
  /* Clear the old external event selection for injected group */
  tmpreg &= CR2_JEXTSEL_RESET;
 80004de:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
  
  /* Set the external event selection for injected group */
  tmpreg |= ADC_ExternalTrigInjecConv;
 80004e2:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 80004e4:	6081      	str	r1, [r0, #8]
 80004e6:	4770      	bx	lr

080004e8 <ADC_ExternalTrigInjectedConvEdgeConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 80004e8:	6883      	ldr	r3, [r0, #8]
  /* Clear the old external trigger edge for injected group */
  tmpreg &= CR2_JEXTEN_RESET;
 80004ea:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
  /* Set the new external trigger edge for injected group */
  tmpreg |= ADC_ExternalTrigInjecConvEdge;
 80004ee:	4319      	orrs	r1, r3
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 80004f0:	6081      	str	r1, [r0, #8]
 80004f2:	4770      	bx	lr

080004f4 <ADC_SoftwareStartInjectedConv>:
void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC conversion for injected group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
 80004f4:	6883      	ldr	r3, [r0, #8]
 80004f6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80004fa:	6083      	str	r3, [r0, #8]
 80004fc:	4770      	bx	lr
 80004fe:	bf00      	nop

08000500 <ADC_GetSoftwareStartInjectedConvCmdStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of JSWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
 8000500:	6880      	ldr	r0, [r0, #8]
    /* JSWSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the JSWSTART bit status */
  return  bitstatus;
}
 8000502:	f3c0 5080 	ubfx	r0, r0, #22, #1
 8000506:	4770      	bx	lr

08000508 <ADC_AutoInjectedConvCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
 8000508:	6843      	ldr	r3, [r0, #4]
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800050a:	b919      	cbnz	r1, 8000514 <ADC_AutoInjectedConvCmd+0xc>
    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
 800050c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000510:	6043      	str	r3, [r0, #4]
 8000512:	4770      	bx	lr
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
 8000514:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000518:	6043      	str	r3, [r0, #4]
 800051a:	4770      	bx	lr

0800051c <ADC_InjectedDiscModeCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
 800051c:	6843      	ldr	r3, [r0, #4]
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800051e:	b919      	cbnz	r1, 8000528 <ADC_InjectedDiscModeCmd+0xc>
    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
 8000520:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000524:	6043      	str	r3, [r0, #4]
 8000526:	4770      	bx	lr
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
 8000528:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800052c:	6043      	str	r3, [r0, #4]
 800052e:	4770      	bx	lr

08000530 <ADC_GetInjectedConversionValue>:
  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
{
 8000530:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8000532:	2300      	movs	r3, #0
 8000534:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));

  tmp = (uint32_t)ADCx;
 8000536:	9001      	str	r0, [sp, #4]
  tmp += ADC_InjectedChannel + JDR_OFFSET;
 8000538:	9b01      	ldr	r3, [sp, #4]
 800053a:	3328      	adds	r3, #40	; 0x28
 800053c:	4419      	add	r1, r3
 800053e:	9101      	str	r1, [sp, #4]
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp); 
 8000540:	9b01      	ldr	r3, [sp, #4]
 8000542:	6818      	ldr	r0, [r3, #0]
}
 8000544:	b280      	uxth	r0, r0
 8000546:	b002      	add	sp, #8
 8000548:	4770      	bx	lr
 800054a:	bf00      	nop

0800054c <ADC_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT)); 

  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
  itmask = (uint32_t)0x01 << itmask;    
 800054c:	2301      	movs	r3, #1
 800054e:	b2c9      	uxtb	r1, r1
 8000550:	fa03 f101 	lsl.w	r1, r3, r1

  if (NewState != DISABLE)
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
 8000554:	6843      	ldr	r3, [r0, #4]

  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
  itmask = (uint32_t)0x01 << itmask;    

  if (NewState != DISABLE)
 8000556:	b91a      	cbnz	r2, 8000560 <ADC_ITConfig+0x14>
    ADCx->CR1 |= itmask;
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(uint32_t)itmask);
 8000558:	ea23 0101 	bic.w	r1, r3, r1
 800055c:	6041      	str	r1, [r0, #4]
 800055e:	4770      	bx	lr
  itmask = (uint32_t)0x01 << itmask;    

  if (NewState != DISABLE)
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
 8000560:	4319      	orrs	r1, r3
 8000562:	6041      	str	r1, [r0, #4]
 8000564:	4770      	bx	lr
 8000566:	bf00      	nop

08000568 <ADC_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
 8000568:	6803      	ldr	r3, [r0, #0]
 800056a:	4219      	tst	r1, r3
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 800056c:	bf0c      	ite	eq
 800056e:	2000      	moveq	r0, #0
 8000570:	2001      	movne	r0, #1
 8000572:	4770      	bx	lr

08000574 <ADC_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));

  /* Clear the selected ADC flags */
  ADCx->SR = ~(uint32_t)ADC_FLAG;
 8000574:	43c9      	mvns	r1, r1
 8000576:	6001      	str	r1, [r0, #0]
 8000578:	4770      	bx	lr
 800057a:	bf00      	nop

0800057c <ADC_GetITStatus>:

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
 800057c:	6843      	ldr	r3, [r0, #4]

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
 800057e:	6800      	ldr	r0, [r0, #0]
 8000580:	ea10 2011 	ands.w	r0, r0, r1, lsr #8
 8000584:	d007      	beq.n	8000596 <ADC_GetITStatus+0x1a>

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
 8000586:	b2c9      	uxtb	r1, r1
 8000588:	2201      	movs	r2, #1
 800058a:	fa02 f101 	lsl.w	r1, r2, r1

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
 800058e:	4219      	tst	r1, r3
  {
    /* ADC_IT is set */
    bitstatus = SET;
 8000590:	bf0c      	ite	eq
 8000592:	2000      	moveq	r0, #0
 8000594:	2001      	movne	r0, #1
    /* ADC_IT is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_IT status */
  return  bitstatus;
}
 8000596:	4770      	bx	lr

08000598 <ADC_ClearITPendingBit>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT)); 
  /* Get the ADC IT index */
  itmask = (uint8_t)(ADC_IT >> 8);
  /* Clear the selected ADC interrupt pending bits */
  ADCx->SR = ~(uint32_t)itmask;
 8000598:	ea6f 2111 	mvn.w	r1, r1, lsr #8
 800059c:	6001      	str	r1, [r0, #0]
 800059e:	4770      	bx	lr

080005a0 <DMA_DeInit>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *         to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
{
 80005a0:	b410      	push	{r4}

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 80005a2:	4a37      	ldr	r2, [pc, #220]	; (8000680 <DMA_DeInit+0xe0>)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 80005a4:	6804      	ldr	r4, [r0, #0]

  /* Reset DMAy Streamx control register */
  DMAy_Streamx->CR  = 0;
 80005a6:	2300      	movs	r3, #0
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 80005a8:	f024 0401 	bic.w	r4, r4, #1

  /* Reset DMAy Streamx memory 1 address register */
  DMAy_Streamx->M1AR = 0;

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 80005ac:	2121      	movs	r1, #33	; 0x21

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 80005ae:	4290      	cmp	r0, r2
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 80005b0:	6004      	str	r4, [r0, #0]

  /* Reset DMAy Streamx control register */
  DMAy_Streamx->CR  = 0;
 80005b2:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Streamx Number of Data to Transfer register */
  DMAy_Streamx->NDTR = 0;
 80005b4:	6043      	str	r3, [r0, #4]
  
  /* Reset DMAy Streamx peripheral address register */
  DMAy_Streamx->PAR  = 0;
 80005b6:	6083      	str	r3, [r0, #8]
  
  /* Reset DMAy Streamx memory 0 address register */
  DMAy_Streamx->M0AR = 0;
 80005b8:	60c3      	str	r3, [r0, #12]

  /* Reset DMAy Streamx memory 1 address register */
  DMAy_Streamx->M1AR = 0;
 80005ba:	6103      	str	r3, [r0, #16]

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 80005bc:	6141      	str	r1, [r0, #20]

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 80005be:	d04d      	beq.n	800065c <DMA_DeInit+0xbc>
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream1)
 80005c0:	4b30      	ldr	r3, [pc, #192]	; (8000684 <DMA_DeInit+0xe4>)
 80005c2:	4298      	cmp	r0, r3
 80005c4:	d035      	beq.n	8000632 <DMA_DeInit+0x92>
  {
    /* Reset interrupt pending bits for DMA1 Stream1 */
    DMA1->LIFCR = DMA_Stream1_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream2)
 80005c6:	4b30      	ldr	r3, [pc, #192]	; (8000688 <DMA_DeInit+0xe8>)
 80005c8:	4298      	cmp	r0, r3
 80005ca:	d039      	beq.n	8000640 <DMA_DeInit+0xa0>
  {
    /* Reset interrupt pending bits for DMA1 Stream2 */
    DMA1->LIFCR = DMA_Stream2_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream3)
 80005cc:	4b2f      	ldr	r3, [pc, #188]	; (800068c <DMA_DeInit+0xec>)
 80005ce:	4298      	cmp	r0, r3
 80005d0:	d03d      	beq.n	800064e <DMA_DeInit+0xae>
  {
    /* Reset interrupt pending bits for DMA1 Stream3 */
    DMA1->LIFCR = DMA_Stream3_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream4)
 80005d2:	4b2f      	ldr	r3, [pc, #188]	; (8000690 <DMA_DeInit+0xf0>)
 80005d4:	4298      	cmp	r0, r3
 80005d6:	d047      	beq.n	8000668 <DMA_DeInit+0xc8>
  {
    /* Reset interrupt pending bits for DMA1 Stream4 */
    DMA1->HIFCR = DMA_Stream4_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream5)
 80005d8:	4b2e      	ldr	r3, [pc, #184]	; (8000694 <DMA_DeInit+0xf4>)
 80005da:	4298      	cmp	r0, r3
 80005dc:	d048      	beq.n	8000670 <DMA_DeInit+0xd0>
  {
    /* Reset interrupt pending bits for DMA1 Stream5 */
    DMA1->HIFCR = DMA_Stream5_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream6)
 80005de:	4b2e      	ldr	r3, [pc, #184]	; (8000698 <DMA_DeInit+0xf8>)
 80005e0:	4298      	cmp	r0, r3
 80005e2:	d01d      	beq.n	8000620 <DMA_DeInit+0x80>
  {
    /* Reset interrupt pending bits for DMA1 Stream6 */
    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream7)
 80005e4:	4b2d      	ldr	r3, [pc, #180]	; (800069c <DMA_DeInit+0xfc>)
 80005e6:	4298      	cmp	r0, r3
 80005e8:	d01e      	beq.n	8000628 <DMA_DeInit+0x88>
  {
    /* Reset interrupt pending bits for DMA1 Stream7 */
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream0)
 80005ea:	4b2d      	ldr	r3, [pc, #180]	; (80006a0 <DMA_DeInit+0x100>)
 80005ec:	4298      	cmp	r0, r3
 80005ee:	d043      	beq.n	8000678 <DMA_DeInit+0xd8>
  {
    /* Reset interrupt pending bits for DMA2 Stream0 */
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream1)
 80005f0:	4b2c      	ldr	r3, [pc, #176]	; (80006a4 <DMA_DeInit+0x104>)
 80005f2:	4298      	cmp	r0, r3
 80005f4:	d01d      	beq.n	8000632 <DMA_DeInit+0x92>
  {
    /* Reset interrupt pending bits for DMA2 Stream1 */
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream2)
 80005f6:	4b2c      	ldr	r3, [pc, #176]	; (80006a8 <DMA_DeInit+0x108>)
 80005f8:	4298      	cmp	r0, r3
 80005fa:	d021      	beq.n	8000640 <DMA_DeInit+0xa0>
  {
    /* Reset interrupt pending bits for DMA2 Stream2 */
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream3)
 80005fc:	4b2b      	ldr	r3, [pc, #172]	; (80006ac <DMA_DeInit+0x10c>)
 80005fe:	4298      	cmp	r0, r3
 8000600:	d025      	beq.n	800064e <DMA_DeInit+0xae>
  {
    /* Reset interrupt pending bits for DMA2 Stream3 */
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream4)
 8000602:	4b2b      	ldr	r3, [pc, #172]	; (80006b0 <DMA_DeInit+0x110>)
 8000604:	4298      	cmp	r0, r3
 8000606:	d02f      	beq.n	8000668 <DMA_DeInit+0xc8>
  {
    /* Reset interrupt pending bits for DMA2 Stream4 */
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream5)
 8000608:	4b2a      	ldr	r3, [pc, #168]	; (80006b4 <DMA_DeInit+0x114>)
 800060a:	4298      	cmp	r0, r3
 800060c:	d030      	beq.n	8000670 <DMA_DeInit+0xd0>
  {
    /* Reset interrupt pending bits for DMA2 Stream5 */
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream6)
 800060e:	4b2a      	ldr	r3, [pc, #168]	; (80006b8 <DMA_DeInit+0x118>)
 8000610:	4298      	cmp	r0, r3
 8000612:	d005      	beq.n	8000620 <DMA_DeInit+0x80>
    /* Reset interrupt pending bits for DMA2 Stream6 */
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
  }
  else 
  {
    if (DMAy_Streamx == DMA2_Stream7)
 8000614:	4b29      	ldr	r3, [pc, #164]	; (80006bc <DMA_DeInit+0x11c>)
 8000616:	4298      	cmp	r0, r3
 8000618:	d006      	beq.n	8000628 <DMA_DeInit+0x88>
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
    }
  }
}
 800061a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800061e:	4770      	bx	lr
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream6)
  {
    /* Reset interrupt pending bits for DMA2 Stream6 */
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
 8000620:	4a27      	ldr	r2, [pc, #156]	; (80006c0 <DMA_DeInit+0x120>)
 8000622:	f843 2c94 	str.w	r2, [r3, #-148]
 8000626:	e7f8      	b.n	800061a <DMA_DeInit+0x7a>
  else 
  {
    if (DMAy_Streamx == DMA2_Stream7)
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
 8000628:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 800062c:	f843 2cac 	str.w	r2, [r3, #-172]
 8000630:	e7f3      	b.n	800061a <DMA_DeInit+0x7a>
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream1)
  {
    /* Reset interrupt pending bits for DMA2 Stream1 */
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
 8000632:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8000636:	f843 2c20 	str.w	r2, [r3, #-32]
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
    }
  }
}
 800063a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800063e:	4770      	bx	lr
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream2)
  {
    /* Reset interrupt pending bits for DMA2 Stream2 */
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
 8000640:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 8000644:	f843 2c38 	str.w	r2, [r3, #-56]
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
    }
  }
}
 8000648:	f85d 4b04 	ldr.w	r4, [sp], #4
 800064c:	4770      	bx	lr
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream3)
  {
    /* Reset interrupt pending bits for DMA2 Stream3 */
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
 800064e:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 8000652:	f843 2c50 	str.w	r2, [r3, #-80]
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
    }
  }
}
 8000656:	f85d 4b04 	ldr.w	r4, [sp], #4
 800065a:	4770      	bx	lr

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
 800065c:	4b19      	ldr	r3, [pc, #100]	; (80006c4 <DMA_DeInit+0x124>)
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
    }
  }
}
 800065e:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
 8000662:	223d      	movs	r2, #61	; 0x3d
 8000664:	609a      	str	r2, [r3, #8]
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
    }
  }
}
 8000666:	4770      	bx	lr
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream4)
  {
    /* Reset interrupt pending bits for DMA2 Stream4 */
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
 8000668:	4a17      	ldr	r2, [pc, #92]	; (80006c8 <DMA_DeInit+0x128>)
 800066a:	f843 2c64 	str.w	r2, [r3, #-100]
 800066e:	e7d4      	b.n	800061a <DMA_DeInit+0x7a>
  }
  else if (DMAy_Streamx == DMA2_Stream5)
  {
    /* Reset interrupt pending bits for DMA2 Stream5 */
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
 8000670:	4a16      	ldr	r2, [pc, #88]	; (80006cc <DMA_DeInit+0x12c>)
 8000672:	f843 2c7c 	str.w	r2, [r3, #-124]
 8000676:	e7d0      	b.n	800061a <DMA_DeInit+0x7a>
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream0)
  {
    /* Reset interrupt pending bits for DMA2 Stream0 */
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
 8000678:	223d      	movs	r2, #61	; 0x3d
 800067a:	f843 2c08 	str.w	r2, [r3, #-8]
 800067e:	e7cc      	b.n	800061a <DMA_DeInit+0x7a>
 8000680:	40026010 	.word	0x40026010
 8000684:	40026028 	.word	0x40026028
 8000688:	40026040 	.word	0x40026040
 800068c:	40026058 	.word	0x40026058
 8000690:	40026070 	.word	0x40026070
 8000694:	40026088 	.word	0x40026088
 8000698:	400260a0 	.word	0x400260a0
 800069c:	400260b8 	.word	0x400260b8
 80006a0:	40026410 	.word	0x40026410
 80006a4:	40026428 	.word	0x40026428
 80006a8:	40026440 	.word	0x40026440
 80006ac:	40026458 	.word	0x40026458
 80006b0:	40026470 	.word	0x40026470
 80006b4:	40026488 	.word	0x40026488
 80006b8:	400264a0 	.word	0x400264a0
 80006bc:	400264b8 	.word	0x400264b8
 80006c0:	203d0000 	.word	0x203d0000
 80006c4:	40026000 	.word	0x40026000
 80006c8:	2000003d 	.word	0x2000003d
 80006cc:	20000f40 	.word	0x20000f40

080006d0 <DMA_Init>:
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 80006d0:	68ca      	ldr	r2, [r1, #12]
 80006d2:	680b      	ldr	r3, [r1, #0]
  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));

  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;
 80006d4:	f8d0 c000 	ldr.w	ip, [r0]
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Stream.  
  * @retval None
  */
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
{
 80006d8:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 80006dc:	694f      	ldr	r7, [r1, #20]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 80006de:	698e      	ldr	r6, [r1, #24]
 80006e0:	69cd      	ldr	r5, [r1, #28]
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 80006e2:	6a0c      	ldr	r4, [r1, #32]
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 80006e4:	f8d1 9034 	ldr.w	r9, [r1, #52]	; 0x34
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 80006e8:	f8d1 8038 	ldr.w	r8, [r1, #56]	; 0x38
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 80006ec:	ea42 0a03 	orr.w	sl, r2, r3
 80006f0:	ea4a 0707 	orr.w	r7, sl, r7
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 80006f4:	433e      	orrs	r6, r7
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 80006f6:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 80006f8:	684f      	ldr	r7, [r1, #4]
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 80006fa:	4335      	orrs	r5, r6
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 80006fc:	432c      	orrs	r4, r5
 80006fe:	ea44 0203 	orr.w	r2, r4, r3
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8000702:	6a8b      	ldr	r3, [r1, #40]	; 0x28
  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8000704:	4e0d      	ldr	r6, [pc, #52]	; (800073c <DMA_Init+0x6c>)
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8000706:	6acc      	ldr	r4, [r1, #44]	; 0x2c
  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 8000708:	690d      	ldr	r5, [r1, #16]
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 800070a:	431a      	orrs	r2, r3
 800070c:	ea42 0909 	orr.w	r9, r2, r9
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 8000710:	ea49 0808 	orr.w	r8, r9, r8
  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8000714:	ea0c 0606 	and.w	r6, ip, r6
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8000718:	ea48 0606 	orr.w	r6, r8, r6
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 800071c:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 800071e:	6889      	ldr	r1, [r1, #8]
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;

  /* Write to DMAy Streamx CR register */
  DMAy_Streamx->CR = tmpreg;
 8000720:	6006      	str	r6, [r0, #0]

  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;
 8000722:	6942      	ldr	r2, [r0, #20]
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8000724:	4323      	orrs	r3, r4
  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;

  /* Clear DMDIS and FTH bits */
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8000726:	f022 0207 	bic.w	r2, r2, #7

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 800072a:	4313      	orrs	r3, r2

  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;
 800072c:	6143      	str	r3, [r0, #20]

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 800072e:	6045      	str	r5, [r0, #4]

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8000730:	6087      	str	r7, [r0, #8]

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 8000732:	60c1      	str	r1, [r0, #12]
}
 8000734:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8000738:	4770      	bx	lr
 800073a:	bf00      	nop
 800073c:	f01c803f 	.word	0xf01c803f

08000740 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
  /*-------------- Reset DMA init structure parameters values ----------------*/
  /* Initialize the DMA_Channel member */
  DMA_InitStruct->DMA_Channel = 0;
 8000740:	2300      	movs	r3, #0
 8000742:	6003      	str	r3, [r0, #0]

  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8000744:	6043      	str	r3, [r0, #4]

  /* Initialize the DMA_Memory0BaseAddr member */
  DMA_InitStruct->DMA_Memory0BaseAddr = 0;
 8000746:	6083      	str	r3, [r0, #8]

  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
 8000748:	60c3      	str	r3, [r0, #12]

  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 800074a:	6103      	str	r3, [r0, #16]

  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800074c:	6143      	str	r3, [r0, #20]

  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 800074e:	6183      	str	r3, [r0, #24]

  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8000750:	61c3      	str	r3, [r0, #28]

  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8000752:	6203      	str	r3, [r0, #32]

  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8000754:	6243      	str	r3, [r0, #36]	; 0x24

  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 8000756:	6283      	str	r3, [r0, #40]	; 0x28

  /* Initialize the DMA_FIFOMode member */
  DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
 8000758:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Initialize the DMA_FIFOThreshold member */
  DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 800075a:	6303      	str	r3, [r0, #48]	; 0x30

  /* Initialize the DMA_MemoryBurst member */
  DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
 800075c:	6343      	str	r3, [r0, #52]	; 0x34

  /* Initialize the DMA_PeripheralBurst member */
  DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 800075e:	6383      	str	r3, [r0, #56]	; 0x38
 8000760:	4770      	bx	lr
 8000762:	bf00      	nop

08000764 <DMA_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 8000764:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000766:	b919      	cbnz	r1, 8000770 <DMA_Cmd+0xc>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
  }
  else
  {
    /* Disable the selected DMAy Streamx by clearing EN bit */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 8000768:	f023 0301 	bic.w	r3, r3, #1
 800076c:	6003      	str	r3, [r0, #0]
 800076e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 8000770:	f043 0301 	orr.w	r3, r3, #1
 8000774:	6003      	str	r3, [r0, #0]
 8000776:	4770      	bx	lr

08000778 <DMA_PeriphIncOffsetSizeConfig>:

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
  {
    /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 8000778:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
 800077a:	b919      	cbnz	r1, 8000784 <DMA_PeriphIncOffsetSizeConfig+0xc>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
  }
  else
  {
    /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
 800077c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8000780:	6003      	str	r3, [r0, #0]
 8000782:	4770      	bx	lr

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
  {
    /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 8000784:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000788:	6003      	str	r3, [r0, #0]
 800078a:	4770      	bx	lr

0800078c <DMA_FlowControllerConfig>:

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
  {
    /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 800078c:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
 800078e:	b919      	cbnz	r1, 8000798 <DMA_FlowControllerConfig+0xc>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
  }
  else
  {
    /* Clear the PFCTRL bit: Memory is the flow controller */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
 8000790:	f023 0320 	bic.w	r3, r3, #32
 8000794:	6003      	str	r3, [r0, #0]
 8000796:	4770      	bx	lr

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
  {
    /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 8000798:	f043 0320 	orr.w	r3, r3, #32
 800079c:	6003      	str	r3, [r0, #0]
 800079e:	4770      	bx	lr

080007a0 <DMA_SetCurrDataCounter>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Write the number of data units to be transferred */
  DMAy_Streamx->NDTR = (uint16_t)Counter;
 80007a0:	6041      	str	r1, [r0, #4]
 80007a2:	4770      	bx	lr

080007a4 <DMA_GetCurrDataCounter>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Return the number of remaining data units for DMAy Streamx */
  return ((uint16_t)(DMAy_Streamx->NDTR));
 80007a4:	6840      	ldr	r0, [r0, #4]
}
 80007a6:	b280      	uxth	r0, r0
 80007a8:	4770      	bx	lr
 80007aa:	bf00      	nop

080007ac <DMA_DoubleBufferModeConfig>:
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
  {
    /* Set Memory 1 as current memory address */
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 80007ac:	6803      	ldr	r3, [r0, #0]
{  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
 80007ae:	b922      	cbnz	r2, 80007ba <DMA_DoubleBufferModeConfig+0xe>
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
  }
  else
  {
    /* Set Memory 0 as current memory address */
    DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
 80007b0:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80007b4:	6003      	str	r3, [r0, #0]
  }

  /* Write to DMAy Streamx M1AR */
  DMAy_Streamx->M1AR = Memory1BaseAddr;
 80007b6:	6101      	str	r1, [r0, #16]
 80007b8:	4770      	bx	lr
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
  {
    /* Set Memory 1 as current memory address */
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 80007ba:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80007be:	6003      	str	r3, [r0, #0]
    /* Set Memory 0 as current memory address */
    DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
  }

  /* Write to DMAy Streamx M1AR */
  DMAy_Streamx->M1AR = Memory1BaseAddr;
 80007c0:	6101      	str	r1, [r0, #16]
 80007c2:	4770      	bx	lr

080007c4 <DMA_DoubleBufferModeCmd>:

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
  {
    /* Enable the Double buffer mode */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 80007c4:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
 80007c6:	b919      	cbnz	r1, 80007d0 <DMA_DoubleBufferModeCmd+0xc>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
  }
  else
  {
    /* Disable the Double buffer mode */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
 80007c8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80007cc:	6003      	str	r3, [r0, #0]
 80007ce:	4770      	bx	lr

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
  {
    /* Enable the Double buffer mode */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 80007d0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80007d4:	6003      	str	r3, [r0, #0]
 80007d6:	4770      	bx	lr

080007d8 <DMA_MemoryTargetConfig>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
    
  /* Check the Memory target to be configured */
  if (DMA_MemoryTarget != DMA_Memory_0)
 80007d8:	b90a      	cbnz	r2, 80007de <DMA_MemoryTargetConfig+0x6>
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
  }  
  else
  {
    /* Write to DMAy Streamx M0AR */
    DMAy_Streamx->M0AR = MemoryBaseAddr;  
 80007da:	60c1      	str	r1, [r0, #12]
 80007dc:	4770      	bx	lr
    
  /* Check the Memory target to be configured */
  if (DMA_MemoryTarget != DMA_Memory_0)
  {
    /* Write to DMAy Streamx M1AR */
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
 80007de:	6101      	str	r1, [r0, #16]
 80007e0:	4770      	bx	lr
 80007e2:	bf00      	nop

080007e4 <DMA_GetCurrentMemoryTarget>:
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Get the current memory target */
  if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
 80007e4:	6800      	ldr	r0, [r0, #0]
  {
    /* Current memory buffer used is Memory 0 */
    tmp = 0;    
  }
  return tmp;
}
 80007e6:	f3c0 40c0 	ubfx	r0, r0, #19, #1
 80007ea:	4770      	bx	lr

080007ec <DMA_GetCmdStatus>:
  FunctionalState state = DISABLE;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
 80007ec:	6800      	ldr	r0, [r0, #0]
    /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
        all transfers are complete) */
    state = DISABLE;
  }
  return state;
}
 80007ee:	f000 0001 	and.w	r0, r0, #1
 80007f2:	4770      	bx	lr

080007f4 <DMA_GetFIFOStatus>:
 
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  
  /* Get the FIFO level bits */
  tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
 80007f4:	6940      	ldr	r0, [r0, #20]
  
  return tmpreg;
}
 80007f6:	f000 0038 	and.w	r0, r0, #56	; 0x38
 80007fa:	4770      	bx	lr

080007fc <DMA_GetFlagStatus>:

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 80007fc:	4b0b      	ldr	r3, [pc, #44]	; (800082c <DMA_GetFlagStatus+0x30>)
 80007fe:	4a0c      	ldr	r2, [pc, #48]	; (8000830 <DMA_GetFlagStatus+0x34>)
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_FLAG (SET or RESET).
  */
FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 8000800:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8000802:	4c0c      	ldr	r4, [pc, #48]	; (8000834 <DMA_GetFlagStatus+0x38>)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8000804:	42a0      	cmp	r0, r4
 8000806:	bf8c      	ite	hi
 8000808:	4610      	movhi	r0, r2
 800080a:	4618      	movls	r0, r3
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if the flag is in HISR or LISR */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 800080c:	008b      	lsls	r3, r1, #2
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR;
 800080e:	bf4c      	ite	mi
 8000810:	6843      	ldrmi	r3, [r0, #4]
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR;
 8000812:	6803      	ldrpl	r3, [r0, #0]
    bitstatus = RESET;
  }

  /* Return the DMA_FLAG status */
  return  bitstatus;
}
 8000814:	f85d 4b04 	ldr.w	r4, [sp], #4
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR;
  }   
 
  /* Mask the reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 8000818:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 800081c:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082

  /* Check the status of the specified DMA flag */
  if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
 8000820:	4219      	tst	r1, r3
    bitstatus = RESET;
  }

  /* Return the DMA_FLAG status */
  return  bitstatus;
}
 8000822:	bf0c      	ite	eq
 8000824:	2000      	moveq	r0, #0
 8000826:	2001      	movne	r0, #1
 8000828:	4770      	bx	lr
 800082a:	bf00      	nop
 800082c:	40026000 	.word	0x40026000
 8000830:	40026400 	.word	0x40026400
 8000834:	4002640f 	.word	0x4002640f

08000838 <DMA_ClearFlag>:
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.   
  * @retval None
  */
void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 8000838:	b410      	push	{r4}

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 800083a:	4a09      	ldr	r2, [pc, #36]	; (8000860 <DMA_ClearFlag+0x28>)
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 800083c:	4c09      	ldr	r4, [pc, #36]	; (8000864 <DMA_ClearFlag+0x2c>)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 800083e:	4b0a      	ldr	r3, [pc, #40]	; (8000868 <DMA_ClearFlag+0x30>)
 8000840:	42a0      	cmp	r0, r4
 8000842:	bf8c      	ite	hi
 8000844:	4610      	movhi	r0, r2
 8000846:	4618      	movls	r0, r3
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 8000848:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
  {
    /* Set DMAy HIFCR register clear flag bits */
    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 800084c:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8000850:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8000854:	bf14      	ite	ne
 8000856:	60c1      	strne	r1, [r0, #12]
  }
  else 
  {
    /* Set DMAy LIFCR register clear flag bits */
    DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8000858:	6081      	streq	r1, [r0, #8]
  }    
}
 800085a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800085e:	4770      	bx	lr
 8000860:	40026400 	.word	0x40026400
 8000864:	4002640f 	.word	0x4002640f
 8000868:	40026000 	.word	0x40026000

0800086c <DMA_ITConfig>:
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
 800086c:	060b      	lsls	r3, r1, #24
 800086e:	d50c      	bpl.n	800088a <DMA_ITConfig+0x1e>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8000870:	6943      	ldr	r3, [r0, #20]
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
  {
    if (NewState != DISABLE)
 8000872:	b1aa      	cbz	r2, 80008a0 <DMA_ITConfig+0x34>
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8000874:	f043 0380 	orr.w	r3, r3, #128	; 0x80
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8000878:	2980      	cmp	r1, #128	; 0x80
  if ((DMA_IT & DMA_IT_FE) != 0)
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 800087a:	6143      	str	r3, [r0, #20]
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 800087c:	d00f      	beq.n	800089e <DMA_ITConfig+0x32>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA transfer interrupts */
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
 800087e:	6803      	ldr	r3, [r0, #0]
 8000880:	f001 011e 	and.w	r1, r1, #30
 8000884:	4319      	orrs	r1, r3
 8000886:	6001      	str	r1, [r0, #0]
 8000888:	4770      	bx	lr
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 800088a:	2980      	cmp	r1, #128	; 0x80
 800088c:	d007      	beq.n	800089e <DMA_ITConfig+0x32>
  {
    if (NewState != DISABLE)
 800088e:	2a00      	cmp	r2, #0
 8000890:	d1f5      	bne.n	800087e <DMA_ITConfig+0x12>
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
    }
    else
    {
      /* Disable the selected DMA transfer interrupts */
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
 8000892:	6803      	ldr	r3, [r0, #0]
 8000894:	f001 011e 	and.w	r1, r1, #30
 8000898:	ea23 0101 	bic.w	r1, r3, r1
 800089c:	6001      	str	r1, [r0, #0]
 800089e:	4770      	bx	lr
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
    }    
    else 
    {
      /* Disable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 80008a0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 80008a4:	2980      	cmp	r1, #128	; 0x80
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
    }    
    else 
    {
      /* Disable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 80008a6:	6143      	str	r3, [r0, #20]
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 80008a8:	d1f3      	bne.n	8000892 <DMA_ITConfig+0x26>
 80008aa:	4770      	bx	lr

080008ac <DMA_GetITStatus>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_IT (SET or RESET).
  */
ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 80008ac:	b470      	push	{r4, r5, r6}
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 80008ae:	4a11      	ldr	r2, [pc, #68]	; (80008f4 <DMA_GetITStatus+0x48>)
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_IT(DMA_IT));
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 80008b0:	4d11      	ldr	r5, [pc, #68]	; (80008f8 <DMA_GetITStatus+0x4c>)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 80008b2:	4c12      	ldr	r4, [pc, #72]	; (80008fc <DMA_GetITStatus+0x50>)
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 80008b4:	f021 23f0 	bic.w	r3, r1, #4026593280	; 0xf000f000
 80008b8:	f023 16c3 	bic.w	r6, r3, #12779715	; 0xc300c3
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 80008bc:	42a8      	cmp	r0, r5
 80008be:	bf88      	it	hi
 80008c0:	4622      	movhi	r2, r4
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 80008c2:	b196      	cbz	r6, 80008ea <DMA_GetITStatus+0x3e>
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 80008c4:	6804      	ldr	r4, [r0, #0]

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
 80008c6:	f004 041e 	and.w	r4, r4, #30
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 80008ca:	ea04 24d1 	and.w	r4, r4, r1, lsr #11
    /* Check the enable bit in FCR register */
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
  }
 
  /* Check if the interrupt pending flag is in LISR or HISR */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 80008ce:	0089      	lsls	r1, r1, #2
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR ;
 80008d0:	bf4c      	ite	mi
 80008d2:	6852      	ldrmi	r2, [r2, #4]
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR ;
 80008d4:	6812      	ldrpl	r2, [r2, #0]
  } 

  /* mask all reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 80008d6:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082

  /* Check the status of the specified DMA interrupt */
  if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 80008da:	ea13 0002 	ands.w	r0, r3, r2
 80008de:	d002      	beq.n	80008e6 <DMA_GetITStatus+0x3a>
  {
    /* DMA_IT is set */
    bitstatus = SET;
 80008e0:	1c20      	adds	r0, r4, #0
 80008e2:	bf18      	it	ne
 80008e4:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the DMA_IT status */
  return  bitstatus;
}
 80008e6:	bc70      	pop	{r4, r5, r6}
 80008e8:	4770      	bx	lr
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
  }
  else 
  {
    /* Check the enable bit in FCR register */
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
 80008ea:	6944      	ldr	r4, [r0, #20]
 80008ec:	f004 0480 	and.w	r4, r4, #128	; 0x80
 80008f0:	e7ed      	b.n	80008ce <DMA_GetITStatus+0x22>
 80008f2:	bf00      	nop
 80008f4:	40026000 	.word	0x40026000
 80008f8:	4002640f 	.word	0x4002640f
 80008fc:	40026400 	.word	0x40026400

08000900 <DMA_ClearITPendingBit>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 8000900:	b410      	push	{r4}

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8000902:	4a09      	ldr	r2, [pc, #36]	; (8000928 <DMA_ClearITPendingBit+0x28>)
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_IT(DMA_IT));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8000904:	4c09      	ldr	r4, [pc, #36]	; (800092c <DMA_ClearITPendingBit+0x2c>)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8000906:	4b0a      	ldr	r3, [pc, #40]	; (8000930 <DMA_ClearITPendingBit+0x30>)
 8000908:	42a0      	cmp	r0, r4
 800090a:	bf8c      	ite	hi
 800090c:	4610      	movhi	r0, r2
 800090e:	4618      	movls	r0, r3
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8000910:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
  {
    /* Set DMAy HIFCR register clear interrupt bits */
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8000914:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8000918:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 800091c:	bf14      	ite	ne
 800091e:	60c1      	strne	r1, [r0, #12]
  }
  else 
  {
    /* Set DMAy LIFCR register clear interrupt bits */
    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8000920:	6081      	streq	r1, [r0, #8]
  }   
}
 8000922:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000926:	4770      	bx	lr
 8000928:	40026400 	.word	0x40026400
 800092c:	4002640f 	.word	0x4002640f
 8000930:	40026000 	.word	0x40026000

08000934 <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8000934:	4b04      	ldr	r3, [pc, #16]	; (8000948 <EXTI_DeInit+0x14>)
  EXTI->EMR = 0x00000000;
  EXTI->RTSR = 0x00000000;
  EXTI->FTSR = 0x00000000;
  EXTI->PR = 0x007FFFFF;
 8000936:	4905      	ldr	r1, [pc, #20]	; (800094c <EXTI_DeInit+0x18>)
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8000938:	2200      	movs	r2, #0
 800093a:	601a      	str	r2, [r3, #0]
  EXTI->EMR = 0x00000000;
 800093c:	605a      	str	r2, [r3, #4]
  EXTI->RTSR = 0x00000000;
 800093e:	609a      	str	r2, [r3, #8]
  EXTI->FTSR = 0x00000000;
 8000940:	60da      	str	r2, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 8000942:	6159      	str	r1, [r3, #20]
 8000944:	4770      	bx	lr
 8000946:	bf00      	nop
 8000948:	40013c00 	.word	0x40013c00
 800094c:	007fffff 	.word	0x007fffff

08000950 <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8000950:	7983      	ldrb	r3, [r0, #6]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8000952:	b470      	push	{r4, r5, r6}
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8000954:	b32b      	cbz	r3, 80009a2 <EXTI_Init+0x52>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8000956:	4b1d      	ldr	r3, [pc, #116]	; (80009cc <EXTI_Init+0x7c>)
 8000958:	6801      	ldr	r1, [r0, #0]
 800095a:	681e      	ldr	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 800095c:	7902      	ldrb	r2, [r0, #4]
    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 800095e:	7945      	ldrb	r5, [r0, #5]
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8000960:	43cc      	mvns	r4, r1
 8000962:	4026      	ands	r6, r4
 8000964:	601e      	str	r6, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8000966:	685e      	ldr	r6, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8000968:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 800096c:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8000970:	4034      	ands	r4, r6
 8000972:	605c      	str	r4, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8000974:	6814      	ldr	r4, [r2, #0]
 8000976:	4321      	orrs	r1, r4
 8000978:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 800097a:	6802      	ldr	r2, [r0, #0]
 800097c:	6898      	ldr	r0, [r3, #8]
 800097e:	43d1      	mvns	r1, r2
 8000980:	4008      	ands	r0, r1
 8000982:	6098      	str	r0, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8000984:	68d8      	ldr	r0, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8000986:	2d10      	cmp	r5, #16

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8000988:	ea01 0100 	and.w	r1, r1, r0
 800098c:	60d9      	str	r1, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 800098e:	d014      	beq.n	80009ba <EXTI_Init+0x6a>
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8000990:	f105 4380 	add.w	r3, r5, #1073741824	; 0x40000000
 8000994:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 8000998:	bc70      	pop	{r4, r5, r6}
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800099a:	6819      	ldr	r1, [r3, #0]
 800099c:	430a      	orrs	r2, r1
 800099e:	601a      	str	r2, [r3, #0]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 80009a0:	4770      	bx	lr
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80009a2:	7903      	ldrb	r3, [r0, #4]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80009a4:	6801      	ldr	r1, [r0, #0]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80009a6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80009aa:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 80009ae:	bc70      	pop	{r4, r5, r6}
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80009b0:	681a      	ldr	r2, [r3, #0]
 80009b2:	ea22 0201 	bic.w	r2, r2, r1
 80009b6:	601a      	str	r2, [r3, #0]
  }
}
 80009b8:	4770      	bx	lr
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 80009ba:	6899      	ldr	r1, [r3, #8]
 80009bc:	4311      	orrs	r1, r2
 80009be:	6099      	str	r1, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 80009c0:	68d9      	ldr	r1, [r3, #12]
 80009c2:	430a      	orrs	r2, r1
 80009c4:	60da      	str	r2, [r3, #12]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 80009c6:	bc70      	pop	{r4, r5, r6}
 80009c8:	4770      	bx	lr
 80009ca:	bf00      	nop
 80009cc:	40013c00 	.word	0x40013c00

080009d0 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 80009d0:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 80009d2:	220c      	movs	r2, #12
 80009d4:	7142      	strb	r2, [r0, #5]
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 80009d6:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 80009d8:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 80009da:	7183      	strb	r3, [r0, #6]
 80009dc:	4770      	bx	lr
 80009de:	bf00      	nop

080009e0 <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 80009e0:	4b02      	ldr	r3, [pc, #8]	; (80009ec <EXTI_GenerateSWInterrupt+0xc>)
 80009e2:	691a      	ldr	r2, [r3, #16]
 80009e4:	4310      	orrs	r0, r2
 80009e6:	6118      	str	r0, [r3, #16]
 80009e8:	4770      	bx	lr
 80009ea:	bf00      	nop
 80009ec:	40013c00 	.word	0x40013c00

080009f0 <EXTI_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 80009f0:	4b03      	ldr	r3, [pc, #12]	; (8000a00 <EXTI_GetFlagStatus+0x10>)
 80009f2:	695b      	ldr	r3, [r3, #20]
 80009f4:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80009f6:	bf0c      	ite	eq
 80009f8:	2000      	moveq	r0, #0
 80009fa:	2001      	movne	r0, #1
 80009fc:	4770      	bx	lr
 80009fe:	bf00      	nop
 8000a00:	40013c00 	.word	0x40013c00

08000a04 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8000a04:	4b01      	ldr	r3, [pc, #4]	; (8000a0c <EXTI_ClearFlag+0x8>)
 8000a06:	6158      	str	r0, [r3, #20]
 8000a08:	4770      	bx	lr
 8000a0a:	bf00      	nop
 8000a0c:	40013c00 	.word	0x40013c00

08000a10 <EXTI_GetITStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 8000a10:	4b03      	ldr	r3, [pc, #12]	; (8000a20 <EXTI_GetITStatus+0x10>)
 8000a12:	695b      	ldr	r3, [r3, #20]
 8000a14:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  return bitstatus;
  
}
 8000a16:	bf0c      	ite	eq
 8000a18:	2000      	moveq	r0, #0
 8000a1a:	2001      	movne	r0, #1
 8000a1c:	4770      	bx	lr
 8000a1e:	bf00      	nop
 8000a20:	40013c00 	.word	0x40013c00

08000a24 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8000a24:	4b01      	ldr	r3, [pc, #4]	; (8000a2c <EXTI_ClearITPendingBit+0x8>)
 8000a26:	6158      	str	r0, [r3, #20]
 8000a28:	4770      	bx	lr
 8000a2a:	bf00      	nop
 8000a2c:	40013c00 	.word	0x40013c00

08000a30 <FLASH_SetLatency>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
  *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
 8000a30:	4b01      	ldr	r3, [pc, #4]	; (8000a38 <FLASH_SetLatency+0x8>)
 8000a32:	b2c0      	uxtb	r0, r0
 8000a34:	7018      	strb	r0, [r3, #0]
 8000a36:	4770      	bx	lr
 8000a38:	40023c00 	.word	0x40023c00

08000a3c <FLASH_PrefetchBufferCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Enable or disable the Prefetch Buffer */
  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 8000a3c:	4b05      	ldr	r3, [pc, #20]	; (8000a54 <FLASH_PrefetchBufferCmd+0x18>)
 8000a3e:	681a      	ldr	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Enable or disable the Prefetch Buffer */
  if(NewState != DISABLE)
 8000a40:	b918      	cbnz	r0, 8000a4a <FLASH_PrefetchBufferCmd+0xe>
  {
    FLASH->ACR |= FLASH_ACR_PRFTEN;
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_PRFTEN);
 8000a42:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8000a46:	601a      	str	r2, [r3, #0]
 8000a48:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Enable or disable the Prefetch Buffer */
  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 8000a4a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000a4e:	601a      	str	r2, [r3, #0]
 8000a50:	4770      	bx	lr
 8000a52:	bf00      	nop
 8000a54:	40023c00 	.word	0x40023c00

08000a58 <FLASH_InstructionCacheCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_ICEN;
 8000a58:	4b05      	ldr	r3, [pc, #20]	; (8000a70 <FLASH_InstructionCacheCmd+0x18>)
 8000a5a:	681a      	ldr	r2, [r3, #0]
void FLASH_InstructionCacheCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 8000a5c:	b918      	cbnz	r0, 8000a66 <FLASH_InstructionCacheCmd+0xe>
  {
    FLASH->ACR |= FLASH_ACR_ICEN;
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_ICEN);
 8000a5e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8000a62:	601a      	str	r2, [r3, #0]
 8000a64:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_ICEN;
 8000a66:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000a6a:	601a      	str	r2, [r3, #0]
 8000a6c:	4770      	bx	lr
 8000a6e:	bf00      	nop
 8000a70:	40023c00 	.word	0x40023c00

08000a74 <FLASH_DataCacheCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_DCEN;
 8000a74:	4b05      	ldr	r3, [pc, #20]	; (8000a8c <FLASH_DataCacheCmd+0x18>)
 8000a76:	681a      	ldr	r2, [r3, #0]
void FLASH_DataCacheCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 8000a78:	b918      	cbnz	r0, 8000a82 <FLASH_DataCacheCmd+0xe>
  {
    FLASH->ACR |= FLASH_ACR_DCEN;
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_DCEN);
 8000a7a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000a7e:	601a      	str	r2, [r3, #0]
 8000a80:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_DCEN;
 8000a82:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000a86:	601a      	str	r2, [r3, #0]
 8000a88:	4770      	bx	lr
 8000a8a:	bf00      	nop
 8000a8c:	40023c00 	.word	0x40023c00

08000a90 <FLASH_InstructionCacheReset>:
  * @param  None
  * @retval None
  */
void FLASH_InstructionCacheReset(void)
{
  FLASH->ACR |= FLASH_ACR_ICRST;
 8000a90:	4b02      	ldr	r3, [pc, #8]	; (8000a9c <FLASH_InstructionCacheReset+0xc>)
 8000a92:	681a      	ldr	r2, [r3, #0]
 8000a94:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8000a98:	601a      	str	r2, [r3, #0]
 8000a9a:	4770      	bx	lr
 8000a9c:	40023c00 	.word	0x40023c00

08000aa0 <FLASH_DataCacheReset>:
  * @param  None
  * @retval None
  */
void FLASH_DataCacheReset(void)
{
  FLASH->ACR |= FLASH_ACR_DCRST;
 8000aa0:	4b02      	ldr	r3, [pc, #8]	; (8000aac <FLASH_DataCacheReset+0xc>)
 8000aa2:	681a      	ldr	r2, [r3, #0]
 8000aa4:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000aa8:	601a      	str	r2, [r3, #0]
 8000aaa:	4770      	bx	lr
 8000aac:	40023c00 	.word	0x40023c00

08000ab0 <FLASH_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 8000ab0:	4b04      	ldr	r3, [pc, #16]	; (8000ac4 <FLASH_Unlock+0x14>)
 8000ab2:	691a      	ldr	r2, [r3, #16]
 8000ab4:	2a00      	cmp	r2, #0
 8000ab6:	da03      	bge.n	8000ac0 <FLASH_Unlock+0x10>
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 8000ab8:	4903      	ldr	r1, [pc, #12]	; (8000ac8 <FLASH_Unlock+0x18>)
    FLASH->KEYR = FLASH_KEY2;
 8000aba:	4a04      	ldr	r2, [pc, #16]	; (8000acc <FLASH_Unlock+0x1c>)
void FLASH_Unlock(void)
{
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 8000abc:	6059      	str	r1, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 8000abe:	605a      	str	r2, [r3, #4]
 8000ac0:	4770      	bx	lr
 8000ac2:	bf00      	nop
 8000ac4:	40023c00 	.word	0x40023c00
 8000ac8:	45670123 	.word	0x45670123
 8000acc:	cdef89ab 	.word	0xcdef89ab

08000ad0 <FLASH_Lock>:
  * @retval None
  */
void FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 8000ad0:	4b02      	ldr	r3, [pc, #8]	; (8000adc <FLASH_Lock+0xc>)
 8000ad2:	691a      	ldr	r2, [r3, #16]
 8000ad4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8000ad8:	611a      	str	r2, [r3, #16]
 8000ada:	4770      	bx	lr
 8000adc:	40023c00 	.word	0x40023c00

08000ae0 <FLASH_OB_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_OB_Unlock(void)
{
  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
 8000ae0:	4b04      	ldr	r3, [pc, #16]	; (8000af4 <FLASH_OB_Unlock+0x14>)
 8000ae2:	695a      	ldr	r2, [r3, #20]
 8000ae4:	07d2      	lsls	r2, r2, #31
 8000ae6:	d503      	bpl.n	8000af0 <FLASH_OB_Unlock+0x10>
  {
    /* Authorizes the Option Byte register programming */
    FLASH->OPTKEYR = FLASH_OPT_KEY1;
 8000ae8:	4903      	ldr	r1, [pc, #12]	; (8000af8 <FLASH_OB_Unlock+0x18>)
    FLASH->OPTKEYR = FLASH_OPT_KEY2;
 8000aea:	4a04      	ldr	r2, [pc, #16]	; (8000afc <FLASH_OB_Unlock+0x1c>)
void FLASH_OB_Unlock(void)
{
  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
  {
    /* Authorizes the Option Byte register programming */
    FLASH->OPTKEYR = FLASH_OPT_KEY1;
 8000aec:	6099      	str	r1, [r3, #8]
    FLASH->OPTKEYR = FLASH_OPT_KEY2;
 8000aee:	609a      	str	r2, [r3, #8]
 8000af0:	4770      	bx	lr
 8000af2:	bf00      	nop
 8000af4:	40023c00 	.word	0x40023c00
 8000af8:	08192a3b 	.word	0x08192a3b
 8000afc:	4c5d6e7f 	.word	0x4c5d6e7f

08000b00 <FLASH_OB_Lock>:
  * @retval None
  */
void FLASH_OB_Lock(void)
{
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
 8000b00:	4b02      	ldr	r3, [pc, #8]	; (8000b0c <FLASH_OB_Lock+0xc>)
 8000b02:	695a      	ldr	r2, [r3, #20]
 8000b04:	f042 0201 	orr.w	r2, r2, #1
 8000b08:	615a      	str	r2, [r3, #20]
 8000b0a:	4770      	bx	lr
 8000b0c:	40023c00 	.word	0x40023c00

08000b10 <FLASH_OB_PCROPSelectionConfig>:
      
  /* Check the parameters */
  assert_param(IS_OB_PCROP_SELECT(OB_PcROP));
  
  /* Mask SPRMOD bit */
  optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
 8000b10:	4b03      	ldr	r3, [pc, #12]	; (8000b20 <FLASH_OB_PCROPSelectionConfig+0x10>)
 8000b12:	781a      	ldrb	r2, [r3, #0]
 8000b14:	f002 027f 	and.w	r2, r2, #127	; 0x7f
  /* Update Option Byte */
  *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PcROP | optiontmp); 
 8000b18:	4310      	orrs	r0, r2
 8000b1a:	7018      	strb	r0, [r3, #0]
 8000b1c:	4770      	bx	lr
 8000b1e:	bf00      	nop
 8000b20:	40023c17 	.word	0x40023c17

08000b24 <FLASH_OB_BootConfig>:
{
  /* Check the parameters */
  assert_param(IS_OB_BOOT(OB_BOOT));

  /* Set Dual Bank Boot */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
 8000b24:	4b04      	ldr	r3, [pc, #16]	; (8000b38 <FLASH_OB_BootConfig+0x14>)
 8000b26:	781a      	ldrb	r2, [r3, #0]
 8000b28:	f002 02ef 	and.w	r2, r2, #239	; 0xef
 8000b2c:	701a      	strb	r2, [r3, #0]
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOOT;
 8000b2e:	781a      	ldrb	r2, [r3, #0]
 8000b30:	4310      	orrs	r0, r2
 8000b32:	7018      	strb	r0, [r3, #0]
 8000b34:	4770      	bx	lr
 8000b36:	bf00      	nop
 8000b38:	40023c14 	.word	0x40023c14

08000b3c <FLASH_OB_BORConfig>:
{
  /* Check the parameters */
  assert_param(IS_OB_BOR(OB_BOR));

  /* Set the BOR Level */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
 8000b3c:	4b04      	ldr	r3, [pc, #16]	; (8000b50 <FLASH_OB_BORConfig+0x14>)
 8000b3e:	781a      	ldrb	r2, [r3, #0]
 8000b40:	f002 02f3 	and.w	r2, r2, #243	; 0xf3
 8000b44:	701a      	strb	r2, [r3, #0]
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
 8000b46:	781a      	ldrb	r2, [r3, #0]
 8000b48:	4310      	orrs	r0, r2
 8000b4a:	7018      	strb	r0, [r3, #0]
 8000b4c:	4770      	bx	lr
 8000b4e:	bf00      	nop
 8000b50:	40023c14 	.word	0x40023c14

08000b54 <FLASH_OB_GetUser>:
  *         and RST_STDBY(Bit2).
  */
uint8_t FLASH_OB_GetUser(void)
{
  /* Return the User Option Byte */
  return (uint8_t)(FLASH->OPTCR >> 5);
 8000b54:	4b02      	ldr	r3, [pc, #8]	; (8000b60 <FLASH_OB_GetUser+0xc>)
 8000b56:	6958      	ldr	r0, [r3, #20]
}
 8000b58:	f3c0 1047 	ubfx	r0, r0, #5, #8
 8000b5c:	4770      	bx	lr
 8000b5e:	bf00      	nop
 8000b60:	40023c00 	.word	0x40023c00

08000b64 <FLASH_OB_GetWRP>:
  * @retval The FLASH Write Protection  Option Bytes value
  */
uint16_t FLASH_OB_GetWRP(void)
{
  /* Return the FLASH write protection Register value */
  return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
 8000b64:	4b01      	ldr	r3, [pc, #4]	; (8000b6c <FLASH_OB_GetWRP+0x8>)
 8000b66:	8818      	ldrh	r0, [r3, #0]
}
 8000b68:	b280      	uxth	r0, r0
 8000b6a:	4770      	bx	lr
 8000b6c:	40023c16 	.word	0x40023c16

08000b70 <FLASH_OB_GetWRP1>:
  * @retval The FLASH Write Protection  Option Bytes value
  */
uint16_t FLASH_OB_GetWRP1(void)
{
  /* Return the FLASH write protection Register value */
  return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
 8000b70:	4b01      	ldr	r3, [pc, #4]	; (8000b78 <FLASH_OB_GetWRP1+0x8>)
 8000b72:	8818      	ldrh	r0, [r3, #0]
}
 8000b74:	b280      	uxth	r0, r0
 8000b76:	4770      	bx	lr
 8000b78:	40023c1a 	.word	0x40023c1a

08000b7c <FLASH_OB_GetPCROP>:
  * @retval The FLASH PC Read/Write Protection Option Bytes value
  */
uint16_t FLASH_OB_GetPCROP(void)
{
  /* Return the FLASH PC Read/write protection Register value */
  return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
 8000b7c:	4b01      	ldr	r3, [pc, #4]	; (8000b84 <FLASH_OB_GetPCROP+0x8>)
 8000b7e:	8818      	ldrh	r0, [r3, #0]
}
 8000b80:	b280      	uxth	r0, r0
 8000b82:	4770      	bx	lr
 8000b84:	40023c16 	.word	0x40023c16

08000b88 <FLASH_OB_GetPCROP1>:
  * @retval The FLASH PC Read/Write Protection Option Bytes value
  */
uint16_t FLASH_OB_GetPCROP1(void)
{
  /* Return the FLASH write protection Register value */
  return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
 8000b88:	4b01      	ldr	r3, [pc, #4]	; (8000b90 <FLASH_OB_GetPCROP1+0x8>)
 8000b8a:	8818      	ldrh	r0, [r3, #0]
}
 8000b8c:	b280      	uxth	r0, r0
 8000b8e:	4770      	bx	lr
 8000b90:	40023c1a 	.word	0x40023c1a

08000b94 <FLASH_OB_GetRDP>:
  */
FlagStatus FLASH_OB_GetRDP(void)
{
  FlagStatus readstatus = RESET;

  if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
 8000b94:	4b02      	ldr	r3, [pc, #8]	; (8000ba0 <FLASH_OB_GetRDP+0xc>)
 8000b96:	7818      	ldrb	r0, [r3, #0]
  else
  {
    readstatus = RESET;
  }
  return readstatus;
}
 8000b98:	38aa      	subs	r0, #170	; 0xaa
 8000b9a:	bf18      	it	ne
 8000b9c:	2001      	movne	r0, #1
 8000b9e:	4770      	bx	lr
 8000ba0:	40023c15 	.word	0x40023c15

08000ba4 <FLASH_OB_GetBOR>:
  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
  */
uint8_t FLASH_OB_GetBOR(void)
{
  /* Return the FLASH BOR level */
  return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
 8000ba4:	4b02      	ldr	r3, [pc, #8]	; (8000bb0 <FLASH_OB_GetBOR+0xc>)
 8000ba6:	7818      	ldrb	r0, [r3, #0]
}
 8000ba8:	f000 000c 	and.w	r0, r0, #12
 8000bac:	4770      	bx	lr
 8000bae:	bf00      	nop
 8000bb0:	40023c14 	.word	0x40023c14

08000bb4 <FLASH_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 8000bb4:	4b04      	ldr	r3, [pc, #16]	; (8000bc8 <FLASH_ITConfig+0x14>)
 8000bb6:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
 8000bb8:	b919      	cbnz	r1, 8000bc2 <FLASH_ITConfig+0xe>
    FLASH->CR |= FLASH_IT;
  }
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(uint32_t)FLASH_IT;
 8000bba:	ea22 0000 	bic.w	r0, r2, r0
 8000bbe:	6118      	str	r0, [r3, #16]
 8000bc0:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 8000bc2:	4310      	orrs	r0, r2
 8000bc4:	6118      	str	r0, [r3, #16]
 8000bc6:	4770      	bx	lr
 8000bc8:	40023c00 	.word	0x40023c00

08000bcc <FLASH_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));

  if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
 8000bcc:	4b03      	ldr	r3, [pc, #12]	; (8000bdc <FLASH_GetFlagStatus+0x10>)
 8000bce:	68db      	ldr	r3, [r3, #12]
 8000bd0:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus; 
}
 8000bd2:	bf0c      	ite	eq
 8000bd4:	2000      	moveq	r0, #0
 8000bd6:	2001      	movne	r0, #1
 8000bd8:	4770      	bx	lr
 8000bda:	bf00      	nop
 8000bdc:	40023c00 	.word	0x40023c00

08000be0 <FLASH_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 8000be0:	4b01      	ldr	r3, [pc, #4]	; (8000be8 <FLASH_ClearFlag+0x8>)
 8000be2:	60d8      	str	r0, [r3, #12]
 8000be4:	4770      	bx	lr
 8000be6:	bf00      	nop
 8000be8:	40023c00 	.word	0x40023c00

08000bec <FLASH_GetStatus>:
  */
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8000bec:	4b0e      	ldr	r3, [pc, #56]	; (8000c28 <FLASH_GetStatus+0x3c>)
 8000bee:	68da      	ldr	r2, [r3, #12]
 8000bf0:	03d0      	lsls	r0, r2, #15
 8000bf2:	d409      	bmi.n	8000c08 <FLASH_GetStatus+0x1c>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
 8000bf4:	68da      	ldr	r2, [r3, #12]
 8000bf6:	06d1      	lsls	r1, r2, #27
 8000bf8:	d501      	bpl.n	8000bfe <FLASH_GetStatus+0x12>
    { 
      flashstatus = FLASH_ERROR_WRP;
 8000bfa:	2006      	movs	r0, #6
 8000bfc:	4770      	bx	lr
    }
    else
    {
      if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
 8000bfe:	68da      	ldr	r2, [r3, #12]
 8000c00:	05d2      	lsls	r2, r2, #23
 8000c02:	d503      	bpl.n	8000c0c <FLASH_GetStatus+0x20>
      { 
        flashstatus = FLASH_ERROR_RD;
 8000c04:	2002      	movs	r0, #2
 8000c06:	4770      	bx	lr
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
  {
    flashstatus = FLASH_BUSY;
 8000c08:	2001      	movs	r0, #1
 8000c0a:	4770      	bx	lr
      { 
        flashstatus = FLASH_ERROR_RD;
      } 
      else 
      {
        if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
 8000c0c:	68da      	ldr	r2, [r3, #12]
 8000c0e:	f012 0fef 	tst.w	r2, #239	; 0xef
 8000c12:	d001      	beq.n	8000c18 <FLASH_GetStatus+0x2c>
        {
          flashstatus = FLASH_ERROR_PROGRAM; 
 8000c14:	2007      	movs	r0, #7
      }
    }
  }
  /* Return the FLASH Status */
  return flashstatus;
}
 8000c16:	4770      	bx	lr
        {
          flashstatus = FLASH_ERROR_PROGRAM; 
        }
        else
        {
          if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
 8000c18:	68db      	ldr	r3, [r3, #12]
 8000c1a:	f013 0f02 	tst.w	r3, #2
          {
            flashstatus = FLASH_ERROR_OPERATION;
 8000c1e:	bf0c      	ite	eq
 8000c20:	2009      	moveq	r0, #9
 8000c22:	2008      	movne	r0, #8
 8000c24:	4770      	bx	lr
 8000c26:	bf00      	nop
 8000c28:	40023c00 	.word	0x40023c00

08000c2c <FLASH_WaitForLastOperation>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_WaitForLastOperation(void)
{ 
 8000c2c:	b500      	push	{lr}
 8000c2e:	b083      	sub	sp, #12
  __IO FLASH_Status status = FLASH_COMPLETE;
 8000c30:	2309      	movs	r3, #9
 8000c32:	f88d 3007 	strb.w	r3, [sp, #7]
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
 8000c36:	f7ff ffd9 	bl	8000bec <FLASH_GetStatus>
 8000c3a:	f88d 0007 	strb.w	r0, [sp, #7]

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 8000c3e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000c42:	2b01      	cmp	r3, #1
 8000c44:	d0f7      	beq.n	8000c36 <FLASH_WaitForLastOperation+0xa>
  {
    status = FLASH_GetStatus();
  }
  /* Return the operation status */
  return status;
 8000c46:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8000c4a:	b2c0      	uxtb	r0, r0
}
 8000c4c:	b003      	add	sp, #12
 8000c4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c52:	bf00      	nop

08000c54 <FLASH_EraseSector>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
{
 8000c54:	b570      	push	{r4, r5, r6, lr}
 8000c56:	4605      	mov	r5, r0

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8000c58:	b359      	cbz	r1, 8000cb2 <FLASH_EraseSector+0x5e>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
 8000c5a:	2901      	cmp	r1, #1
 8000c5c:	d02f      	beq.n	8000cbe <FLASH_EraseSector+0x6a>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == VoltageRange_3)
 8000c5e:	2902      	cmp	r1, #2
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8000c60:	bf14      	ite	ne
 8000c62:	f44f 7640 	movne.w	r6, #768	; 0x300
 8000c66:	f44f 7600 	moveq.w	r6, #512	; 0x200
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000c6a:	f7ff ffdf 	bl	8000c2c <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8000c6e:	2809      	cmp	r0, #9
 8000c70:	d124      	bne.n	8000cbc <FLASH_EraseSector+0x68>
  { 
    /* if the previous operation is completed, proceed to erase the sector */
    FLASH->CR &= CR_PSIZE_MASK;
 8000c72:	4c14      	ldr	r4, [pc, #80]	; (8000cc4 <FLASH_EraseSector+0x70>)
 8000c74:	6923      	ldr	r3, [r4, #16]
 8000c76:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000c7a:	6123      	str	r3, [r4, #16]
    FLASH->CR |= tmp_psize;
 8000c7c:	6921      	ldr	r1, [r4, #16]
 8000c7e:	430e      	orrs	r6, r1
 8000c80:	6126      	str	r6, [r4, #16]
    FLASH->CR &= SECTOR_MASK;
 8000c82:	6923      	ldr	r3, [r4, #16]
 8000c84:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000c88:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
 8000c8a:	6923      	ldr	r3, [r4, #16]
 8000c8c:	f043 0302 	orr.w	r3, r3, #2
 8000c90:	431d      	orrs	r5, r3
 8000c92:	6125      	str	r5, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8000c94:	6923      	ldr	r3, [r4, #16]
 8000c96:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000c9a:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000c9c:	f7ff ffc6 	bl	8000c2c <FLASH_WaitForLastOperation>
    
    /* if the erase operation is completed, disable the SER Bit */
    FLASH->CR &= (~FLASH_CR_SER);
 8000ca0:	6923      	ldr	r3, [r4, #16]
 8000ca2:	f023 0302 	bic.w	r3, r3, #2
 8000ca6:	6123      	str	r3, [r4, #16]
    FLASH->CR &= SECTOR_MASK; 
 8000ca8:	6923      	ldr	r3, [r4, #16]
 8000caa:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000cae:	6123      	str	r3, [r4, #16]
  }
  /* Return the Erase Status */
  return status;
}
 8000cb0:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 8000cb2:	460e      	mov	r6, r1
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000cb4:	f7ff ffba 	bl	8000c2c <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8000cb8:	2809      	cmp	r0, #9
 8000cba:	d0da      	beq.n	8000c72 <FLASH_EraseSector+0x1e>
    FLASH->CR &= (~FLASH_CR_SER);
    FLASH->CR &= SECTOR_MASK; 
  }
  /* Return the Erase Status */
  return status;
}
 8000cbc:	bd70      	pop	{r4, r5, r6, pc}
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8000cbe:	f44f 7680 	mov.w	r6, #256	; 0x100
 8000cc2:	e7f7      	b.n	8000cb4 <FLASH_EraseSector+0x60>
 8000cc4:	40023c00 	.word	0x40023c00

08000cc8 <FLASH_EraseAllSectors>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
{
 8000cc8:	b538      	push	{r3, r4, r5, lr}
 8000cca:	4604      	mov	r4, r0
  uint32_t tmp_psize = 0x0;
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000ccc:	f7ff ffae 	bl	8000c2c <FLASH_WaitForLastOperation>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8000cd0:	b13c      	cbz	r4, 8000ce2 <FLASH_EraseAllSectors+0x1a>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
 8000cd2:	2c01      	cmp	r4, #1
 8000cd4:	d008      	beq.n	8000ce8 <FLASH_EraseAllSectors+0x20>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == VoltageRange_3)
 8000cd6:	2c02      	cmp	r4, #2
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8000cd8:	bf14      	ite	ne
 8000cda:	f44f 7440 	movne.w	r4, #768	; 0x300
 8000cde:	f44f 7400 	moveq.w	r4, #512	; 0x200
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 8000ce2:	2809      	cmp	r0, #9
 8000ce4:	d004      	beq.n	8000cf0 <FLASH_EraseAllSectors+0x28>
#endif /* STM32F40_41xxx || STM32F401xx */

  }   
  /* Return the Erase Status */
  return status;
}
 8000ce6:	bd38      	pop	{r3, r4, r5, pc}
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 8000ce8:	2809      	cmp	r0, #9
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8000cea:	f44f 7480 	mov.w	r4, #256	; 0x100
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 8000cee:	d1fa      	bne.n	8000ce6 <FLASH_EraseAllSectors+0x1e>
    /* if the erase operation is completed, disable the MER Bit */
    FLASH->CR &= ~(FLASH_CR_MER1 | FLASH_CR_MER2);
#endif /* STM32F427_437xx ||  STM32F429_439xx */

#if defined (STM32F40_41xxx) || defined (STM32F401xx) 
    FLASH->CR &= CR_PSIZE_MASK;
 8000cf0:	4d0b      	ldr	r5, [pc, #44]	; (8000d20 <FLASH_EraseAllSectors+0x58>)
 8000cf2:	692b      	ldr	r3, [r5, #16]
 8000cf4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000cf8:	612b      	str	r3, [r5, #16]
    FLASH->CR |= tmp_psize;
 8000cfa:	692b      	ldr	r3, [r5, #16]
 8000cfc:	431c      	orrs	r4, r3
 8000cfe:	612c      	str	r4, [r5, #16]
    FLASH->CR |= FLASH_CR_MER;
 8000d00:	692b      	ldr	r3, [r5, #16]
 8000d02:	f043 0304 	orr.w	r3, r3, #4
 8000d06:	612b      	str	r3, [r5, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8000d08:	692b      	ldr	r3, [r5, #16]
 8000d0a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000d0e:	612b      	str	r3, [r5, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000d10:	f7ff ff8c 	bl	8000c2c <FLASH_WaitForLastOperation>

    /* if the erase operation is completed, disable the MER Bit */
    FLASH->CR &= (~FLASH_CR_MER);
 8000d14:	692b      	ldr	r3, [r5, #16]
 8000d16:	f023 0304 	bic.w	r3, r3, #4
 8000d1a:	612b      	str	r3, [r5, #16]
#endif /* STM32F40_41xxx || STM32F401xx */

  }   
  /* Return the Erase Status */
  return status;
}
 8000d1c:	bd38      	pop	{r3, r4, r5, pc}
 8000d1e:	bf00      	nop
 8000d20:	40023c00 	.word	0x40023c00

08000d24 <FLASH_EraseAllBank1Sectors>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
{
 8000d24:	b538      	push	{r3, r4, r5, lr}
 8000d26:	4604      	mov	r4, r0
  uint32_t tmp_psize = 0x0;
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000d28:	f7ff ff80 	bl	8000c2c <FLASH_WaitForLastOperation>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8000d2c:	b13c      	cbz	r4, 8000d3e <FLASH_EraseAllBank1Sectors+0x1a>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
 8000d2e:	2c01      	cmp	r4, #1
 8000d30:	d008      	beq.n	8000d44 <FLASH_EraseAllBank1Sectors+0x20>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == VoltageRange_3)
 8000d32:	2c02      	cmp	r4, #2
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8000d34:	bf14      	ite	ne
 8000d36:	f44f 7440 	movne.w	r4, #768	; 0x300
 8000d3a:	f44f 7400 	moveq.w	r4, #512	; 0x200
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 8000d3e:	2809      	cmp	r0, #9
 8000d40:	d004      	beq.n	8000d4c <FLASH_EraseAllBank1Sectors+0x28>
    FLASH->CR &= (~FLASH_CR_MER1);

  }   
  /* Return the Erase Status */
  return status;
}
 8000d42:	bd38      	pop	{r3, r4, r5, pc}
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 8000d44:	2809      	cmp	r0, #9
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8000d46:	f44f 7480 	mov.w	r4, #256	; 0x100
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 8000d4a:	d1fa      	bne.n	8000d42 <FLASH_EraseAllBank1Sectors+0x1e>
  {
    /* if the previous operation is completed, proceed to erase all sectors */
     FLASH->CR &= CR_PSIZE_MASK;
 8000d4c:	4d0b      	ldr	r5, [pc, #44]	; (8000d7c <FLASH_EraseAllBank1Sectors+0x58>)
 8000d4e:	692b      	ldr	r3, [r5, #16]
 8000d50:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000d54:	612b      	str	r3, [r5, #16]
     FLASH->CR |= tmp_psize;
 8000d56:	692b      	ldr	r3, [r5, #16]
 8000d58:	431c      	orrs	r4, r3
 8000d5a:	612c      	str	r4, [r5, #16]
     FLASH->CR |= FLASH_CR_MER1;
 8000d5c:	692b      	ldr	r3, [r5, #16]
 8000d5e:	f043 0304 	orr.w	r3, r3, #4
 8000d62:	612b      	str	r3, [r5, #16]
     FLASH->CR |= FLASH_CR_STRT;
 8000d64:	692b      	ldr	r3, [r5, #16]
 8000d66:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000d6a:	612b      	str	r3, [r5, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000d6c:	f7ff ff5e 	bl	8000c2c <FLASH_WaitForLastOperation>

    /* if the erase operation is completed, disable the MER Bit */
    FLASH->CR &= (~FLASH_CR_MER1);
 8000d70:	692b      	ldr	r3, [r5, #16]
 8000d72:	f023 0304 	bic.w	r3, r3, #4
 8000d76:	612b      	str	r3, [r5, #16]

  }   
  /* Return the Erase Status */
  return status;
}
 8000d78:	bd38      	pop	{r3, r4, r5, pc}
 8000d7a:	bf00      	nop
 8000d7c:	40023c00 	.word	0x40023c00

08000d80 <FLASH_EraseAllBank2Sectors>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)
{
 8000d80:	b538      	push	{r3, r4, r5, lr}
 8000d82:	4604      	mov	r4, r0
  uint32_t tmp_psize = 0x0;
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000d84:	f7ff ff52 	bl	8000c2c <FLASH_WaitForLastOperation>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8000d88:	b13c      	cbz	r4, 8000d9a <FLASH_EraseAllBank2Sectors+0x1a>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
 8000d8a:	2c01      	cmp	r4, #1
 8000d8c:	d008      	beq.n	8000da0 <FLASH_EraseAllBank2Sectors+0x20>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == VoltageRange_3)
 8000d8e:	2c02      	cmp	r4, #2
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8000d90:	bf14      	ite	ne
 8000d92:	f44f 7440 	movne.w	r4, #768	; 0x300
 8000d96:	f44f 7400 	moveq.w	r4, #512	; 0x200
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 8000d9a:	2809      	cmp	r0, #9
 8000d9c:	d004      	beq.n	8000da8 <FLASH_EraseAllBank2Sectors+0x28>
    FLASH->CR &= (~FLASH_CR_MER2);

  }   
  /* Return the Erase Status */
  return status;
}
 8000d9e:	bd38      	pop	{r3, r4, r5, pc}
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 8000da0:	2809      	cmp	r0, #9
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8000da2:	f44f 7480 	mov.w	r4, #256	; 0x100
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 8000da6:	d1fa      	bne.n	8000d9e <FLASH_EraseAllBank2Sectors+0x1e>
  {
    /* if the previous operation is completed, proceed to erase all sectors */
     FLASH->CR &= CR_PSIZE_MASK;
 8000da8:	4d0b      	ldr	r5, [pc, #44]	; (8000dd8 <FLASH_EraseAllBank2Sectors+0x58>)
 8000daa:	692b      	ldr	r3, [r5, #16]
 8000dac:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000db0:	612b      	str	r3, [r5, #16]
     FLASH->CR |= tmp_psize;
 8000db2:	692b      	ldr	r3, [r5, #16]
 8000db4:	431c      	orrs	r4, r3
 8000db6:	612c      	str	r4, [r5, #16]
     FLASH->CR |= FLASH_CR_MER2;
 8000db8:	692b      	ldr	r3, [r5, #16]
 8000dba:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000dbe:	612b      	str	r3, [r5, #16]
     FLASH->CR |= FLASH_CR_STRT;
 8000dc0:	692b      	ldr	r3, [r5, #16]
 8000dc2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000dc6:	612b      	str	r3, [r5, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000dc8:	f7ff ff30 	bl	8000c2c <FLASH_WaitForLastOperation>

    /* if the erase operation is completed, disable the MER Bit */
    FLASH->CR &= (~FLASH_CR_MER2);
 8000dcc:	692b      	ldr	r3, [r5, #16]
 8000dce:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8000dd2:	612b      	str	r3, [r5, #16]

  }   
  /* Return the Erase Status */
  return status;
}
 8000dd4:	bd38      	pop	{r3, r4, r5, pc}
 8000dd6:	bf00      	nop
 8000dd8:	40023c00 	.word	0x40023c00

08000ddc <FLASH_ProgramDoubleWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
{
 8000ddc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000dde:	4607      	mov	r7, r0
 8000de0:	4614      	mov	r4, r2
 8000de2:	461d      	mov	r5, r3

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000de4:	f7ff ff22 	bl	8000c2c <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8000de8:	2809      	cmp	r0, #9
 8000dea:	d000      	beq.n	8000dee <FLASH_ProgramDoubleWord+0x12>
    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
  } 
  /* Return the Program Status */
  return status;
}
 8000dec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  status = FLASH_WaitForLastOperation();
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8000dee:	4e0b      	ldr	r6, [pc, #44]	; (8000e1c <FLASH_ProgramDoubleWord+0x40>)
 8000df0:	6933      	ldr	r3, [r6, #16]
 8000df2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000df6:	6133      	str	r3, [r6, #16]
    FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8000df8:	6933      	ldr	r3, [r6, #16]
 8000dfa:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 8000dfe:	6133      	str	r3, [r6, #16]
    FLASH->CR |= FLASH_CR_PG;
 8000e00:	6933      	ldr	r3, [r6, #16]
 8000e02:	f043 0301 	orr.w	r3, r3, #1
 8000e06:	6133      	str	r3, [r6, #16]
  
    *(__IO uint64_t*)Address = Data;
 8000e08:	e9c7 4500 	strd	r4, r5, [r7]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000e0c:	f7ff ff0e 	bl	8000c2c <FLASH_WaitForLastOperation>

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8000e10:	6933      	ldr	r3, [r6, #16]
 8000e12:	f023 0301 	bic.w	r3, r3, #1
 8000e16:	6133      	str	r3, [r6, #16]
  } 
  /* Return the Program Status */
  return status;
}
 8000e18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000e1a:	bf00      	nop
 8000e1c:	40023c00 	.word	0x40023c00

08000e20 <FLASH_ProgramWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 8000e20:	b570      	push	{r4, r5, r6, lr}
 8000e22:	4605      	mov	r5, r0
 8000e24:	460e      	mov	r6, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000e26:	f7ff ff01 	bl	8000c2c <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8000e2a:	2809      	cmp	r0, #9
 8000e2c:	d000      	beq.n	8000e30 <FLASH_ProgramWord+0x10>
    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
  } 
  /* Return the Program Status */
  return status;
}
 8000e2e:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation();
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8000e30:	4c0a      	ldr	r4, [pc, #40]	; (8000e5c <FLASH_ProgramWord+0x3c>)
 8000e32:	6923      	ldr	r3, [r4, #16]
 8000e34:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000e38:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_WORD;
 8000e3a:	6923      	ldr	r3, [r4, #16]
 8000e3c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000e40:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 8000e42:	6923      	ldr	r3, [r4, #16]
 8000e44:	f043 0301 	orr.w	r3, r3, #1
 8000e48:	6123      	str	r3, [r4, #16]
  
    *(__IO uint32_t*)Address = Data;
 8000e4a:	602e      	str	r6, [r5, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000e4c:	f7ff feee 	bl	8000c2c <FLASH_WaitForLastOperation>

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8000e50:	6923      	ldr	r3, [r4, #16]
 8000e52:	f023 0301 	bic.w	r3, r3, #1
 8000e56:	6123      	str	r3, [r4, #16]
  } 
  /* Return the Program Status */
  return status;
}
 8000e58:	bd70      	pop	{r4, r5, r6, pc}
 8000e5a:	bf00      	nop
 8000e5c:	40023c00 	.word	0x40023c00

08000e60 <FLASH_ProgramHalfWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
 8000e60:	b570      	push	{r4, r5, r6, lr}
 8000e62:	4605      	mov	r5, r0
 8000e64:	460e      	mov	r6, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000e66:	f7ff fee1 	bl	8000c2c <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8000e6a:	2809      	cmp	r0, #9
 8000e6c:	d000      	beq.n	8000e70 <FLASH_ProgramHalfWord+0x10>
    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
  } 
  /* Return the Program Status */
  return status;
}
 8000e6e:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation();
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8000e70:	4c0a      	ldr	r4, [pc, #40]	; (8000e9c <FLASH_ProgramHalfWord+0x3c>)
 8000e72:	6923      	ldr	r3, [r4, #16]
 8000e74:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000e78:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8000e7a:	6923      	ldr	r3, [r4, #16]
 8000e7c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000e80:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 8000e82:	6923      	ldr	r3, [r4, #16]
 8000e84:	f043 0301 	orr.w	r3, r3, #1
 8000e88:	6123      	str	r3, [r4, #16]
  
    *(__IO uint16_t*)Address = Data;
 8000e8a:	802e      	strh	r6, [r5, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000e8c:	f7ff fece 	bl	8000c2c <FLASH_WaitForLastOperation>

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8000e90:	6923      	ldr	r3, [r4, #16]
 8000e92:	f023 0301 	bic.w	r3, r3, #1
 8000e96:	6123      	str	r3, [r4, #16]
  } 
  /* Return the Program Status */
  return status;
}
 8000e98:	bd70      	pop	{r4, r5, r6, pc}
 8000e9a:	bf00      	nop
 8000e9c:	40023c00 	.word	0x40023c00

08000ea0 <FLASH_ProgramByte>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
{
 8000ea0:	b570      	push	{r4, r5, r6, lr}
 8000ea2:	4605      	mov	r5, r0
 8000ea4:	460e      	mov	r6, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000ea6:	f7ff fec1 	bl	8000c2c <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8000eaa:	2809      	cmp	r0, #9
 8000eac:	d000      	beq.n	8000eb0 <FLASH_ProgramByte+0x10>
    FLASH->CR &= (~FLASH_CR_PG);
  } 

  /* Return the Program Status */
  return status;
}
 8000eae:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation();
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8000eb0:	4c09      	ldr	r4, [pc, #36]	; (8000ed8 <FLASH_ProgramByte+0x38>)
 8000eb2:	6923      	ldr	r3, [r4, #16]
 8000eb4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000eb8:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_BYTE;
 8000eba:	6923      	ldr	r3, [r4, #16]
 8000ebc:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 8000ebe:	6923      	ldr	r3, [r4, #16]
 8000ec0:	f043 0301 	orr.w	r3, r3, #1
 8000ec4:	6123      	str	r3, [r4, #16]
  
    *(__IO uint8_t*)Address = Data;
 8000ec6:	702e      	strb	r6, [r5, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000ec8:	f7ff feb0 	bl	8000c2c <FLASH_WaitForLastOperation>

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8000ecc:	6923      	ldr	r3, [r4, #16]
 8000ece:	f023 0301 	bic.w	r3, r3, #1
 8000ed2:	6123      	str	r3, [r4, #16]
  } 

  /* Return the Program Status */
  return status;
}
 8000ed4:	bd70      	pop	{r4, r5, r6, pc}
 8000ed6:	bf00      	nop
 8000ed8:	40023c00 	.word	0x40023c00

08000edc <FLASH_OB_WRPConfig>:
  * @param  Newstate: new state of the Write Protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None  
  */
void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
{ 
 8000edc:	b538      	push	{r3, r4, r5, lr}
 8000ede:	4605      	mov	r5, r0
 8000ee0:	460c      	mov	r4, r1
  
  /* Check the parameters */
  assert_param(IS_OB_WRP(OB_WRP));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  status = FLASH_WaitForLastOperation();
 8000ee2:	f7ff fea3 	bl	8000c2c <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 8000ee6:	2809      	cmp	r0, #9
 8000ee8:	d000      	beq.n	8000eec <FLASH_OB_WRPConfig+0x10>
 8000eea:	bd38      	pop	{r3, r4, r5, pc}
  { 
    if(NewState != DISABLE)
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
 8000eec:	4b05      	ldr	r3, [pc, #20]	; (8000f04 <FLASH_OB_WRPConfig+0x28>)
 8000eee:	881a      	ldrh	r2, [r3, #0]
    
  status = FLASH_WaitForLastOperation();

  if(status == FLASH_COMPLETE)
  { 
    if(NewState != DISABLE)
 8000ef0:	b91c      	cbnz	r4, 8000efa <FLASH_OB_WRPConfig+0x1e>
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
    }
    else
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
 8000ef2:	4315      	orrs	r5, r2
 8000ef4:	b2ad      	uxth	r5, r5
 8000ef6:	801d      	strh	r5, [r3, #0]
 8000ef8:	bd38      	pop	{r3, r4, r5, pc}

  if(status == FLASH_COMPLETE)
  { 
    if(NewState != DISABLE)
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
 8000efa:	b292      	uxth	r2, r2
 8000efc:	ea22 0505 	bic.w	r5, r2, r5
 8000f00:	801d      	strh	r5, [r3, #0]
 8000f02:	bd38      	pop	{r3, r4, r5, pc}
 8000f04:	40023c16 	.word	0x40023c16

08000f08 <FLASH_OB_WRP1Config>:
  * @param  Newstate: new state of the Write Protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None  
  */
void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)
{ 
 8000f08:	b538      	push	{r3, r4, r5, lr}
 8000f0a:	4605      	mov	r5, r0
 8000f0c:	460c      	mov	r4, r1
  
  /* Check the parameters */
  assert_param(IS_OB_WRP(OB_WRP));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  status = FLASH_WaitForLastOperation();
 8000f0e:	f7ff fe8d 	bl	8000c2c <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 8000f12:	2809      	cmp	r0, #9
 8000f14:	d000      	beq.n	8000f18 <FLASH_OB_WRP1Config+0x10>
 8000f16:	bd38      	pop	{r3, r4, r5, pc}
  { 
    if(NewState != DISABLE)
    {
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
 8000f18:	4b05      	ldr	r3, [pc, #20]	; (8000f30 <FLASH_OB_WRP1Config+0x28>)
 8000f1a:	881a      	ldrh	r2, [r3, #0]
    
  status = FLASH_WaitForLastOperation();

  if(status == FLASH_COMPLETE)
  { 
    if(NewState != DISABLE)
 8000f1c:	b91c      	cbnz	r4, 8000f26 <FLASH_OB_WRP1Config+0x1e>
    {
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
    }
    else
    {
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
 8000f1e:	4315      	orrs	r5, r2
 8000f20:	b2ad      	uxth	r5, r5
 8000f22:	801d      	strh	r5, [r3, #0]
 8000f24:	bd38      	pop	{r3, r4, r5, pc}

  if(status == FLASH_COMPLETE)
  { 
    if(NewState != DISABLE)
    {
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
 8000f26:	b292      	uxth	r2, r2
 8000f28:	ea22 0505 	bic.w	r5, r2, r5
 8000f2c:	801d      	strh	r5, [r3, #0]
 8000f2e:	bd38      	pop	{r3, r4, r5, pc}
 8000f30:	40023c1a 	.word	0x40023c1a

08000f34 <FLASH_OB_PCROPConfig>:
  * @param  Newstate: new state of the Write Protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None  
  */
void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
{ 
 8000f34:	b538      	push	{r3, r4, r5, lr}
 8000f36:	4605      	mov	r5, r0
 8000f38:	460c      	mov	r4, r1
  
  /* Check the parameters */
  assert_param(IS_OB_PCROP(OB_PCROP));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  status = FLASH_WaitForLastOperation();
 8000f3a:	f7ff fe77 	bl	8000c2c <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 8000f3e:	2809      	cmp	r0, #9
 8000f40:	d000      	beq.n	8000f44 <FLASH_OB_PCROPConfig+0x10>
 8000f42:	bd38      	pop	{r3, r4, r5, pc}
  { 
    if(NewState != DISABLE)
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
 8000f44:	4b05      	ldr	r3, [pc, #20]	; (8000f5c <FLASH_OB_PCROPConfig+0x28>)
 8000f46:	881a      	ldrh	r2, [r3, #0]
    
  status = FLASH_WaitForLastOperation();

  if(status == FLASH_COMPLETE)
  { 
    if(NewState != DISABLE)
 8000f48:	b924      	cbnz	r4, 8000f54 <FLASH_OB_PCROPConfig+0x20>
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
    }
    else
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_PCROP);
 8000f4a:	b292      	uxth	r2, r2
 8000f4c:	ea22 0505 	bic.w	r5, r2, r5
 8000f50:	801d      	strh	r5, [r3, #0]
 8000f52:	bd38      	pop	{r3, r4, r5, pc}

  if(status == FLASH_COMPLETE)
  { 
    if(NewState != DISABLE)
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
 8000f54:	4315      	orrs	r5, r2
 8000f56:	b2ad      	uxth	r5, r5
 8000f58:	801d      	strh	r5, [r3, #0]
 8000f5a:	bd38      	pop	{r3, r4, r5, pc}
 8000f5c:	40023c16 	.word	0x40023c16

08000f60 <FLASH_OB_PCROP1Config>:
  * @param  Newstate: new state of the Write Protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None  
  */
void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState)
{ 
 8000f60:	b538      	push	{r3, r4, r5, lr}
 8000f62:	4605      	mov	r5, r0
 8000f64:	460c      	mov	r4, r1
  
  /* Check the parameters */
  assert_param(IS_OB_PCROP(OB_PCROP));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  status = FLASH_WaitForLastOperation();
 8000f66:	f7ff fe61 	bl	8000c2c <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 8000f6a:	2809      	cmp	r0, #9
 8000f6c:	d000      	beq.n	8000f70 <FLASH_OB_PCROP1Config+0x10>
 8000f6e:	bd38      	pop	{r3, r4, r5, pc}
  { 
    if(NewState != DISABLE)
    {
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
 8000f70:	4b05      	ldr	r3, [pc, #20]	; (8000f88 <FLASH_OB_PCROP1Config+0x28>)
 8000f72:	881a      	ldrh	r2, [r3, #0]
    
  status = FLASH_WaitForLastOperation();

  if(status == FLASH_COMPLETE)
  { 
    if(NewState != DISABLE)
 8000f74:	b924      	cbnz	r4, 8000f80 <FLASH_OB_PCROP1Config+0x20>
    {
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
    }
    else
    {
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_PCROP);
 8000f76:	b292      	uxth	r2, r2
 8000f78:	ea22 0505 	bic.w	r5, r2, r5
 8000f7c:	801d      	strh	r5, [r3, #0]
 8000f7e:	bd38      	pop	{r3, r4, r5, pc}

  if(status == FLASH_COMPLETE)
  { 
    if(NewState != DISABLE)
    {
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
 8000f80:	4315      	orrs	r5, r2
 8000f82:	b2ad      	uxth	r5, r5
 8000f84:	801d      	strh	r5, [r3, #0]
 8000f86:	bd38      	pop	{r3, r4, r5, pc}
 8000f88:	40023c1a 	.word	0x40023c1a

08000f8c <FLASH_OB_RDPConfig>:
  * /!\ Warning /!\ When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
  *    
  * @retval None
  */
void FLASH_OB_RDPConfig(uint8_t OB_RDP)
{
 8000f8c:	b510      	push	{r4, lr}
 8000f8e:	4604      	mov	r4, r0
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_OB_RDP(OB_RDP));

  status = FLASH_WaitForLastOperation();
 8000f90:	f7ff fe4c 	bl	8000c2c <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 8000f94:	2809      	cmp	r0, #9
  {
    *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
 8000f96:	bf04      	itt	eq
 8000f98:	4b01      	ldreq	r3, [pc, #4]	; (8000fa0 <FLASH_OB_RDPConfig+0x14>)
 8000f9a:	701c      	strbeq	r4, [r3, #0]
 8000f9c:	bd10      	pop	{r4, pc}
 8000f9e:	bf00      	nop
 8000fa0:	40023c15 	.word	0x40023c15

08000fa4 <FLASH_OB_UserConfig>:
  *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval None
  */
void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
{
 8000fa4:	b570      	push	{r4, r5, r6, lr}
 8000fa6:	4606      	mov	r6, r0
 8000fa8:	460c      	mov	r4, r1
 8000faa:	4615      	mov	r5, r2
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000fac:	f7ff fe3e 	bl	8000c2c <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8000fb0:	2809      	cmp	r0, #9
 8000fb2:	d107      	bne.n	8000fc4 <FLASH_OB_UserConfig+0x20>
    optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
#endif /* STM32F427_437xx ||  STM32F429_439xx */

#if defined (STM32F40_41xxx) || defined (STM32F401xx) 
    /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
    optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
 8000fb4:	4b04      	ldr	r3, [pc, #16]	; (8000fc8 <FLASH_OB_UserConfig+0x24>)
 8000fb6:	781a      	ldrb	r2, [r3, #0]
 8000fb8:	f002 020f 	and.w	r2, r2, #15
#endif /* STM32F40_41xxx || STM32F401xx */ 

    /* Update User Option Byte */
    *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
 8000fbc:	4316      	orrs	r6, r2
 8000fbe:	4335      	orrs	r5, r6
 8000fc0:	432c      	orrs	r4, r5
 8000fc2:	701c      	strb	r4, [r3, #0]
 8000fc4:	bd70      	pop	{r4, r5, r6, pc}
 8000fc6:	bf00      	nop
 8000fc8:	40023c14 	.word	0x40023c14

08000fcc <FLASH_OB_Launch>:
FLASH_Status FLASH_OB_Launch(void)
{
  FLASH_Status status = FLASH_COMPLETE;

  /* Set the OPTSTRT bit in OPTCR register */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
 8000fcc:	4b03      	ldr	r3, [pc, #12]	; (8000fdc <FLASH_OB_Launch+0x10>)
 8000fce:	781a      	ldrb	r2, [r3, #0]
 8000fd0:	f042 0202 	orr.w	r2, r2, #2
 8000fd4:	701a      	strb	r2, [r3, #0]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000fd6:	f7ff be29 	b.w	8000c2c <FLASH_WaitForLastOperation>
 8000fda:	bf00      	nop
 8000fdc:	40023c14 	.word	0x40023c14

08000fe0 <GPIO_DeInit>:
  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices.  
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8000fe0:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8000fe2:	4b4b      	ldr	r3, [pc, #300]	; (8001110 <GPIO_DeInit+0x130>)
 8000fe4:	4298      	cmp	r0, r3
 8000fe6:	d02a      	beq.n	800103e <GPIO_DeInit+0x5e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8000fe8:	4b4a      	ldr	r3, [pc, #296]	; (8001114 <GPIO_DeInit+0x134>)
 8000fea:	4298      	cmp	r0, r3
 8000fec:	d031      	beq.n	8001052 <GPIO_DeInit+0x72>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 8000fee:	4b4a      	ldr	r3, [pc, #296]	; (8001118 <GPIO_DeInit+0x138>)
 8000ff0:	4298      	cmp	r0, r3
 8000ff2:	d038      	beq.n	8001066 <GPIO_DeInit+0x86>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 8000ff4:	4b49      	ldr	r3, [pc, #292]	; (800111c <GPIO_DeInit+0x13c>)
 8000ff6:	4298      	cmp	r0, r3
 8000ff8:	d03f      	beq.n	800107a <GPIO_DeInit+0x9a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
 8000ffa:	4b49      	ldr	r3, [pc, #292]	; (8001120 <GPIO_DeInit+0x140>)
 8000ffc:	4298      	cmp	r0, r3
 8000ffe:	d046      	beq.n	800108e <GPIO_DeInit+0xae>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
 8001000:	4b48      	ldr	r3, [pc, #288]	; (8001124 <GPIO_DeInit+0x144>)
 8001002:	4298      	cmp	r0, r3
 8001004:	d04d      	beq.n	80010a2 <GPIO_DeInit+0xc2>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
 8001006:	4b48      	ldr	r3, [pc, #288]	; (8001128 <GPIO_DeInit+0x148>)
 8001008:	4298      	cmp	r0, r3
 800100a:	d054      	beq.n	80010b6 <GPIO_DeInit+0xd6>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
 800100c:	4b47      	ldr	r3, [pc, #284]	; (800112c <GPIO_DeInit+0x14c>)
 800100e:	4298      	cmp	r0, r3
 8001010:	d05b      	beq.n	80010ca <GPIO_DeInit+0xea>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
  }

  else if (GPIOx == GPIOI)
 8001012:	4b47      	ldr	r3, [pc, #284]	; (8001130 <GPIO_DeInit+0x150>)
 8001014:	4298      	cmp	r0, r3
 8001016:	d062      	beq.n	80010de <GPIO_DeInit+0xfe>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
  }
  else if (GPIOx == GPIOJ)
 8001018:	4b46      	ldr	r3, [pc, #280]	; (8001134 <GPIO_DeInit+0x154>)
 800101a:	4298      	cmp	r0, r3
 800101c:	d06b      	beq.n	80010f6 <GPIO_DeInit+0x116>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOK)
 800101e:	4b46      	ldr	r3, [pc, #280]	; (8001138 <GPIO_DeInit+0x158>)
 8001020:	4298      	cmp	r0, r3
 8001022:	d000      	beq.n	8001026 <GPIO_DeInit+0x46>
 8001024:	bd08      	pop	{r3, pc}
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
 8001026:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800102a:	2101      	movs	r1, #1
 800102c:	f000 fd60 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
 8001030:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001034:	2100      	movs	r1, #0
    }
  }
}
 8001036:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (GPIOx == GPIOK)
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
 800103a:	f000 bd59 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 800103e:	2001      	movs	r0, #1
 8001040:	4601      	mov	r1, r0
 8001042:	f000 fd55 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 8001046:	2001      	movs	r0, #1
 8001048:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 800104a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 800104e:	f000 bd4f 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8001052:	2002      	movs	r0, #2
 8001054:	2101      	movs	r1, #1
 8001056:	f000 fd4b 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 800105a:	2002      	movs	r0, #2
 800105c:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 800105e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 8001062:	f000 bd45 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8001066:	2004      	movs	r0, #4
 8001068:	2101      	movs	r1, #1
 800106a:	f000 fd41 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 800106e:	2004      	movs	r0, #4
 8001070:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 8001072:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 8001076:	f000 bd3b 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 800107a:	2008      	movs	r0, #8
 800107c:	2101      	movs	r1, #1
 800107e:	f000 fd37 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 8001082:	2008      	movs	r0, #8
 8001084:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 8001086:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 800108a:	f000 bd31 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 800108e:	2010      	movs	r0, #16
 8001090:	2101      	movs	r1, #1
 8001092:	f000 fd2d 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 8001096:	2010      	movs	r0, #16
 8001098:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 800109a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 800109e:	f000 bd27 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 80010a2:	2020      	movs	r0, #32
 80010a4:	2101      	movs	r1, #1
 80010a6:	f000 fd23 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80010aa:	2020      	movs	r0, #32
 80010ac:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 80010ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80010b2:	f000 bd1d 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 80010b6:	2040      	movs	r0, #64	; 0x40
 80010b8:	2101      	movs	r1, #1
 80010ba:	f000 fd19 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 80010be:	2040      	movs	r0, #64	; 0x40
 80010c0:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 80010c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 80010c6:	f000 bd13 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 80010ca:	2080      	movs	r0, #128	; 0x80
 80010cc:	2101      	movs	r1, #1
 80010ce:	f000 fd0f 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 80010d2:	2080      	movs	r0, #128	; 0x80
 80010d4:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 80010d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 80010da:	f000 bd09 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  }

  else if (GPIOx == GPIOI)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 80010de:	f44f 7080 	mov.w	r0, #256	; 0x100
 80010e2:	2101      	movs	r1, #1
 80010e4:	f000 fd04 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80010e8:	f44f 7080 	mov.w	r0, #256	; 0x100
 80010ec:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 80010ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  }

  else if (GPIOx == GPIOI)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80010f2:	f000 bcfd 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOJ)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, ENABLE);
 80010f6:	f44f 7000 	mov.w	r0, #512	; 0x200
 80010fa:	2101      	movs	r1, #1
 80010fc:	f000 fcf8 	bl	8001af0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, DISABLE);
 8001100:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001104:	2100      	movs	r1, #0
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    }
  }
}
 8001106:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
  }
  else if (GPIOx == GPIOJ)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, DISABLE);
 800110a:	f000 bcf1 	b.w	8001af0 <RCC_AHB1PeriphResetCmd>
 800110e:	bf00      	nop
 8001110:	40020000 	.word	0x40020000
 8001114:	40020400 	.word	0x40020400
 8001118:	40020800 	.word	0x40020800
 800111c:	40020c00 	.word	0x40020c00
 8001120:	40021000 	.word	0x40021000
 8001124:	40021400 	.word	0x40021400
 8001128:	40021800 	.word	0x40021800
 800112c:	40021c00 	.word	0x40021c00
 8001130:	40022000 	.word	0x40022000
 8001134:	40022400 	.word	0x40022400
 8001138:	40022800 	.word	0x40022800

0800113c <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 800113c:	2200      	movs	r2, #0
 800113e:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001142:	4613      	mov	r3, r2
 8001144:	680e      	ldr	r6, [r1, #0]
  {
    pos = ((uint32_t)0x01) << pinpos;
 8001146:	2701      	movs	r7, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8001148:	f04f 0803 	mov.w	r8, #3
 800114c:	e004      	b.n	8001158 <GPIO_Init+0x1c>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800114e:	3301      	adds	r3, #1
 8001150:	2b10      	cmp	r3, #16
 8001152:	f102 0202 	add.w	r2, r2, #2
 8001156:	d02c      	beq.n	80011b2 <GPIO_Init+0x76>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8001158:	fa07 f403 	lsl.w	r4, r7, r3
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800115c:	ea04 0506 	and.w	r5, r4, r6

    if (currentpin == pos)
 8001160:	42a5      	cmp	r5, r4
 8001162:	d1f4      	bne.n	800114e <GPIO_Init+0x12>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8001164:	f8d0 9000 	ldr.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001168:	f891 c004 	ldrb.w	ip, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 800116c:	fa08 f402 	lsl.w	r4, r8, r2
 8001170:	43e4      	mvns	r4, r4
 8001172:	ea04 0909 	and.w	r9, r4, r9
 8001176:	f8c0 9000 	str.w	r9, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800117a:	f8d0 9000 	ldr.w	r9, [r0]
 800117e:	fa0c fa02 	lsl.w	sl, ip, r2

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001182:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001186:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800118a:	f1bc 0f01 	cmp.w	ip, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800118e:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001192:	d911      	bls.n	80011b8 <GPIO_Init+0x7c>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8001194:	68c5      	ldr	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001196:	f891 c007 	ldrb.w	ip, [r1, #7]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 800119a:	402c      	ands	r4, r5
 800119c:	60c4      	str	r4, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800119e:	68c5      	ldr	r5, [r0, #12]
 80011a0:	fa0c f402 	lsl.w	r4, ip, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80011a4:	3301      	adds	r3, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80011a6:	432c      	orrs	r4, r5
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80011a8:	2b10      	cmp	r3, #16
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80011aa:	60c4      	str	r4, [r0, #12]
 80011ac:	f102 0202 	add.w	r2, r2, #2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80011b0:	d1d2      	bne.n	8001158 <GPIO_Init+0x1c>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 80011b2:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 80011b6:	4770      	bx	lr
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80011b8:	f8d0 a008 	ldr.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80011bc:	f891 9005 	ldrb.w	r9, [r1, #5]
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80011c0:	f891 c006 	ldrb.w	ip, [r1, #6]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80011c4:	ea04 0a0a 	and.w	sl, r4, sl
 80011c8:	f8c0 a008 	str.w	sl, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80011cc:	f8d0 a008 	ldr.w	sl, [r0, #8]
 80011d0:	fa09 f902 	lsl.w	r9, r9, r2
 80011d4:	ea49 090a 	orr.w	r9, r9, sl
 80011d8:	f8c0 9008 	str.w	r9, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 80011dc:	f8d0 9004 	ldr.w	r9, [r0, #4]
 80011e0:	ea29 0505 	bic.w	r5, r9, r5
 80011e4:	6045      	str	r5, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80011e6:	6845      	ldr	r5, [r0, #4]
 80011e8:	fa0c fc03 	lsl.w	ip, ip, r3
 80011ec:	fa1f fc8c 	uxth.w	ip, ip
 80011f0:	ea4c 0505 	orr.w	r5, ip, r5
 80011f4:	6045      	str	r5, [r0, #4]
 80011f6:	e7cd      	b.n	8001194 <GPIO_Init+0x58>

080011f8 <GPIO_StructInit>:
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 80011f8:	2300      	movs	r3, #0
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 80011fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80011fe:	6002      	str	r2, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8001200:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8001202:	7143      	strb	r3, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 8001204:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 8001206:	71c3      	strb	r3, [r0, #7]
 8001208:	4770      	bx	lr
 800120a:	bf00      	nop

0800120c <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800120c:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 800120e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001212:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 8001214:	9b01      	ldr	r3, [sp, #4]
 8001216:	430b      	orrs	r3, r1
 8001218:	9301      	str	r3, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800121a:	9b01      	ldr	r3, [sp, #4]
 800121c:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 800121e:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8001220:	9b01      	ldr	r3, [sp, #4]
 8001222:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8001224:	69c3      	ldr	r3, [r0, #28]
 8001226:	9301      	str	r3, [sp, #4]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8001228:	69c3      	ldr	r3, [r0, #28]
 800122a:	9301      	str	r3, [sp, #4]
}
 800122c:	b002      	add	sp, #8
 800122e:	4770      	bx	lr

08001230 <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8001230:	6903      	ldr	r3, [r0, #16]
 8001232:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8001234:	bf0c      	ite	eq
 8001236:	2000      	moveq	r0, #0
 8001238:	2001      	movne	r0, #1
 800123a:	4770      	bx	lr

0800123c <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 800123c:	6900      	ldr	r0, [r0, #16]
}
 800123e:	b280      	uxth	r0, r0
 8001240:	4770      	bx	lr
 8001242:	bf00      	nop

08001244 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if (((GPIOx->ODR) & GPIO_Pin) != (uint32_t)Bit_RESET)
 8001244:	6943      	ldr	r3, [r0, #20]
 8001246:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8001248:	bf0c      	ite	eq
 800124a:	2000      	moveq	r0, #0
 800124c:	2001      	movne	r0, #1
 800124e:	4770      	bx	lr

08001250 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 8001250:	6940      	ldr	r0, [r0, #20]
}
 8001252:	b280      	uxth	r0, r0
 8001254:	4770      	bx	lr
 8001256:	bf00      	nop

08001258 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 8001258:	8301      	strh	r1, [r0, #24]
 800125a:	4770      	bx	lr

0800125c <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 800125c:	8341      	strh	r1, [r0, #26]
 800125e:	4770      	bx	lr

08001260 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8001260:	b90a      	cbnz	r2, 8001266 <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 8001262:	8341      	strh	r1, [r0, #26]
 8001264:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRRL = GPIO_Pin;
 8001266:	8301      	strh	r1, [r0, #24]
 8001268:	4770      	bx	lr
 800126a:	bf00      	nop

0800126c <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 800126c:	6141      	str	r1, [r0, #20]
 800126e:	4770      	bx	lr

08001270 <GPIO_ToggleBits>:
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 8001270:	6943      	ldr	r3, [r0, #20]
 8001272:	4059      	eors	r1, r3
 8001274:	6141      	str	r1, [r0, #20]
 8001276:	4770      	bx	lr

08001278 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429xx/439xx devices. 
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8001278:	08cb      	lsrs	r3, r1, #3
 800127a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800127e:	f001 0107 	and.w	r1, r1, #7
  *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429xx/439xx devices. 
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8001282:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001284:	0089      	lsls	r1, r1, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001286:	6a04      	ldr	r4, [r0, #32]
 8001288:	230f      	movs	r3, #15
 800128a:	408b      	lsls	r3, r1
 800128c:	ea24 0303 	bic.w	r3, r4, r3
 8001290:	6203      	str	r3, [r0, #32]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8001292:	6a03      	ldr	r3, [r0, #32]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
}
 8001294:	f85d 4b04 	ldr.w	r4, [sp], #4
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001298:	408a      	lsls	r2, r1
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 800129a:	4313      	orrs	r3, r2
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 800129c:	6203      	str	r3, [r0, #32]
}
 800129e:	4770      	bx	lr

080012a0 <I2C_DeInit>:
  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 80012a0:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 80012a2:	4b17      	ldr	r3, [pc, #92]	; (8001300 <I2C_DeInit+0x60>)
 80012a4:	4298      	cmp	r0, r3
 80012a6:	d012      	beq.n	80012ce <I2C_DeInit+0x2e>
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
  }
  else if (I2Cx == I2C2)
 80012a8:	4b16      	ldr	r3, [pc, #88]	; (8001304 <I2C_DeInit+0x64>)
 80012aa:	4298      	cmp	r0, r3
 80012ac:	d01b      	beq.n	80012e6 <I2C_DeInit+0x46>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
  }
  else 
  {
    if (I2Cx == I2C3)
 80012ae:	4b16      	ldr	r3, [pc, #88]	; (8001308 <I2C_DeInit+0x68>)
 80012b0:	4298      	cmp	r0, r3
 80012b2:	d000      	beq.n	80012b6 <I2C_DeInit+0x16>
 80012b4:	bd08      	pop	{r3, pc}
    {
      /* Enable I2C3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
 80012b6:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 80012ba:	2101      	movs	r1, #1
 80012bc:	f000 fc3c 	bl	8001b38 <RCC_APB1PeriphResetCmd>
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 80012c0:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 80012c4:	2100      	movs	r1, #0
    }
  }
}
 80012c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (I2Cx == I2C3)
    {
      /* Enable I2C3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 80012ca:	f000 bc35 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 80012ce:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80012d2:	2101      	movs	r1, #1
 80012d4:	f000 fc30 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
 80012d8:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80012dc:	2100      	movs	r1, #0
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
    }
  }
}
 80012de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (I2Cx == I2C1)
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
 80012e2:	f000 bc29 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }
  else if (I2Cx == I2C2)
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 80012e6:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80012ea:	2101      	movs	r1, #1
 80012ec:	f000 fc24 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
 80012f0:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80012f4:	2100      	movs	r1, #0
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
    }
  }
}
 80012f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else if (I2Cx == I2C2)
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
 80012fa:	f000 bc1d 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
 80012fe:	bf00      	nop
 8001300:	40005400 	.word	0x40005400
 8001304:	40005800 	.word	0x40005800
 8001308:	40005c00 	.word	0x40005c00

0800130c <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 800130c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800130e:	4604      	mov	r4, r0
 8001310:	b085      	sub	sp, #20
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8001312:	4668      	mov	r0, sp
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 8001314:	460d      	mov	r5, r1
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 8001316:	88a6      	ldrh	r6, [r4, #4]
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8001318:	f000 faf8 	bl	800190c <RCC_GetClocksFreq>
  pclk1 = rcc_clocks.PCLK1_Frequency;
 800131c:	9902      	ldr	r1, [sp, #8]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 800131e:	4830      	ldr	r0, [pc, #192]	; (80013e0 <I2C_Init+0xd4>)
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8001320:	682a      	ldr	r2, [r5, #0]
 8001322:	f8df c0c4 	ldr.w	ip, [pc, #196]	; 80013e8 <I2C_Init+0xdc>
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  pclk1 = rcc_clocks.PCLK1_Frequency;
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8001326:	fba0 3001 	umull	r3, r0, r0, r1

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 800132a:	f026 063f 	bic.w	r6, r6, #63	; 0x3f
 800132e:	0436      	lsls	r6, r6, #16
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  pclk1 = rcc_clocks.PCLK1_Frequency;
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8001330:	0c80      	lsrs	r0, r0, #18

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 8001332:	0c36      	lsrs	r6, r6, #16
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  pclk1 = rcc_clocks.PCLK1_Frequency;
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8001334:	b287      	uxth	r7, r0
  tmpreg |= freqrange;
 8001336:	433e      	orrs	r6, r7
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 8001338:	80a6      	strh	r6, [r4, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 800133a:	8823      	ldrh	r3, [r4, #0]
 800133c:	f023 0301 	bic.w	r3, r3, #1
 8001340:	041b      	lsls	r3, r3, #16
 8001342:	0c1b      	lsrs	r3, r3, #16
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8001344:	4562      	cmp	r2, ip
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 8001346:	8023      	strh	r3, [r4, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8001348:	d823      	bhi.n	8001392 <I2C_Init+0x86>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 800134a:	0053      	lsls	r3, r2, #1
 800134c:	fbb1 f3f3 	udiv	r3, r1, r3
 8001350:	b29b      	uxth	r3, r3
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
 8001352:	2b03      	cmp	r3, #3
      result = 0x04;  
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 8001354:	f107 0701 	add.w	r7, r7, #1
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
    {
      /* Set minimum allowed value */
      result = 0x04;  
 8001358:	bf98      	it	ls
 800135a:	2304      	movls	r3, #4
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 800135c:	8427      	strh	r7, [r4, #32]
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 800135e:	83a3      	strh	r3, [r4, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8001360:	8823      	ldrh	r3, [r4, #0]
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8001362:	896e      	ldrh	r6, [r5, #10]
 8001364:	88a8      	ldrh	r0, [r5, #4]
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8001366:	8929      	ldrh	r1, [r5, #8]
 8001368:	89aa      	ldrh	r2, [r5, #12]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 800136a:	b29b      	uxth	r3, r3
 800136c:	f043 0301 	orr.w	r3, r3, #1
 8001370:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 8001372:	8823      	ldrh	r3, [r4, #0]
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 8001374:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 8001378:	f023 0302 	bic.w	r3, r3, #2
 800137c:	041b      	lsls	r3, r3, #16
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 800137e:	4330      	orrs	r0, r6

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 8001380:	0c1b      	lsrs	r3, r3, #16
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8001382:	4303      	orrs	r3, r0
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8001384:	430a      	orrs	r2, r1
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8001386:	b29b      	uxth	r3, r3
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8001388:	b292      	uxth	r2, r2
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 800138a:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 800138c:	8122      	strh	r2, [r4, #8]
}
 800138e:	b005      	add	sp, #20
 8001390:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Configure speed in fast mode */
  /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
     input clock) must be a multiple of 10 MHz */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 8001392:	88ee      	ldrh	r6, [r5, #6]
 8001394:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 8001398:	429e      	cmp	r6, r3
 800139a:	d01a      	beq.n	80013d2 <I2C_Init+0xc6>
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 800139c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80013a0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80013a4:	fbb1 f3f2 	udiv	r3, r1, r2
 80013a8:	b29b      	uxth	r3, r3
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
 80013aa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    }

    /* Test if CCR value is under 0x1*/
    if ((result & I2C_CCR_CCR) == 0)
 80013ae:	f3c3 020b 	ubfx	r2, r3, #0, #12
 80013b2:	b90a      	cbnz	r2, 80013b8 <I2C_Init+0xac>
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 80013b4:	f043 0301 	orr.w	r3, r3, #1
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 80013b8:	f44f 7196 	mov.w	r1, #300	; 0x12c
 80013bc:	4a09      	ldr	r2, [pc, #36]	; (80013e4 <I2C_Init+0xd8>)
 80013be:	fb01 f000 	mul.w	r0, r1, r0
 80013c2:	fb82 1000 	smull	r1, r0, r2, r0
 80013c6:	0980      	lsrs	r0, r0, #6
 80013c8:	3001      	adds	r0, #1
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
 80013ca:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 80013ce:	8420      	strh	r0, [r4, #32]
 80013d0:	e7c5      	b.n	800135e <I2C_Init+0x52>
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 80013d2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80013d6:	fbb1 f3f2 	udiv	r3, r1, r2
 80013da:	b29b      	uxth	r3, r3
 80013dc:	e7e7      	b.n	80013ae <I2C_Init+0xa2>
 80013de:	bf00      	nop
 80013e0:	431bde83 	.word	0x431bde83
 80013e4:	10624dd3 	.word	0x10624dd3
 80013e8:	000186a0 	.word	0x000186a0

080013ec <I2C_StructInit>:
{
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 80013ec:	2300      	movs	r3, #0
  * @brief  Fills each I2C_InitStruct member with its default value.
  * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
  * @retval None
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
 80013ee:	b410      	push	{r4}
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 80013f0:	f64b 71ff 	movw	r1, #49151	; 0xbfff
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
 80013f4:	f241 3488 	movw	r4, #5000	; 0x1388
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80013f8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
 80013fc:	6004      	str	r4, [r0, #0]
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 80013fe:	80c1      	strh	r1, [r0, #6]
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8001400:	8182      	strh	r2, [r0, #12]
{
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 8001402:	8083      	strh	r3, [r0, #4]
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 8001404:	8103      	strh	r3, [r0, #8]
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8001406:	8143      	strh	r3, [r0, #10]
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
}
 8001408:	f85d 4b04 	ldr.w	r4, [sp], #4
 800140c:	4770      	bx	lr
 800140e:	bf00      	nop

08001410 <I2C_Cmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8001410:	8803      	ldrh	r3, [r0, #0]
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001412:	b929      	cbnz	r1, 8001420 <I2C_Cmd+0x10>
    I2Cx->CR1 |= I2C_CR1_PE;
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 8001414:	f023 0301 	bic.w	r3, r3, #1
 8001418:	041b      	lsls	r3, r3, #16
 800141a:	0c1b      	lsrs	r3, r3, #16
 800141c:	8003      	strh	r3, [r0, #0]
 800141e:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8001420:	b29b      	uxth	r3, r3
 8001422:	f043 0301 	orr.w	r3, r3, #1
 8001426:	8003      	strh	r3, [r0, #0]
 8001428:	4770      	bx	lr
 800142a:	bf00      	nop

0800142c <I2C_AnalogFilterCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the analog filter */
    I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
 800142c:	8c83      	ldrh	r3, [r0, #36]	; 0x24
void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800142e:	b921      	cbnz	r1, 800143a <I2C_AnalogFilterCmd+0xe>
    I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
  }
  else
  {
    /* Disable the analog filter */
    I2Cx->FLTR |= I2C_FLTR_ANOFF;
 8001430:	b29b      	uxth	r3, r3
 8001432:	f043 0310 	orr.w	r3, r3, #16
 8001436:	8483      	strh	r3, [r0, #36]	; 0x24
 8001438:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the analog filter */
    I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
 800143a:	f023 0310 	bic.w	r3, r3, #16
 800143e:	041b      	lsls	r3, r3, #16
 8001440:	0c1b      	lsrs	r3, r3, #16
 8001442:	8483      	strh	r3, [r0, #36]	; 0x24
 8001444:	4770      	bx	lr
 8001446:	bf00      	nop

08001448 <I2C_DigitalFilterConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
  
  /* Get the old register value */
  tmpreg = I2Cx->FLTR;
 8001448:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 800144a:	b29b      	uxth	r3, r3
  
  /* Reset I2Cx DNF bit [3:0] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
  
  /* Set I2Cx DNF coefficient */
  tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
 800144c:	f001 010f 	and.w	r1, r1, #15
  
  /* Get the old register value */
  tmpreg = I2Cx->FLTR;
  
  /* Reset I2Cx DNF bit [3:0] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
 8001450:	f023 030f 	bic.w	r3, r3, #15
  
  /* Set I2Cx DNF coefficient */
  tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
 8001454:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  I2Cx->FLTR = tmpreg;
 8001456:	8481      	strh	r1, [r0, #36]	; 0x24
 8001458:	4770      	bx	lr
 800145a:	bf00      	nop

0800145c <I2C_GenerateSTART>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a START condition */
    I2Cx->CR1 |= I2C_CR1_START;
 800145c:	8803      	ldrh	r3, [r0, #0]
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800145e:	b929      	cbnz	r1, 800146c <I2C_GenerateSTART+0x10>
    I2Cx->CR1 |= I2C_CR1_START;
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
 8001460:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001464:	041b      	lsls	r3, r3, #16
 8001466:	0c1b      	lsrs	r3, r3, #16
 8001468:	8003      	strh	r3, [r0, #0]
 800146a:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a START condition */
    I2Cx->CR1 |= I2C_CR1_START;
 800146c:	b29b      	uxth	r3, r3
 800146e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001472:	8003      	strh	r3, [r0, #0]
 8001474:	4770      	bx	lr
 8001476:	bf00      	nop

08001478 <I2C_GenerateSTOP>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
 8001478:	8803      	ldrh	r3, [r0, #0]
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800147a:	b929      	cbnz	r1, 8001488 <I2C_GenerateSTOP+0x10>
    I2Cx->CR1 |= I2C_CR1_STOP;
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
 800147c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001480:	041b      	lsls	r3, r3, #16
 8001482:	0c1b      	lsrs	r3, r3, #16
 8001484:	8003      	strh	r3, [r0, #0]
 8001486:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
 8001488:	b29b      	uxth	r3, r3
 800148a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800148e:	8003      	strh	r3, [r0, #0]
 8001490:	4770      	bx	lr
 8001492:	bf00      	nop

08001494 <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 8001494:	b91a      	cbnz	r2, 800149e <I2C_Send7bitAddress+0xa>
    Address |= I2C_OAR1_ADD0;
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
 8001496:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 800149a:	8201      	strh	r1, [r0, #16]
 800149c:	4770      	bx	lr
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
  {
    /* Set the address bit0 for read */
    Address |= I2C_OAR1_ADD0;
 800149e:	f041 0101 	orr.w	r1, r1, #1
  {
    /* Reset the address bit0 for write */
    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
  }
  /* Send the address */
  I2Cx->DR = Address;
 80014a2:	8201      	strh	r1, [r0, #16]
 80014a4:	4770      	bx	lr
 80014a6:	bf00      	nop

080014a8 <I2C_AcknowledgeConfig>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= I2C_CR1_ACK;
 80014a8:	8803      	ldrh	r3, [r0, #0]
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80014aa:	b929      	cbnz	r1, 80014b8 <I2C_AcknowledgeConfig+0x10>
    I2Cx->CR1 |= I2C_CR1_ACK;
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
 80014ac:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80014b0:	041b      	lsls	r3, r3, #16
 80014b2:	0c1b      	lsrs	r3, r3, #16
 80014b4:	8003      	strh	r3, [r0, #0]
 80014b6:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= I2C_CR1_ACK;
 80014b8:	b29b      	uxth	r3, r3
 80014ba:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80014be:	8003      	strh	r3, [r0, #0]
 80014c0:	4770      	bx	lr
 80014c2:	bf00      	nop

080014c4 <I2C_OwnAddress2Config>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 80014c4:	8983      	ldrh	r3, [r0, #12]
 80014c6:	b29b      	uxth	r3, r3

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 80014c8:	f001 01fe 	and.w	r1, r1, #254	; 0xfe

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
 80014cc:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 80014d0:	4319      	orrs	r1, r3

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 80014d2:	8181      	strh	r1, [r0, #12]
 80014d4:	4770      	bx	lr
 80014d6:	bf00      	nop

080014d8 <I2C_DualAddressCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
 80014d8:	8983      	ldrh	r3, [r0, #12]
void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80014da:	b929      	cbnz	r1, 80014e8 <I2C_DualAddressCmd+0x10>
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
  }
  else
  {
    /* Disable dual addressing mode */
    I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
 80014dc:	f023 0301 	bic.w	r3, r3, #1
 80014e0:	041b      	lsls	r3, r3, #16
 80014e2:	0c1b      	lsrs	r3, r3, #16
 80014e4:	8183      	strh	r3, [r0, #12]
 80014e6:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
 80014e8:	b29b      	uxth	r3, r3
 80014ea:	f043 0301 	orr.w	r3, r3, #1
 80014ee:	8183      	strh	r3, [r0, #12]
 80014f0:	4770      	bx	lr
 80014f2:	bf00      	nop

080014f4 <I2C_GeneralCallCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable generall call */
    I2Cx->CR1 |= I2C_CR1_ENGC;
 80014f4:	8803      	ldrh	r3, [r0, #0]
void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80014f6:	b929      	cbnz	r1, 8001504 <I2C_GeneralCallCmd+0x10>
    I2Cx->CR1 |= I2C_CR1_ENGC;
  }
  else
  {
    /* Disable generall call */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
 80014f8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80014fc:	041b      	lsls	r3, r3, #16
 80014fe:	0c1b      	lsrs	r3, r3, #16
 8001500:	8003      	strh	r3, [r0, #0]
 8001502:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable generall call */
    I2Cx->CR1 |= I2C_CR1_ENGC;
 8001504:	b29b      	uxth	r3, r3
 8001506:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800150a:	8003      	strh	r3, [r0, #0]
 800150c:	4770      	bx	lr
 800150e:	bf00      	nop

08001510 <I2C_SoftwareResetCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= I2C_CR1_SWRST;
 8001510:	8803      	ldrh	r3, [r0, #0]
void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001512:	b919      	cbnz	r1, 800151c <I2C_SoftwareResetCmd+0xc>
    I2Cx->CR1 |= I2C_CR1_SWRST;
  }
  else
  {
    /* Peripheral not under reset */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
 8001514:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8001518:	8003      	strh	r3, [r0, #0]
 800151a:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= I2C_CR1_SWRST;
 800151c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8001520:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8001524:	b29b      	uxth	r3, r3
 8001526:	8003      	strh	r3, [r0, #0]
 8001528:	4770      	bx	lr
 800152a:	bf00      	nop

0800152c <I2C_StretchClockCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 800152c:	8803      	ldrh	r3, [r0, #0]
void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
 800152e:	b129      	cbz	r1, 800153c <I2C_StretchClockCmd+0x10>
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
  }
  else
  {
    /* Disable the selected I2C Clock stretching */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
 8001530:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001534:	041b      	lsls	r3, r3, #16
 8001536:	0c1b      	lsrs	r3, r3, #16
 8001538:	8003      	strh	r3, [r0, #0]
 800153a:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 800153c:	b29b      	uxth	r3, r3
 800153e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001542:	8003      	strh	r3, [r0, #0]
 8001544:	4770      	bx	lr
 8001546:	bf00      	nop

08001548 <I2C_FastModeDutyCycleConfig>:
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 8001548:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 800154c:	8b83      	ldrh	r3, [r0, #28]
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 800154e:	d005      	beq.n	800155c <I2C_FastModeDutyCycleConfig+0x14>
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 8001550:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001554:	041b      	lsls	r3, r3, #16
 8001556:	0c1b      	lsrs	r3, r3, #16
 8001558:	8383      	strh	r3, [r0, #28]
 800155a:	4770      	bx	lr
  }
  else
  {
    /* I2C fast mode Tlow/Thigh=16/9 */
    I2Cx->CCR |= I2C_DutyCycle_16_9;
 800155c:	b29b      	uxth	r3, r3
 800155e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001562:	8383      	strh	r3, [r0, #28]
 8001564:	4770      	bx	lr
 8001566:	bf00      	nop

08001568 <I2C_NACKPositionConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
 8001568:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
  {
    /* Next byte in shift register is the last received byte */
    I2Cx->CR1 |= I2C_NACKPosition_Next;
 800156c:	8803      	ldrh	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
 800156e:	d005      	beq.n	800157c <I2C_NACKPositionConfig+0x14>
    I2Cx->CR1 |= I2C_NACKPosition_Next;
  }
  else
  {
    /* Current byte in shift register is the last received byte */
    I2Cx->CR1 &= I2C_NACKPosition_Current;
 8001570:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001574:	041b      	lsls	r3, r3, #16
 8001576:	0c1b      	lsrs	r3, r3, #16
 8001578:	8003      	strh	r3, [r0, #0]
 800157a:	4770      	bx	lr
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
  {
    /* Next byte in shift register is the last received byte */
    I2Cx->CR1 |= I2C_NACKPosition_Next;
 800157c:	b29b      	uxth	r3, r3
 800157e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001582:	8003      	strh	r3, [r0, #0]
 8001584:	4770      	bx	lr
 8001586:	bf00      	nop

08001588 <I2C_SMBusAlertConfig>:
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 8001588:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 800158c:	8803      	ldrh	r3, [r0, #0]
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 800158e:	d005      	beq.n	800159c <I2C_SMBusAlertConfig+0x14>
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
  }
  else
  {
    /* Drive the SMBusAlert pin High  */
    I2Cx->CR1 &= I2C_SMBusAlert_High;
 8001590:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001594:	041b      	lsls	r3, r3, #16
 8001596:	0c1b      	lsrs	r3, r3, #16
 8001598:	8003      	strh	r3, [r0, #0]
 800159a:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 800159c:	b29b      	uxth	r3, r3
 800159e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80015a2:	8003      	strh	r3, [r0, #0]
 80015a4:	4770      	bx	lr
 80015a6:	bf00      	nop

080015a8 <I2C_ARPCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= I2C_CR1_ENARP;
 80015a8:	8803      	ldrh	r3, [r0, #0]
void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80015aa:	b929      	cbnz	r1, 80015b8 <I2C_ARPCmd+0x10>
    I2Cx->CR1 |= I2C_CR1_ENARP;
  }
  else
  {
    /* Disable the selected I2C ARP */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
 80015ac:	f023 0310 	bic.w	r3, r3, #16
 80015b0:	041b      	lsls	r3, r3, #16
 80015b2:	0c1b      	lsrs	r3, r3, #16
 80015b4:	8003      	strh	r3, [r0, #0]
 80015b6:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= I2C_CR1_ENARP;
 80015b8:	b29b      	uxth	r3, r3
 80015ba:	f043 0310 	orr.w	r3, r3, #16
 80015be:	8003      	strh	r3, [r0, #0]
 80015c0:	4770      	bx	lr
 80015c2:	bf00      	nop

080015c4 <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 80015c4:	8201      	strh	r1, [r0, #16]
 80015c6:	4770      	bx	lr

080015c8 <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 80015c8:	8a00      	ldrh	r0, [r0, #16]
}
 80015ca:	b2c0      	uxtb	r0, r0
 80015cc:	4770      	bx	lr
 80015ce:	bf00      	nop

080015d0 <I2C_TransmitPEC>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= I2C_CR1_PEC;
 80015d0:	8803      	ldrh	r3, [r0, #0]
void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80015d2:	b929      	cbnz	r1, 80015e0 <I2C_TransmitPEC+0x10>
    I2Cx->CR1 |= I2C_CR1_PEC;
  }
  else
  {
    /* Disable the selected I2C PEC transmission */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
 80015d4:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80015d8:	041b      	lsls	r3, r3, #16
 80015da:	0c1b      	lsrs	r3, r3, #16
 80015dc:	8003      	strh	r3, [r0, #0]
 80015de:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= I2C_CR1_PEC;
 80015e0:	b29b      	uxth	r3, r3
 80015e2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80015e6:	8003      	strh	r3, [r0, #0]
 80015e8:	4770      	bx	lr
 80015ea:	bf00      	nop

080015ec <I2C_PECPositionConfig>:
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 80015ec:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
 80015f0:	8803      	ldrh	r3, [r0, #0]
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 80015f2:	d005      	beq.n	8001600 <I2C_PECPositionConfig+0x14>
    I2Cx->CR1 |= I2C_PECPosition_Next;
  }
  else
  {
    /* Current byte in shift register is PEC */
    I2Cx->CR1 &= I2C_PECPosition_Current;
 80015f4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80015f8:	041b      	lsls	r3, r3, #16
 80015fa:	0c1b      	lsrs	r3, r3, #16
 80015fc:	8003      	strh	r3, [r0, #0]
 80015fe:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
 8001600:	b29b      	uxth	r3, r3
 8001602:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001606:	8003      	strh	r3, [r0, #0]
 8001608:	4770      	bx	lr
 800160a:	bf00      	nop

0800160c <I2C_CalculatePEC>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= I2C_CR1_ENPEC;
 800160c:	8803      	ldrh	r3, [r0, #0]
void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800160e:	b929      	cbnz	r1, 800161c <I2C_CalculatePEC+0x10>
    I2Cx->CR1 |= I2C_CR1_ENPEC;
  }
  else
  {
    /* Disable the selected I2C PEC calculation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
 8001610:	f023 0320 	bic.w	r3, r3, #32
 8001614:	041b      	lsls	r3, r3, #16
 8001616:	0c1b      	lsrs	r3, r3, #16
 8001618:	8003      	strh	r3, [r0, #0]
 800161a:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= I2C_CR1_ENPEC;
 800161c:	b29b      	uxth	r3, r3
 800161e:	f043 0320 	orr.w	r3, r3, #32
 8001622:	8003      	strh	r3, [r0, #0]
 8001624:	4770      	bx	lr
 8001626:	bf00      	nop

08001628 <I2C_GetPEC>:
uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the selected I2C PEC value */
  return ((I2Cx->SR2) >> 8);
 8001628:	8b00      	ldrh	r0, [r0, #24]
}
 800162a:	f3c0 2007 	ubfx	r0, r0, #8, #8
 800162e:	4770      	bx	lr

08001630 <I2C_DMACmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= I2C_CR2_DMAEN;
 8001630:	8883      	ldrh	r3, [r0, #4]
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001632:	b929      	cbnz	r1, 8001640 <I2C_DMACmd+0x10>
    I2Cx->CR2 |= I2C_CR2_DMAEN;
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
 8001634:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001638:	041b      	lsls	r3, r3, #16
 800163a:	0c1b      	lsrs	r3, r3, #16
 800163c:	8083      	strh	r3, [r0, #4]
 800163e:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= I2C_CR2_DMAEN;
 8001640:	b29b      	uxth	r3, r3
 8001642:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001646:	8083      	strh	r3, [r0, #4]
 8001648:	4770      	bx	lr
 800164a:	bf00      	nop

0800164c <I2C_DMALastTransferCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= I2C_CR2_LAST;
 800164c:	8883      	ldrh	r3, [r0, #4]
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800164e:	b929      	cbnz	r1, 800165c <I2C_DMALastTransferCmd+0x10>
    I2Cx->CR2 |= I2C_CR2_LAST;
  }
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
 8001650:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8001654:	041b      	lsls	r3, r3, #16
 8001656:	0c1b      	lsrs	r3, r3, #16
 8001658:	8083      	strh	r3, [r0, #4]
 800165a:	4770      	bx	lr
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= I2C_CR2_LAST;
 800165c:	b29b      	uxth	r3, r3
 800165e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001662:	8083      	strh	r3, [r0, #4]
 8001664:	4770      	bx	lr
 8001666:	bf00      	nop

08001668 <I2C_ReadRegister>:
  *            @arg I2C_Register_CCR:   CCR register.
  *            @arg I2C_Register_TRISE: TRISE register.
  * @retval The value of the read register.
  */
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 8001668:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 800166a:	2300      	movs	r3, #0
 800166c:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t) I2Cx;
 800166e:	9001      	str	r0, [sp, #4]
  tmp += I2C_Register;
 8001670:	9b01      	ldr	r3, [sp, #4]
 8001672:	4419      	add	r1, r3
 8001674:	9101      	str	r1, [sp, #4]

  /* Return the selected register value */
  return (*(__IO uint16_t *) tmp);
 8001676:	9b01      	ldr	r3, [sp, #4]
 8001678:	8818      	ldrh	r0, [r3, #0]
}
 800167a:	b280      	uxth	r0, r0
 800167c:	b002      	add	sp, #8
 800167e:	4770      	bx	lr

08001680 <I2C_ITConfig>:
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 8001680:	8883      	ldrh	r3, [r0, #4]
 8001682:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8001684:	b91a      	cbnz	r2, 800168e <I2C_ITConfig+0xe>
    I2Cx->CR2 |= I2C_IT;
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8001686:	ea23 0101 	bic.w	r1, r3, r1
 800168a:	8081      	strh	r1, [r0, #4]
 800168c:	4770      	bx	lr
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 800168e:	4319      	orrs	r1, r3
 8001690:	8081      	strh	r1, [r0, #4]
 8001692:	4770      	bx	lr

08001694 <I2C_CheckEvent>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8001694:	8a82      	ldrh	r2, [r0, #20]
  flag2 = I2Cx->SR2;
 8001696:	8b03      	ldrh	r3, [r0, #24]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8001698:	b290      	uxth	r0, r2
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 800169a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 800169e:	f021 437f 	bic.w	r3, r1, #4278190080	; 0xff000000

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
 80016a2:	4018      	ands	r0, r3
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
  }
  /* Return status */
  return status;
}
 80016a4:	1a0b      	subs	r3, r1, r0
 80016a6:	4258      	negs	r0, r3
 80016a8:	4158      	adcs	r0, r3
 80016aa:	4770      	bx	lr

080016ac <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80016ac:	8a82      	ldrh	r2, [r0, #20]
  flag2 = I2Cx->SR2;
 80016ae:	8b03      	ldrh	r3, [r0, #24]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80016b0:	b290      	uxth	r0, r2
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 80016b2:	ea40 4003 	orr.w	r0, r0, r3, lsl #16

  /* Return status */
  return lastevent;
}
 80016b6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80016ba:	4770      	bx	lr

080016bc <I2C_GetFlagStatus>:
  *                                Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 80016bc:	b082      	sub	sp, #8
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 80016be:	2300      	movs	r3, #0

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 80016c0:	0f0a      	lsrs	r2, r1, #28
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 80016c2:	9300      	str	r3, [sp, #0]
 80016c4:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 80016c6:	9001      	str	r0, [sp, #4]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 80016c8:	9200      	str	r2, [sp, #0]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
  
  if(i2creg != 0)
 80016ca:	9b00      	ldr	r3, [sp, #0]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
 80016cc:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  
  if(i2creg != 0)
 80016d0:	b153      	cbz	r3, 80016e8 <I2C_GetFlagStatus+0x2c>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 80016d2:	9b01      	ldr	r3, [sp, #4]
 80016d4:	3314      	adds	r3, #20
 80016d6:	9301      	str	r3, [sp, #4]
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 80016d8:	9b01      	ldr	r3, [sp, #4]
 80016da:	681b      	ldr	r3, [r3, #0]
 80016dc:	4219      	tst	r1, r3
    bitstatus = RESET;
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
}
 80016de:	bf0c      	ite	eq
 80016e0:	2000      	moveq	r0, #0
 80016e2:	2001      	movne	r0, #1
 80016e4:	b002      	add	sp, #8
 80016e6:	4770      	bx	lr
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 80016e8:	9b01      	ldr	r3, [sp, #4]
 80016ea:	3318      	adds	r3, #24
    i2cxbase += 0x14;
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 80016ec:	0c09      	lsrs	r1, r1, #16
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 80016ee:	9301      	str	r3, [sp, #4]
 80016f0:	e7f2      	b.n	80016d8 <I2C_GetFlagStatus+0x1c>
 80016f2:	bf00      	nop

080016f4 <I2C_ClearFlag>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_MASK;
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 80016f4:	43c9      	mvns	r1, r1
 80016f6:	b289      	uxth	r1, r1
 80016f8:	8281      	strh	r1, [r0, #20]
 80016fa:	4770      	bx	lr

080016fc <I2C_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 80016fc:	8883      	ldrh	r3, [r0, #4]
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 80016fe:	8a80      	ldrh	r0, [r0, #20]
 8001700:	b280      	uxth	r0, r0
 8001702:	4008      	ands	r0, r1
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 8001704:	b29b      	uxth	r3, r3
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 8001706:	d006      	beq.n	8001716 <I2C_GetITStatus+0x1a>
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 8001708:	f001 61e0 	and.w	r1, r1, #117440512	; 0x7000000
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 800170c:	ea13 4111 	ands.w	r1, r3, r1, lsr #16
  {
    /* I2C_IT is set */
    bitstatus = SET;
 8001710:	bf0c      	ite	eq
 8001712:	2000      	moveq	r0, #0
 8001714:	2001      	movne	r0, #1
    /* I2C_IT is reset */
    bitstatus = RESET;
  }
  /* Return the I2C_IT status */
  return  bitstatus;
}
 8001716:	4770      	bx	lr

08001718 <I2C_ClearITPendingBit>:

  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_MASK;

  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8001718:	43c9      	mvns	r1, r1
 800171a:	b289      	uxth	r1, r1
 800171c:	8281      	strh	r1, [r0, #20]
 800171e:	4770      	bx	lr

08001720 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001720:	4b0f      	ldr	r3, [pc, #60]	; (8001760 <RCC_DeInit+0x40>)

  /* Reset PLLI2SCFGR register */
  RCC->PLLI2SCFGR = 0x20003000;

  /* Reset PLLSAICFGR register, only available for STM32F42/43xxx devices */
  RCC->PLLSAICFGR = 0x24003000;
 8001722:	4810      	ldr	r0, [pc, #64]	; (8001764 <RCC_DeInit+0x44>)
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001724:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8001726:	2200      	movs	r2, #0
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001728:	f041 0101 	orr.w	r1, r1, #1
  *            - LSI, LSE and RTC clocks 
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
 800172c:	b430      	push	{r4, r5}
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800172e:	6019      	str	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8001730:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42/43xxx devices) bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 8001732:	6819      	ldr	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8001734:	4d0c      	ldr	r5, [pc, #48]	; (8001768 <RCC_DeInit+0x48>)

  /* Reset PLLI2SCFGR register */
  RCC->PLLI2SCFGR = 0x20003000;
 8001736:	4c0d      	ldr	r4, [pc, #52]	; (800176c <RCC_DeInit+0x4c>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42/43xxx devices) bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 8001738:	f021 51a8 	bic.w	r1, r1, #352321536	; 0x15000000
 800173c:	f421 2110 	bic.w	r1, r1, #589824	; 0x90000
 8001740:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8001742:	605d      	str	r5, [r3, #4]

  /* Reset PLLI2SCFGR register */
  RCC->PLLI2SCFGR = 0x20003000;
 8001744:	f8c3 4084 	str.w	r4, [r3, #132]	; 0x84

  /* Reset PLLSAICFGR register, only available for STM32F42/43xxx devices */
  RCC->PLLSAICFGR = 0x24003000;
 8001748:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
 
  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800174c:	6819      	ldr	r1, [r3, #0]
 800174e:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8001752:	6019      	str	r1, [r3, #0]
  RCC->CIR = 0x00000000;

  /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx devices */
  RCC->DCKCFGR = 0x00000000; 

}
 8001754:	bc30      	pop	{r4, r5}
 
  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8001756:	60da      	str	r2, [r3, #12]

  /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx devices */
  RCC->DCKCFGR = 0x00000000; 
 8001758:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

}
 800175c:	4770      	bx	lr
 800175e:	bf00      	nop
 8001760:	40023800 	.word	0x40023800
 8001764:	24003000 	.word	0x24003000
 8001768:	24003010 	.word	0x24003010
 800176c:	20003000 	.word	0x20003000

08001770 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 8001770:	4b02      	ldr	r3, [pc, #8]	; (800177c <RCC_HSEConfig+0xc>)
 8001772:	2200      	movs	r2, #0
 8001774:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 8001776:	7018      	strb	r0, [r3, #0]
 8001778:	4770      	bx	lr
 800177a:	bf00      	nop
 800177c:	40023802 	.word	0x40023802

08001780 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8001780:	b082      	sub	sp, #8
  __IO uint32_t startupcounter = 0;
 8001782:	2300      	movs	r3, #0

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8001784:	4a0b      	ldr	r2, [pc, #44]	; (80017b4 <RCC_WaitForHSEStartUp+0x34>)
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
  __IO uint32_t startupcounter = 0;
 8001786:	9301      	str	r3, [sp, #4]

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8001788:	6813      	ldr	r3, [r2, #0]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800178a:	039b      	lsls	r3, r3, #14
 800178c:	d40c      	bmi.n	80017a8 <RCC_WaitForHSEStartUp+0x28>
  FlagStatus hsestatus = RESET;
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    startupcounter++;
 800178e:	9b01      	ldr	r3, [sp, #4]
 8001790:	3301      	adds	r3, #1
 8001792:	9301      	str	r3, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8001794:	9b01      	ldr	r3, [sp, #4]
 8001796:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
 800179a:	d1f5      	bne.n	8001788 <RCC_WaitForHSEStartUp+0x8>

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 800179c:	4b05      	ldr	r3, [pc, #20]	; (80017b4 <RCC_WaitForHSEStartUp+0x34>)
 800179e:	6818      	ldr	r0, [r3, #0]
  }
  else
  {
    status = ERROR;
  }
  return (status);
 80017a0:	f3c0 4040 	ubfx	r0, r0, #17, #1
}
 80017a4:	b002      	add	sp, #8
 80017a6:	4770      	bx	lr
  FlagStatus hsestatus = RESET;
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    startupcounter++;
 80017a8:	9b01      	ldr	r3, [sp, #4]
 80017aa:	3301      	adds	r3, #1
 80017ac:	9301      	str	r3, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 80017ae:	9b01      	ldr	r3, [sp, #4]
 80017b0:	e7f4      	b.n	800179c <RCC_WaitForHSEStartUp+0x1c>
 80017b2:	bf00      	nop
 80017b4:	40023800 	.word	0x40023800

080017b8 <RCC_AdjustHSICalibrationValue>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 80017b8:	4b03      	ldr	r3, [pc, #12]	; (80017c8 <RCC_AdjustHSICalibrationValue+0x10>)
 80017ba:	681a      	ldr	r2, [r3, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 80017bc:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 80017c0:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 80017c4:	6018      	str	r0, [r3, #0]
 80017c6:	4770      	bx	lr
 80017c8:	40023800 	.word	0x40023800

080017cc <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 80017cc:	4b01      	ldr	r3, [pc, #4]	; (80017d4 <RCC_HSICmd+0x8>)
 80017ce:	6018      	str	r0, [r3, #0]
 80017d0:	4770      	bx	lr
 80017d2:	bf00      	nop
 80017d4:	42470000 	.word	0x42470000

080017d8 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80017d8:	4b06      	ldr	r3, [pc, #24]	; (80017f4 <RCC_LSEConfig+0x1c>)
 80017da:	2200      	movs	r2, #0

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 80017dc:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80017de:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80017e0:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 80017e2:	d005      	beq.n	80017f0 <RCC_LSEConfig+0x18>
 80017e4:	2804      	cmp	r0, #4
 80017e6:	d102      	bne.n	80017ee <RCC_LSEConfig+0x16>
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 80017e8:	2205      	movs	r2, #5
 80017ea:	701a      	strb	r2, [r3, #0]
 80017ec:	4770      	bx	lr
 80017ee:	4770      	bx	lr
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 80017f0:	7018      	strb	r0, [r3, #0]
      break;
 80017f2:	4770      	bx	lr
 80017f4:	40023870 	.word	0x40023870

080017f8 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 80017f8:	4b01      	ldr	r3, [pc, #4]	; (8001800 <RCC_LSICmd+0x8>)
 80017fa:	6018      	str	r0, [r3, #0]
 80017fc:	4770      	bx	lr
 80017fe:	bf00      	nop
 8001800:	42470e80 	.word	0x42470e80

08001804 <RCC_PLLConfig>:
  *         correctly.
  *   
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
{
 8001804:	b430      	push	{r4, r5}
 8001806:	9c02      	ldr	r4, [sp, #8]
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8001808:	4d06      	ldr	r5, [pc, #24]	; (8001824 <RCC_PLLConfig+0x20>)
 800180a:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
 800180e:	085b      	lsrs	r3, r3, #1
 8001810:	4301      	orrs	r1, r0
 8001812:	3b01      	subs	r3, #1
 8001814:	ea41 1282 	orr.w	r2, r1, r2, lsl #6
 8001818:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 800181c:	606b      	str	r3, [r5, #4]
                 (PLLQ << 24);
}
 800181e:	bc30      	pop	{r4, r5}
 8001820:	4770      	bx	lr
 8001822:	bf00      	nop
 8001824:	40023800 	.word	0x40023800

08001828 <RCC_PLLCmd>:
  */
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8001828:	4b01      	ldr	r3, [pc, #4]	; (8001830 <RCC_PLLCmd+0x8>)
 800182a:	6018      	str	r0, [r3, #0]
 800182c:	4770      	bx	lr
 800182e:	bf00      	nop
 8001830:	42470060 	.word	0x42470060

08001834 <RCC_PLLI2SConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 8001834:	0709      	lsls	r1, r1, #28
 8001836:	4b03      	ldr	r3, [pc, #12]	; (8001844 <RCC_PLLI2SConfig+0x10>)
 8001838:	ea41 1080 	orr.w	r0, r1, r0, lsl #6
 800183c:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
 8001840:	4770      	bx	lr
 8001842:	bf00      	nop
 8001844:	40023800 	.word	0x40023800

08001848 <RCC_PLLI2SCmd>:
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 8001848:	4b01      	ldr	r3, [pc, #4]	; (8001850 <RCC_PLLI2SCmd+0x8>)
 800184a:	6018      	str	r0, [r3, #0]
 800184c:	4770      	bx	lr
 800184e:	bf00      	nop
 8001850:	42470068 	.word	0x42470068

08001854 <RCC_PLLSAIConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIN));
  assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIR));

  RCC->PLLSAICFGR = (PLLSAIN << 6) | (PLLSAIQ << 24) | (PLLSAIR << 28);
 8001854:	0712      	lsls	r2, r2, #28
 8001856:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
 800185a:	4b03      	ldr	r3, [pc, #12]	; (8001868 <RCC_PLLSAIConfig+0x14>)
 800185c:	ea41 1080 	orr.w	r0, r1, r0, lsl #6
 8001860:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
 8001864:	4770      	bx	lr
 8001866:	bf00      	nop
 8001868:	40023800 	.word	0x40023800

0800186c <RCC_PLLSAICmd>:
  */
void RCC_PLLSAICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLSAION_BB = (uint32_t)NewState;
 800186c:	4b01      	ldr	r3, [pc, #4]	; (8001874 <RCC_PLLSAICmd+0x8>)
 800186e:	6018      	str	r0, [r3, #0]
 8001870:	4770      	bx	lr
 8001872:	bf00      	nop
 8001874:	42470070 	.word	0x42470070

08001878 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8001878:	4b01      	ldr	r3, [pc, #4]	; (8001880 <RCC_ClockSecuritySystemCmd+0x8>)
 800187a:	6018      	str	r0, [r3, #0]
 800187c:	4770      	bx	lr
 800187e:	bf00      	nop
 8001880:	4247004c 	.word	0x4247004c

08001884 <RCC_MCO1Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 8001884:	4b03      	ldr	r3, [pc, #12]	; (8001894 <RCC_MCO1Config+0x10>)
 8001886:	689a      	ldr	r2, [r3, #8]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 8001888:	f022 62ec 	bic.w	r2, r2, #123731968	; 0x7600000

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 800188c:	4311      	orrs	r1, r2
 800188e:	4308      	orrs	r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8001890:	6098      	str	r0, [r3, #8]
 8001892:	4770      	bx	lr
 8001894:	40023800 	.word	0x40023800

08001898 <RCC_MCO2Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 8001898:	4b03      	ldr	r3, [pc, #12]	; (80018a8 <RCC_MCO2Config+0x10>)
 800189a:	689a      	ldr	r2, [r3, #8]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 800189c:	f022 4278 	bic.w	r2, r2, #4160749568	; 0xf8000000

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 80018a0:	4311      	orrs	r1, r2
 80018a2:	4308      	orrs	r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 80018a4:	6098      	str	r0, [r3, #8]
 80018a6:	4770      	bx	lr
 80018a8:	40023800 	.word	0x40023800

080018ac <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 80018ac:	4b03      	ldr	r3, [pc, #12]	; (80018bc <RCC_SYSCLKConfig+0x10>)
 80018ae:	689a      	ldr	r2, [r3, #8]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 80018b0:	f022 0203 	bic.w	r2, r2, #3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80018b4:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80018b6:	6098      	str	r0, [r3, #8]
 80018b8:	4770      	bx	lr
 80018ba:	bf00      	nop
 80018bc:	40023800 	.word	0x40023800

080018c0 <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 80018c0:	4b02      	ldr	r3, [pc, #8]	; (80018cc <RCC_GetSYSCLKSource+0xc>)
 80018c2:	6898      	ldr	r0, [r3, #8]
}
 80018c4:	f000 000c 	and.w	r0, r0, #12
 80018c8:	4770      	bx	lr
 80018ca:	bf00      	nop
 80018cc:	40023800 	.word	0x40023800

080018d0 <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 80018d0:	4b03      	ldr	r3, [pc, #12]	; (80018e0 <RCC_HCLKConfig+0x10>)
 80018d2:	689a      	ldr	r2, [r3, #8]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 80018d4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 80018d8:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80018da:	6098      	str	r0, [r3, #8]
 80018dc:	4770      	bx	lr
 80018de:	bf00      	nop
 80018e0:	40023800 	.word	0x40023800

080018e4 <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 80018e4:	4b03      	ldr	r3, [pc, #12]	; (80018f4 <RCC_PCLK1Config+0x10>)
 80018e6:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 80018e8:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80018ec:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80018ee:	6098      	str	r0, [r3, #8]
 80018f0:	4770      	bx	lr
 80018f2:	bf00      	nop
 80018f4:	40023800 	.word	0x40023800

080018f8 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 80018f8:	4b03      	ldr	r3, [pc, #12]	; (8001908 <RCC_PCLK2Config+0x10>)
 80018fa:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 80018fc:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8001900:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001904:	6098      	str	r0, [r3, #8]
 8001906:	4770      	bx	lr
 8001908:	40023800 	.word	0x40023800

0800190c <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800190c:	4a1f      	ldr	r2, [pc, #124]	; (800198c <RCC_GetClocksFreq+0x80>)
 800190e:	6893      	ldr	r3, [r2, #8]
 8001910:	f003 030c 	and.w	r3, r3, #12

  switch (tmp)
 8001914:	2b04      	cmp	r3, #4
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8001916:	b410      	push	{r4}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;

  switch (tmp)
 8001918:	d01b      	beq.n	8001952 <RCC_GetClocksFreq+0x46>
 800191a:	2b08      	cmp	r3, #8
 800191c:	d01c      	beq.n	8001958 <RCC_GetClocksFreq+0x4c>

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
      break;
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 800191e:	4b1c      	ldr	r3, [pc, #112]	; (8001990 <RCC_GetClocksFreq+0x84>)
 8001920:	6003      	str	r3, [r0, #0]
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8001922:	491a      	ldr	r1, [pc, #104]	; (800198c <RCC_GetClocksFreq+0x80>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8001924:	4a1b      	ldr	r2, [pc, #108]	; (8001994 <RCC_GetClocksFreq+0x88>)
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8001926:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 4;
 8001928:	f3c4 1403 	ubfx	r4, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 800192c:	5d14      	ldrb	r4, [r2, r4]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800192e:	40e3      	lsrs	r3, r4
 8001930:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8001932:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 10;
 8001934:	f3c4 2482 	ubfx	r4, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 8001938:	5d14      	ldrb	r4, [r2, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800193a:	fa23 f404 	lsr.w	r4, r3, r4
 800193e:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8001940:	6889      	ldr	r1, [r1, #8]
  tmp = tmp >> 13;
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
}
 8001942:	f85d 4b04 	ldr.w	r4, [sp], #4
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
  tmp = tmp >> 13;
 8001946:	f3c1 3142 	ubfx	r1, r1, #13, #3
  presc = APBAHBPrescTable[tmp];
 800194a:	5c52      	ldrb	r2, [r2, r1]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800194c:	40d3      	lsrs	r3, r2
 800194e:	60c3      	str	r3, [r0, #12]
}
 8001950:	4770      	bx	lr
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8001952:	4b11      	ldr	r3, [pc, #68]	; (8001998 <RCC_GetClocksFreq+0x8c>)
 8001954:	6003      	str	r3, [r0, #0]
      break;
 8001956:	e7e4      	b.n	8001922 <RCC_GetClocksFreq+0x16>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8001958:	6854      	ldr	r4, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800195a:	6851      	ldr	r1, [r2, #4]
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800195c:	6852      	ldr	r2, [r2, #4]
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
 800195e:	0263      	lsls	r3, r4, #9
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8001960:	bf4c      	ite	mi
 8001962:	4b0d      	ldrmi	r3, [pc, #52]	; (8001998 <RCC_GetClocksFreq+0x8c>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8001964:	4b0a      	ldrpl	r3, [pc, #40]	; (8001990 <RCC_GetClocksFreq+0x84>)

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001966:	f001 013f 	and.w	r1, r1, #63	; 0x3f
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800196a:	f3c2 1288 	ubfx	r2, r2, #6, #9
 800196e:	fbb3 f3f1 	udiv	r3, r3, r1
 8001972:	fb03 f302 	mul.w	r3, r3, r2
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8001976:	4a05      	ldr	r2, [pc, #20]	; (800198c <RCC_GetClocksFreq+0x80>)
 8001978:	6852      	ldr	r2, [r2, #4]
 800197a:	f3c2 4201 	ubfx	r2, r2, #16, #2
 800197e:	3201      	adds	r2, #1
 8001980:	0052      	lsls	r2, r2, #1
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8001982:	fbb3 f3f2 	udiv	r3, r3, r2
 8001986:	6003      	str	r3, [r0, #0]
      break;
 8001988:	e7cb      	b.n	8001922 <RCC_GetClocksFreq+0x16>
 800198a:	bf00      	nop
 800198c:	40023800 	.word	0x40023800
 8001990:	00f42400 	.word	0x00f42400
 8001994:	20000000 	.word	0x20000000
 8001998:	017d7840 	.word	0x017d7840

0800199c <RCC_RTCCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 800199c:	f400 7340 	and.w	r3, r0, #768	; 0x300
 80019a0:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80019a4:	d109      	bne.n	80019ba <RCC_RTCCLKConfig+0x1e>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 80019a6:	4a08      	ldr	r2, [pc, #32]	; (80019c8 <RCC_RTCCLKConfig+0x2c>)
 80019a8:	6891      	ldr	r1, [r2, #8]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 80019aa:	f020 4370 	bic.w	r3, r0, #4026531840	; 0xf0000000
  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 80019ae:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 80019b2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80019b6:	430b      	orrs	r3, r1

    /* Store the new value */
    RCC->CFGR = tmpreg;
 80019b8:	6093      	str	r3, [r2, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 80019ba:	4b03      	ldr	r3, [pc, #12]	; (80019c8 <RCC_RTCCLKConfig+0x2c>)
 80019bc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80019be:	f3c0 000b 	ubfx	r0, r0, #0, #12
 80019c2:	4310      	orrs	r0, r2
 80019c4:	6718      	str	r0, [r3, #112]	; 0x70
 80019c6:	4770      	bx	lr
 80019c8:	40023800 	.word	0x40023800

080019cc <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 80019cc:	4b01      	ldr	r3, [pc, #4]	; (80019d4 <RCC_RTCCLKCmd+0x8>)
 80019ce:	6018      	str	r0, [r3, #0]
 80019d0:	4770      	bx	lr
 80019d2:	bf00      	nop
 80019d4:	42470e3c 	.word	0x42470e3c

080019d8 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80019d8:	4b01      	ldr	r3, [pc, #4]	; (80019e0 <RCC_BackupResetCmd+0x8>)
 80019da:	6018      	str	r0, [r3, #0]
 80019dc:	4770      	bx	lr
 80019de:	bf00      	nop
 80019e0:	42470e40 	.word	0x42470e40

080019e4 <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 80019e4:	4b01      	ldr	r3, [pc, #4]	; (80019ec <RCC_I2SCLKConfig+0x8>)
 80019e6:	6018      	str	r0, [r3, #0]
 80019e8:	4770      	bx	lr
 80019ea:	bf00      	nop
 80019ec:	4247015c 	.word	0x4247015c

080019f0 <RCC_SAIPLLI2SClkDivConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
  
  tmpreg = RCC->DCKCFGR;
 80019f0:	4b04      	ldr	r3, [pc, #16]	; (8001a04 <RCC_SAIPLLI2SClkDivConfig+0x14>)
 80019f2:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c

  /* Clear PLLI2SDIVQ[4:0] bits */
  tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);

  /* Set PLLI2SDIVQ values */
  tmpreg |= (RCC_PLLI2SDivQ - 1);
 80019f6:	3801      	subs	r0, #1
  assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
  
  tmpreg = RCC->DCKCFGR;

  /* Clear PLLI2SDIVQ[4:0] bits */
  tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);
 80019f8:	f022 021f 	bic.w	r2, r2, #31

  /* Set PLLI2SDIVQ values */
  tmpreg |= (RCC_PLLI2SDivQ - 1);
 80019fc:	4302      	orrs	r2, r0

  /* Store the new value */
  RCC->DCKCFGR = tmpreg;
 80019fe:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 8001a02:	4770      	bx	lr
 8001a04:	40023800 	.word	0x40023800

08001a08 <RCC_SAIPLLSAIClkDivConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
  
  tmpreg = RCC->DCKCFGR;
 8001a08:	4b05      	ldr	r3, [pc, #20]	; (8001a20 <RCC_SAIPLLSAIClkDivConfig+0x18>)
 8001a0a:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c

  /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
  tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);

  /* Set PLLSAIDIVQ values */
  tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
 8001a0e:	3801      	subs	r0, #1
  assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
  
  tmpreg = RCC->DCKCFGR;

  /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
  tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);
 8001a10:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00

  /* Set PLLSAIDIVQ values */
  tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
 8001a14:	ea42 2200 	orr.w	r2, r2, r0, lsl #8

  /* Store the new value */
  RCC->DCKCFGR = tmpreg;
 8001a18:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 8001a1c:	4770      	bx	lr
 8001a1e:	bf00      	nop
 8001a20:	40023800 	.word	0x40023800

08001a24 <RCC_SAIBlockACLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_SAIACLK_SOURCE(RCC_SAIBlockACLKSource));
  
  tmpreg = RCC->DCKCFGR;
 8001a24:	4b04      	ldr	r3, [pc, #16]	; (8001a38 <RCC_SAIBlockACLKConfig+0x14>)
 8001a26:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c

  /* Clear RCC_DCKCFGR_SAI1ASRC[1:0] bits */
  tmpreg &= ~RCC_DCKCFGR_SAI1ASRC;
 8001a2a:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000

  /* Set SAI Block A source selection value */
  tmpreg |= RCC_SAIBlockACLKSource;
 8001a2e:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->DCKCFGR = tmpreg;
 8001a30:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
 8001a34:	4770      	bx	lr
 8001a36:	bf00      	nop
 8001a38:	40023800 	.word	0x40023800

08001a3c <RCC_SAIBlockBCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_SAIBCLK_SOURCE(RCC_SAIBlockBCLKSource));
  
  tmpreg = RCC->DCKCFGR;
 8001a3c:	4b04      	ldr	r3, [pc, #16]	; (8001a50 <RCC_SAIBlockBCLKConfig+0x14>)
 8001a3e:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c

  /* Clear RCC_DCKCFGR_SAI1BSRC[1:0] bits */
  tmpreg &= ~RCC_DCKCFGR_SAI1BSRC;
 8001a42:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000

  /* Set SAI Block B source selection value */
  tmpreg |= RCC_SAIBlockBCLKSource;
 8001a46:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->DCKCFGR = tmpreg;
 8001a48:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
 8001a4c:	4770      	bx	lr
 8001a4e:	bf00      	nop
 8001a50:	40023800 	.word	0x40023800

08001a54 <RCC_LTDCCLKDivConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PLLSAI_DIVR_VALUE(RCC_PLLSAIDivR));
  
  tmpreg = RCC->DCKCFGR;
 8001a54:	4b04      	ldr	r3, [pc, #16]	; (8001a68 <RCC_LTDCCLKDivConfig+0x14>)
 8001a56:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c

  /* Clear PLLSAIDIVR[2:0] bits */
  tmpreg &= ~RCC_DCKCFGR_PLLSAIDIVR;
 8001a5a:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000

  /* Set PLLSAIDIVR values */
  tmpreg |= RCC_PLLSAIDivR;
 8001a5e:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->DCKCFGR = tmpreg;
 8001a60:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
 8001a64:	4770      	bx	lr
 8001a66:	bf00      	nop
 8001a68:	40023800 	.word	0x40023800

08001a6c <RCC_TIMCLKPresConfig>:
void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
{
  /* Check the parameters */
  assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));

  *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
 8001a6c:	4b01      	ldr	r3, [pc, #4]	; (8001a74 <RCC_TIMCLKPresConfig+0x8>)
 8001a6e:	6018      	str	r0, [r3, #0]
 8001a70:	4770      	bx	lr
 8001a72:	bf00      	nop
 8001a74:	424711e0 	.word	0x424711e0

08001a78 <RCC_AHB1PeriphClockCmd>:
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8001a78:	4b04      	ldr	r3, [pc, #16]	; (8001a8c <RCC_AHB1PeriphClockCmd+0x14>)
 8001a7a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001a7c:	b919      	cbnz	r1, 8001a86 <RCC_AHB1PeriphClockCmd+0xe>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8001a7e:	ea22 0000 	bic.w	r0, r2, r0
 8001a82:	6318      	str	r0, [r3, #48]	; 0x30
 8001a84:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8001a86:	4310      	orrs	r0, r2
 8001a88:	6318      	str	r0, [r3, #48]	; 0x30
 8001a8a:	4770      	bx	lr
 8001a8c:	40023800 	.word	0x40023800

08001a90 <RCC_AHB2PeriphClockCmd>:
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 8001a90:	4b04      	ldr	r3, [pc, #16]	; (8001aa4 <RCC_AHB2PeriphClockCmd+0x14>)
 8001a92:	6b5a      	ldr	r2, [r3, #52]	; 0x34
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001a94:	b919      	cbnz	r1, 8001a9e <RCC_AHB2PeriphClockCmd+0xe>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 8001a96:	ea22 0000 	bic.w	r0, r2, r0
 8001a9a:	6358      	str	r0, [r3, #52]	; 0x34
 8001a9c:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 8001a9e:	4310      	orrs	r0, r2
 8001aa0:	6358      	str	r0, [r3, #52]	; 0x34
 8001aa2:	4770      	bx	lr
 8001aa4:	40023800 	.word	0x40023800

08001aa8 <RCC_AHB3PeriphClockCmd>:
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 8001aa8:	4b04      	ldr	r3, [pc, #16]	; (8001abc <RCC_AHB3PeriphClockCmd+0x14>)
 8001aaa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001aac:	b919      	cbnz	r1, 8001ab6 <RCC_AHB3PeriphClockCmd+0xe>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 8001aae:	ea22 0000 	bic.w	r0, r2, r0
 8001ab2:	6398      	str	r0, [r3, #56]	; 0x38
 8001ab4:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 8001ab6:	4310      	orrs	r0, r2
 8001ab8:	6398      	str	r0, [r3, #56]	; 0x38
 8001aba:	4770      	bx	lr
 8001abc:	40023800 	.word	0x40023800

08001ac0 <RCC_APB1PeriphClockCmd>:
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8001ac0:	4b04      	ldr	r3, [pc, #16]	; (8001ad4 <RCC_APB1PeriphClockCmd+0x14>)
 8001ac2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001ac4:	b919      	cbnz	r1, 8001ace <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8001ac6:	ea22 0000 	bic.w	r0, r2, r0
 8001aca:	6418      	str	r0, [r3, #64]	; 0x40
 8001acc:	4770      	bx	lr
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8001ace:	4310      	orrs	r0, r2
 8001ad0:	6418      	str	r0, [r3, #64]	; 0x40
 8001ad2:	4770      	bx	lr
 8001ad4:	40023800 	.word	0x40023800

08001ad8 <RCC_APB2PeriphClockCmd>:
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8001ad8:	4b04      	ldr	r3, [pc, #16]	; (8001aec <RCC_APB2PeriphClockCmd+0x14>)
 8001ada:	6c5a      	ldr	r2, [r3, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001adc:	b919      	cbnz	r1, 8001ae6 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8001ade:	ea22 0000 	bic.w	r0, r2, r0
 8001ae2:	6458      	str	r0, [r3, #68]	; 0x44
 8001ae4:	4770      	bx	lr
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8001ae6:	4310      	orrs	r0, r2
 8001ae8:	6458      	str	r0, [r3, #68]	; 0x44
 8001aea:	4770      	bx	lr
 8001aec:	40023800 	.word	0x40023800

08001af0 <RCC_AHB1PeriphResetCmd>:
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 8001af0:	4b04      	ldr	r3, [pc, #16]	; (8001b04 <RCC_AHB1PeriphResetCmd+0x14>)
 8001af2:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001af4:	b919      	cbnz	r1, 8001afe <RCC_AHB1PeriphResetCmd+0xe>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 8001af6:	ea22 0000 	bic.w	r0, r2, r0
 8001afa:	6118      	str	r0, [r3, #16]
 8001afc:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 8001afe:	4310      	orrs	r0, r2
 8001b00:	6118      	str	r0, [r3, #16]
 8001b02:	4770      	bx	lr
 8001b04:	40023800 	.word	0x40023800

08001b08 <RCC_AHB2PeriphResetCmd>:
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 8001b08:	4b04      	ldr	r3, [pc, #16]	; (8001b1c <RCC_AHB2PeriphResetCmd+0x14>)
 8001b0a:	695a      	ldr	r2, [r3, #20]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001b0c:	b919      	cbnz	r1, 8001b16 <RCC_AHB2PeriphResetCmd+0xe>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 8001b0e:	ea22 0000 	bic.w	r0, r2, r0
 8001b12:	6158      	str	r0, [r3, #20]
 8001b14:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 8001b16:	4310      	orrs	r0, r2
 8001b18:	6158      	str	r0, [r3, #20]
 8001b1a:	4770      	bx	lr
 8001b1c:	40023800 	.word	0x40023800

08001b20 <RCC_AHB3PeriphResetCmd>:
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 8001b20:	4b04      	ldr	r3, [pc, #16]	; (8001b34 <RCC_AHB3PeriphResetCmd+0x14>)
 8001b22:	699a      	ldr	r2, [r3, #24]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001b24:	b919      	cbnz	r1, 8001b2e <RCC_AHB3PeriphResetCmd+0xe>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 8001b26:	ea22 0000 	bic.w	r0, r2, r0
 8001b2a:	6198      	str	r0, [r3, #24]
 8001b2c:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 8001b2e:	4310      	orrs	r0, r2
 8001b30:	6198      	str	r0, [r3, #24]
 8001b32:	4770      	bx	lr
 8001b34:	40023800 	.word	0x40023800

08001b38 <RCC_APB1PeriphResetCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8001b38:	4b04      	ldr	r3, [pc, #16]	; (8001b4c <RCC_APB1PeriphResetCmd+0x14>)
 8001b3a:	6a1a      	ldr	r2, [r3, #32]
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001b3c:	b919      	cbnz	r1, 8001b46 <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8001b3e:	ea22 0000 	bic.w	r0, r2, r0
 8001b42:	6218      	str	r0, [r3, #32]
 8001b44:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8001b46:	4310      	orrs	r0, r2
 8001b48:	6218      	str	r0, [r3, #32]
 8001b4a:	4770      	bx	lr
 8001b4c:	40023800 	.word	0x40023800

08001b50 <RCC_APB2PeriphResetCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8001b50:	4b04      	ldr	r3, [pc, #16]	; (8001b64 <RCC_APB2PeriphResetCmd+0x14>)
 8001b52:	6a5a      	ldr	r2, [r3, #36]	; 0x24
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001b54:	b919      	cbnz	r1, 8001b5e <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8001b56:	ea22 0000 	bic.w	r0, r2, r0
 8001b5a:	6258      	str	r0, [r3, #36]	; 0x24
 8001b5c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8001b5e:	4310      	orrs	r0, r2
 8001b60:	6258      	str	r0, [r3, #36]	; 0x24
 8001b62:	4770      	bx	lr
 8001b64:	40023800 	.word	0x40023800

08001b68 <RCC_AHB1PeriphClockLPModeCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 8001b68:	4b04      	ldr	r3, [pc, #16]	; (8001b7c <RCC_AHB1PeriphClockLPModeCmd+0x14>)
 8001b6a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001b6c:	b919      	cbnz	r1, 8001b76 <RCC_AHB1PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 8001b6e:	ea22 0000 	bic.w	r0, r2, r0
 8001b72:	6518      	str	r0, [r3, #80]	; 0x50
 8001b74:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 8001b76:	4310      	orrs	r0, r2
 8001b78:	6518      	str	r0, [r3, #80]	; 0x50
 8001b7a:	4770      	bx	lr
 8001b7c:	40023800 	.word	0x40023800

08001b80 <RCC_AHB2PeriphClockLPModeCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 8001b80:	4b04      	ldr	r3, [pc, #16]	; (8001b94 <RCC_AHB2PeriphClockLPModeCmd+0x14>)
 8001b82:	6d5a      	ldr	r2, [r3, #84]	; 0x54
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001b84:	b919      	cbnz	r1, 8001b8e <RCC_AHB2PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 8001b86:	ea22 0000 	bic.w	r0, r2, r0
 8001b8a:	6558      	str	r0, [r3, #84]	; 0x54
 8001b8c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 8001b8e:	4310      	orrs	r0, r2
 8001b90:	6558      	str	r0, [r3, #84]	; 0x54
 8001b92:	4770      	bx	lr
 8001b94:	40023800 	.word	0x40023800

08001b98 <RCC_AHB3PeriphClockLPModeCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 8001b98:	4b04      	ldr	r3, [pc, #16]	; (8001bac <RCC_AHB3PeriphClockLPModeCmd+0x14>)
 8001b9a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001b9c:	b919      	cbnz	r1, 8001ba6 <RCC_AHB3PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 8001b9e:	ea22 0000 	bic.w	r0, r2, r0
 8001ba2:	6598      	str	r0, [r3, #88]	; 0x58
 8001ba4:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 8001ba6:	4310      	orrs	r0, r2
 8001ba8:	6598      	str	r0, [r3, #88]	; 0x58
 8001baa:	4770      	bx	lr
 8001bac:	40023800 	.word	0x40023800

08001bb0 <RCC_APB1PeriphClockLPModeCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 8001bb0:	4b04      	ldr	r3, [pc, #16]	; (8001bc4 <RCC_APB1PeriphClockLPModeCmd+0x14>)
 8001bb2:	6e1a      	ldr	r2, [r3, #96]	; 0x60
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001bb4:	b919      	cbnz	r1, 8001bbe <RCC_APB1PeriphClockLPModeCmd+0xe>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 8001bb6:	ea22 0000 	bic.w	r0, r2, r0
 8001bba:	6618      	str	r0, [r3, #96]	; 0x60
 8001bbc:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 8001bbe:	4310      	orrs	r0, r2
 8001bc0:	6618      	str	r0, [r3, #96]	; 0x60
 8001bc2:	4770      	bx	lr
 8001bc4:	40023800 	.word	0x40023800

08001bc8 <RCC_APB2PeriphClockLPModeCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 8001bc8:	4b04      	ldr	r3, [pc, #16]	; (8001bdc <RCC_APB2PeriphClockLPModeCmd+0x14>)
 8001bca:	6e5a      	ldr	r2, [r3, #100]	; 0x64
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001bcc:	b919      	cbnz	r1, 8001bd6 <RCC_APB2PeriphClockLPModeCmd+0xe>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 8001bce:	ea22 0000 	bic.w	r0, r2, r0
 8001bd2:	6658      	str	r0, [r3, #100]	; 0x64
 8001bd4:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 8001bd6:	4310      	orrs	r0, r2
 8001bd8:	6658      	str	r0, [r3, #100]	; 0x64
 8001bda:	4770      	bx	lr
 8001bdc:	40023800 	.word	0x40023800

08001be0 <RCC_ITConfig>:
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8001be0:	4b04      	ldr	r3, [pc, #16]	; (8001bf4 <RCC_ITConfig+0x14>)
 8001be2:	781a      	ldrb	r2, [r3, #0]
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001be4:	b919      	cbnz	r1, 8001bee <RCC_ITConfig+0xe>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8001be6:	ea22 0000 	bic.w	r0, r2, r0
 8001bea:	7018      	strb	r0, [r3, #0]
 8001bec:	4770      	bx	lr
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8001bee:	4310      	orrs	r0, r2
 8001bf0:	7018      	strb	r0, [r3, #0]
 8001bf2:	4770      	bx	lr
 8001bf4:	4002380d 	.word	0x4002380d

08001bf8 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8001bf8:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 8001bfa:	2b01      	cmp	r3, #1
 8001bfc:	d00b      	beq.n	8001c16 <RCC_GetFlagStatus+0x1e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8001bfe:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 8001c00:	4b09      	ldr	r3, [pc, #36]	; (8001c28 <RCC_GetFlagStatus+0x30>)
 8001c02:	bf0c      	ite	eq
 8001c04:	6f1b      	ldreq	r3, [r3, #112]	; 0x70
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8001c06:	6f5b      	ldrne	r3, [r3, #116]	; 0x74
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8001c08:	f000 001f 	and.w	r0, r0, #31
 8001c0c:	fa23 f000 	lsr.w	r0, r3, r0
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 8001c10:	f000 0001 	and.w	r0, r0, #1
 8001c14:	4770      	bx	lr

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8001c16:	4b04      	ldr	r3, [pc, #16]	; (8001c28 <RCC_GetFlagStatus+0x30>)
 8001c18:	681b      	ldr	r3, [r3, #0]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8001c1a:	f000 001f 	and.w	r0, r0, #31
 8001c1e:	fa23 f000 	lsr.w	r0, r3, r0
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 8001c22:	f000 0001 	and.w	r0, r0, #1
 8001c26:	4770      	bx	lr
 8001c28:	40023800 	.word	0x40023800

08001c2c <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 8001c2c:	4b02      	ldr	r3, [pc, #8]	; (8001c38 <RCC_ClearFlag+0xc>)
 8001c2e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8001c30:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001c34:	675a      	str	r2, [r3, #116]	; 0x74
 8001c36:	4770      	bx	lr
 8001c38:	40023800 	.word	0x40023800

08001c3c <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8001c3c:	4b03      	ldr	r3, [pc, #12]	; (8001c4c <RCC_GetITStatus+0x10>)
 8001c3e:	68db      	ldr	r3, [r3, #12]
 8001c40:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 8001c42:	bf0c      	ite	eq
 8001c44:	2000      	moveq	r0, #0
 8001c46:	2001      	movne	r0, #1
 8001c48:	4770      	bx	lr
 8001c4a:	bf00      	nop
 8001c4c:	40023800 	.word	0x40023800

08001c50 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 8001c50:	4b01      	ldr	r3, [pc, #4]	; (8001c58 <RCC_ClearITPendingBit+0x8>)
 8001c52:	7018      	strb	r0, [r3, #0]
 8001c54:	4770      	bx	lr
 8001c56:	bf00      	nop
 8001c58:	4002380e 	.word	0x4002380e

08001c5c <SPI_I2S_DeInit>:
  *         is managed by the I2S peripheral clock).
  *             
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 8001c5c:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 8001c5e:	4b2d      	ldr	r3, [pc, #180]	; (8001d14 <SPI_I2S_DeInit+0xb8>)
 8001c60:	4298      	cmp	r0, r3
 8001c62:	d01b      	beq.n	8001c9c <SPI_I2S_DeInit+0x40>
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
  }
  else if (SPIx == SPI2)
 8001c64:	4b2c      	ldr	r3, [pc, #176]	; (8001d18 <SPI_I2S_DeInit+0xbc>)
 8001c66:	4298      	cmp	r0, r3
 8001c68:	d024      	beq.n	8001cb4 <SPI_I2S_DeInit+0x58>
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
  }
  else if (SPIx == SPI3)
 8001c6a:	4b2c      	ldr	r3, [pc, #176]	; (8001d1c <SPI_I2S_DeInit+0xc0>)
 8001c6c:	4298      	cmp	r0, r3
 8001c6e:	d02d      	beq.n	8001ccc <SPI_I2S_DeInit+0x70>
    /* Enable SPI3 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
    /* Release SPI3 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
  }
  else if (SPIx == SPI4)
 8001c70:	4b2b      	ldr	r3, [pc, #172]	; (8001d20 <SPI_I2S_DeInit+0xc4>)
 8001c72:	4298      	cmp	r0, r3
 8001c74:	d036      	beq.n	8001ce4 <SPI_I2S_DeInit+0x88>
    /* Enable SPI4 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
    /* Release SPI4 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
  }
  else if (SPIx == SPI5)
 8001c76:	4b2b      	ldr	r3, [pc, #172]	; (8001d24 <SPI_I2S_DeInit+0xc8>)
 8001c78:	4298      	cmp	r0, r3
 8001c7a:	d03f      	beq.n	8001cfc <SPI_I2S_DeInit+0xa0>
    /* Release SPI5 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
  }
  else 
  {
    if (SPIx == SPI6)
 8001c7c:	4b2a      	ldr	r3, [pc, #168]	; (8001d28 <SPI_I2S_DeInit+0xcc>)
 8001c7e:	4298      	cmp	r0, r3
 8001c80:	d000      	beq.n	8001c84 <SPI_I2S_DeInit+0x28>
 8001c82:	bd08      	pop	{r3, pc}
    {
      /* Enable SPI6 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
 8001c84:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8001c88:	2101      	movs	r1, #1
 8001c8a:	f7ff ff61 	bl	8001b50 <RCC_APB2PeriphResetCmd>
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
 8001c8e:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8001c92:	2100      	movs	r1, #0
    }
  }
}
 8001c94:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (SPIx == SPI6)
    {
      /* Enable SPI6 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
 8001c98:	f7ff bf5a 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 8001c9c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001ca0:	2101      	movs	r1, #1
 8001ca2:	f7ff ff55 	bl	8001b50 <RCC_APB2PeriphResetCmd>
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 8001ca6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001caa:	2100      	movs	r1, #0
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
    }
  }
}
 8001cac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (SPIx == SPI1)
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 8001cb0:	f7ff bf4e 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
  }
  else if (SPIx == SPI2)
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 8001cb4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001cb8:	2101      	movs	r1, #1
 8001cba:	f7ff ff3d 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 8001cbe:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001cc2:	2100      	movs	r1, #0
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
    }
  }
}
 8001cc4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else if (SPIx == SPI2)
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 8001cc8:	f7ff bf36 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }
  else if (SPIx == SPI3)
  {
    /* Enable SPI3 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 8001ccc:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8001cd0:	2101      	movs	r1, #1
 8001cd2:	f7ff ff31 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    /* Release SPI3 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 8001cd6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8001cda:	2100      	movs	r1, #0
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
    }
  }
}
 8001cdc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else if (SPIx == SPI3)
  {
    /* Enable SPI3 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
    /* Release SPI3 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 8001ce0:	f7ff bf2a 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }
  else if (SPIx == SPI4)
  {
    /* Enable SPI4 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
 8001ce4:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001ce8:	2101      	movs	r1, #1
 8001cea:	f7ff ff31 	bl	8001b50 <RCC_APB2PeriphResetCmd>
    /* Release SPI4 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
 8001cee:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001cf2:	2100      	movs	r1, #0
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
    }
  }
}
 8001cf4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else if (SPIx == SPI4)
  {
    /* Enable SPI4 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
    /* Release SPI4 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
 8001cf8:	f7ff bf2a 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
  }
  else if (SPIx == SPI5)
  {
    /* Enable SPI5 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, ENABLE);
 8001cfc:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8001d00:	2101      	movs	r1, #1
 8001d02:	f7ff ff25 	bl	8001b50 <RCC_APB2PeriphResetCmd>
    /* Release SPI5 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
 8001d06:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8001d0a:	2100      	movs	r1, #0
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
    }
  }
}
 8001d0c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else if (SPIx == SPI5)
  {
    /* Enable SPI5 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, ENABLE);
    /* Release SPI5 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
 8001d10:	f7ff bf1e 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
 8001d14:	40013000 	.word	0x40013000
 8001d18:	40003800 	.word	0x40003800
 8001d1c:	40003c00 	.word	0x40003c00
 8001d20:	40013400 	.word	0x40013400
 8001d24:	40015000 	.word	0x40015000
 8001d28:	40015400 	.word	0x40015400

08001d2c <SPI_Init>:
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 8001d2c:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8001d30:	f8b1 a002 	ldrh.w	sl, [r1, #2]
 8001d34:	f8b1 9000 	ldrh.w	r9, [r1]
 8001d38:	f8b1 8004 	ldrh.w	r8, [r1, #4]
 8001d3c:	890f      	ldrh	r7, [r1, #8]
 8001d3e:	894e      	ldrh	r6, [r1, #10]
 8001d40:	898d      	ldrh	r5, [r1, #12]
 8001d42:	89cc      	ldrh	r4, [r1, #14]
 8001d44:	f8b1 c006 	ldrh.w	ip, [r1, #6]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8001d48:	8a0a      	ldrh	r2, [r1, #16]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 8001d4a:	8803      	ldrh	r3, [r0, #0]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8001d4c:	ea4a 0109 	orr.w	r1, sl, r9
 8001d50:	ea41 0108 	orr.w	r1, r1, r8
 8001d54:	ea41 010c 	orr.w	r1, r1, ip
 8001d58:	4339      	orrs	r1, r7
 8001d5a:	4331      	orrs	r1, r6
 8001d5c:	4329      	orrs	r1, r5
 8001d5e:	4321      	orrs	r1, r4

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
 8001d60:	f403 5341 	and.w	r3, r3, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8001d64:	430b      	orrs	r3, r1
 8001d66:	b29b      	uxth	r3, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8001d68:	8003      	strh	r3, [r0, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 8001d6a:	8b83      	ldrh	r3, [r0, #28]
 8001d6c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001d70:	041b      	lsls	r3, r3, #16
 8001d72:	0c1b      	lsrs	r3, r3, #16
 8001d74:	8383      	strh	r3, [r0, #28]
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
}
 8001d76:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8001d7a:	8202      	strh	r2, [r0, #16]
}
 8001d7c:	4770      	bx	lr
 8001d7e:	bf00      	nop

08001d80 <I2S_Init>:
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001d80:	8b83      	ldrh	r3, [r0, #28]
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8001d82:	688a      	ldr	r2, [r1, #8]
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001d84:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 8001d88:	f023 030f 	bic.w	r3, r3, #15
 8001d8c:	041b      	lsls	r3, r3, #16
  *         to the value of the the source clock frequency (in Hz).
  *  
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 8001d8e:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001d92:	0c1b      	lsrs	r3, r3, #16
  SPIx->I2SPR = 0x0002;
 8001d94:	2402      	movs	r4, #2
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001d96:	8383      	strh	r3, [r0, #28]
  SPIx->I2SPR = 0x0002;
 8001d98:	8404      	strh	r4, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 8001d9a:	f8b0 c01c 	ldrh.w	ip, [r0, #28]
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8001d9e:	42a2      	cmp	r2, r4
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  SPIx->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 8001da0:	fa1f fc8c 	uxth.w	ip, ip
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8001da4:	d052      	beq.n	8001e4c <I2S_Init+0xcc>
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 8001da6:	4b2b      	ldr	r3, [pc, #172]	; (8001e54 <I2S_Init+0xd4>)
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) *******************/
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 8001da8:	888c      	ldrh	r4, [r1, #4]
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 8001daa:	689d      	ldr	r5, [r3, #8]
      packetlength = 1;
    }
    else
    {
      /* Packet length is 32 bits */
      packetlength = 2;
 8001dac:	2c00      	cmp	r4, #0
 8001dae:	bf0c      	ite	eq
 8001db0:	f04f 0801 	moveq.w	r8, #1
 8001db4:	f04f 0802 	movne.w	r8, #2
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 8001db8:	022d      	lsls	r5, r5, #8
 8001dba:	d442      	bmi.n	8001e42 <I2S_Init+0xc2>
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 8001dbc:	4b25      	ldr	r3, [pc, #148]	; (8001e54 <I2S_Init+0xd4>)
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      

    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 8001dbe:	f8df 909c 	ldr.w	r9, [pc, #156]	; 8001e5c <I2S_Init+0xdc>
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 8001dc2:	f8d3 5084 	ldr.w	r5, [r3, #132]	; 0x84
                      (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
 8001dc6:	f8d3 6084 	ldr.w	r6, [r3, #132]	; 0x84
                      (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
 8001dca:	685f      	ldr	r7, [r3, #4]
    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
  #endif /* I2S_EXTERNAL_CLOCK_VAL */
    
    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8001dcc:	88cb      	ldrh	r3, [r1, #6]
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
                      (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
 8001dce:	f007 073f 	and.w	r7, r7, #63	; 0x3f
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 8001dd2:	f3c5 1588 	ubfx	r5, r5, #6, #9
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      

    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 8001dd6:	fbb9 f7f7 	udiv	r7, r9, r7
  #endif /* I2S_EXTERNAL_CLOCK_VAL */
    
    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8001dda:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
                      (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
 8001dde:	f3c6 7602 	ubfx	r6, r6, #28, #3
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      

    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 8001de2:	fb05 f507 	mul.w	r5, r5, r7
 8001de6:	fbb5 f5f6 	udiv	r5, r5, r6
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8001dea:	bf16      	itet	ne
 8001dec:	ea4f 1848 	movne.w	r8, r8, lsl #5
    
    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8001df0:	0a2d      	lsreq	r5, r5, #8
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8001df2:	fbb5 f5f8 	udivne	r5, r5, r8
 8001df6:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8001dfa:	006d      	lsls	r5, r5, #1
 8001dfc:	fbb5 f2f2 	udiv	r2, r5, r2
 8001e00:	3205      	adds	r2, #5
    }
    
    /* Remove the flatting point */
    tmp = tmp / 10;  
 8001e02:	4d15      	ldr	r5, [pc, #84]	; (8001e58 <I2S_Init+0xd8>)
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8001e04:	b292      	uxth	r2, r2
    }
    
    /* Remove the flatting point */
    tmp = tmp / 10;  
 8001e06:	fba5 6202 	umull	r6, r2, r5, r2
 8001e0a:	08d2      	lsrs	r2, r2, #3
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 8001e0c:	0855      	lsrs	r5, r2, #1
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 8001e0e:	1eae      	subs	r6, r5, #2
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 8001e10:	f002 0201 	and.w	r2, r2, #1
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 8001e14:	2efd      	cmp	r6, #253	; 0xfd
 8001e16:	bf94      	ite	ls
 8001e18:	ea45 2202 	orrls.w	r2, r5, r2, lsl #8
 8001e1c:	2202      	movhi	r2, #2
  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8001e1e:	880f      	ldrh	r7, [r1, #0]

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8001e20:	884e      	ldrh	r6, [r1, #2]
 8001e22:	898d      	ldrh	r5, [r1, #12]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8001e24:	ea4c 0107 	orr.w	r1, ip, r7
 8001e28:	f441 6100 	orr.w	r1, r1, #2048	; 0x800

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8001e2c:	4331      	orrs	r1, r6
 8001e2e:	4329      	orrs	r1, r5
    i2sdiv = 2;
    i2sodd = 0;
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 8001e30:	4313      	orrs	r3, r2
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8001e32:	b289      	uxth	r1, r1
 8001e34:	430c      	orrs	r4, r1
    i2sdiv = 2;
    i2sodd = 0;
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 8001e36:	b29b      	uxth	r3, r3
 8001e38:	8403      	strh	r3, [r0, #32]
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  SPIx->I2SCFGR = tmpreg;
 8001e3a:	8384      	strh	r4, [r0, #28]
}
 8001e3c:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8001e40:	4770      	bx	lr

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
 8001e42:	689d      	ldr	r5, [r3, #8]
 8001e44:	f425 0500 	bic.w	r5, r5, #8388608	; 0x800000
 8001e48:	609d      	str	r5, [r3, #8]
 8001e4a:	e7b7      	b.n	8001dbc <I2S_Init+0x3c>
 8001e4c:	888c      	ldrh	r4, [r1, #4]
 8001e4e:	88cb      	ldrh	r3, [r1, #6]
 8001e50:	e7e5      	b.n	8001e1e <I2S_Init+0x9e>
 8001e52:	bf00      	nop
 8001e54:	40023800 	.word	0x40023800
 8001e58:	cccccccd 	.word	0xcccccccd
 8001e5c:	017d7840 	.word	0x017d7840

08001e60 <SPI_StructInit>:
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8001e60:	2300      	movs	r3, #0
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 8001e62:	2207      	movs	r2, #7
 8001e64:	8202      	strh	r2, [r0, #16]
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8001e66:	8003      	strh	r3, [r0, #0]
  /* initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 8001e68:	8043      	strh	r3, [r0, #2]
  /* initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 8001e6a:	8083      	strh	r3, [r0, #4]
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 8001e6c:	80c3      	strh	r3, [r0, #6]
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 8001e6e:	8103      	strh	r3, [r0, #8]
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 8001e70:	8143      	strh	r3, [r0, #10]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 8001e72:	8183      	strh	r3, [r0, #12]
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 8001e74:	81c3      	strh	r3, [r0, #14]
 8001e76:	4770      	bx	lr

08001e78 <I2S_StructInit>:
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8001e78:	2300      	movs	r3, #0
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 8001e7a:	2202      	movs	r2, #2
 8001e7c:	6082      	str	r2, [r0, #8]
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8001e7e:	8003      	strh	r3, [r0, #0]
  
  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 8001e80:	8043      	strh	r3, [r0, #2]
  
  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 8001e82:	8083      	strh	r3, [r0, #4]
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 8001e84:	80c3      	strh	r3, [r0, #6]
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
  
  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 8001e86:	8183      	strh	r3, [r0, #12]
 8001e88:	4770      	bx	lr
 8001e8a:	bf00      	nop

08001e8c <SPI_Cmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 8001e8c:	8803      	ldrh	r3, [r0, #0]
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001e8e:	b929      	cbnz	r1, 8001e9c <SPI_Cmd+0x10>
    SPIx->CR1 |= SPI_CR1_SPE;
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 8001e90:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001e94:	041b      	lsls	r3, r3, #16
 8001e96:	0c1b      	lsrs	r3, r3, #16
 8001e98:	8003      	strh	r3, [r0, #0]
 8001e9a:	4770      	bx	lr
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 8001e9c:	b29b      	uxth	r3, r3
 8001e9e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001ea2:	8003      	strh	r3, [r0, #0]
 8001ea4:	4770      	bx	lr
 8001ea6:	bf00      	nop

08001ea8 <I2S_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8001ea8:	8b83      	ldrh	r3, [r0, #28]
{
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8001eaa:	b929      	cbnz	r1, 8001eb8 <I2S_Cmd+0x10>
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
  }
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 8001eac:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001eb0:	041b      	lsls	r3, r3, #16
 8001eb2:	0c1b      	lsrs	r3, r3, #16
 8001eb4:	8383      	strh	r3, [r0, #28]
 8001eb6:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8001eb8:	b29b      	uxth	r3, r3
 8001eba:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001ebe:	8383      	strh	r3, [r0, #28]
 8001ec0:	4770      	bx	lr
 8001ec2:	bf00      	nop

08001ec4 <SPI_DataSizeConfig>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
  /* Clear DFF bit */
  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
 8001ec4:	8803      	ldrh	r3, [r0, #0]
 8001ec6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001eca:	041b      	lsls	r3, r3, #16
 8001ecc:	0c1b      	lsrs	r3, r3, #16
 8001ece:	8003      	strh	r3, [r0, #0]
  /* Set new DFF bit value */
  SPIx->CR1 |= SPI_DataSize;
 8001ed0:	8803      	ldrh	r3, [r0, #0]
 8001ed2:	b29b      	uxth	r3, r3
 8001ed4:	4319      	orrs	r1, r3
 8001ed6:	8001      	strh	r1, [r0, #0]
 8001ed8:	4770      	bx	lr
 8001eda:	bf00      	nop

08001edc <SPI_BiDirectionalLineConfig>:
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8001edc:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8001ee0:	8803      	ldrh	r3, [r0, #0]
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8001ee2:	d005      	beq.n	8001ef0 <SPI_BiDirectionalLineConfig+0x14>
    SPIx->CR1 |= SPI_Direction_Tx;
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
 8001ee4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001ee8:	041b      	lsls	r3, r3, #16
 8001eea:	0c1b      	lsrs	r3, r3, #16
 8001eec:	8003      	strh	r3, [r0, #0]
 8001eee:	4770      	bx	lr
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8001ef0:	b29b      	uxth	r3, r3
 8001ef2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001ef6:	8003      	strh	r3, [r0, #0]
 8001ef8:	4770      	bx	lr
 8001efa:	bf00      	nop

08001efc <SPI_NSSInternalSoftwareConfig>:
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8001efc:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 8001f00:	4299      	cmp	r1, r3
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8001f02:	8803      	ldrh	r3, [r0, #0]
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8001f04:	d004      	beq.n	8001f10 <SPI_NSSInternalSoftwareConfig+0x14>
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8001f06:	b29b      	uxth	r3, r3
 8001f08:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001f0c:	8003      	strh	r3, [r0, #0]
 8001f0e:	4770      	bx	lr
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 8001f10:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001f14:	041b      	lsls	r3, r3, #16
 8001f16:	0c1b      	lsrs	r3, r3, #16
 8001f18:	8003      	strh	r3, [r0, #0]
 8001f1a:	4770      	bx	lr

08001f1c <SPI_SSOutputCmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 8001f1c:	8883      	ldrh	r3, [r0, #4]
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001f1e:	b929      	cbnz	r1, 8001f2c <SPI_SSOutputCmd+0x10>
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 8001f20:	f023 0304 	bic.w	r3, r3, #4
 8001f24:	041b      	lsls	r3, r3, #16
 8001f26:	0c1b      	lsrs	r3, r3, #16
 8001f28:	8083      	strh	r3, [r0, #4]
 8001f2a:	4770      	bx	lr
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 8001f2c:	b29b      	uxth	r3, r3
 8001f2e:	f043 0304 	orr.w	r3, r3, #4
 8001f32:	8083      	strh	r3, [r0, #4]
 8001f34:	4770      	bx	lr
 8001f36:	bf00      	nop

08001f38 <SPI_TIModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 8001f38:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001f3a:	b929      	cbnz	r1, 8001f48 <SPI_TIModeCmd+0x10>
    SPIx->CR2 |= SPI_CR2_FRF;
  }
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
 8001f3c:	f023 0310 	bic.w	r3, r3, #16
 8001f40:	041b      	lsls	r3, r3, #16
 8001f42:	0c1b      	lsrs	r3, r3, #16
 8001f44:	8083      	strh	r3, [r0, #4]
 8001f46:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 8001f48:	b29b      	uxth	r3, r3
 8001f4a:	f043 0310 	orr.w	r3, r3, #16
 8001f4e:	8083      	strh	r3, [r0, #4]
 8001f50:	4770      	bx	lr
 8001f52:	bf00      	nop

08001f54 <I2S_FullDuplexConfig>:
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001f54:	8b83      	ldrh	r3, [r0, #28]
 8001f56:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 8001f5a:	f023 030f 	bic.w	r3, r3, #15
 8001f5e:	041b      	lsls	r3, r3, #16
  I2Sxext->I2SPR = 0x0002;
 8001f60:	2202      	movs	r2, #2
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001f62:	0c1b      	lsrs	r3, r3, #16
 8001f64:	8383      	strh	r3, [r0, #28]
  I2Sxext->I2SPR = 0x0002;
 8001f66:	8402      	strh	r2, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 8001f68:	8b83      	ldrh	r3, [r0, #28]
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8001f6a:	880a      	ldrh	r2, [r1, #0]
  * @note   The I2S full duplex extension can be configured in slave mode only.    
  *  
  * @retval None
  */
void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
{
 8001f6c:	b430      	push	{r4, r5}
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8001f6e:	884d      	ldrh	r5, [r1, #2]
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8001f70:	888c      	ldrh	r4, [r1, #4]
 8001f72:	8989      	ldrh	r1, [r1, #12]
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  I2Sxext->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 8001f74:	b29b      	uxth	r3, r3
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8001f76:	432b      	orrs	r3, r5
 8001f78:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8001f7c:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8001f80:	4323      	orrs	r3, r4
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8001f82:	b292      	uxth	r2, r2
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8001f84:	430b      	orrs	r3, r1
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8001f86:	2a00      	cmp	r2, #0
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8001f88:	b29b      	uxth	r3, r3
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
  {
    tmp = I2S_Mode_SlaveRx;
 8001f8a:	bf14      	ite	ne
 8001f8c:	2200      	movne	r2, #0
 8001f8e:	f44f 7280 	moveq.w	r2, #256	; 0x100
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8001f92:	4313      	orrs	r3, r2
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
 8001f94:	8383      	strh	r3, [r0, #28]
}
 8001f96:	bc30      	pop	{r4, r5}
 8001f98:	4770      	bx	lr
 8001f9a:	bf00      	nop

08001f9c <SPI_I2S_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Return the data in the DR register */
  return SPIx->DR;
 8001f9c:	8980      	ldrh	r0, [r0, #12]
}
 8001f9e:	b280      	uxth	r0, r0
 8001fa0:	4770      	bx	lr
 8001fa2:	bf00      	nop

08001fa4 <SPI_I2S_SendData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
 8001fa4:	8181      	strh	r1, [r0, #12]
 8001fa6:	4770      	bx	lr

08001fa8 <SPI_CalculateCRC>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 8001fa8:	8803      	ldrh	r3, [r0, #0]
void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001faa:	b929      	cbnz	r1, 8001fb8 <SPI_CalculateCRC+0x10>
    SPIx->CR1 |= SPI_CR1_CRCEN;
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 8001fac:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001fb0:	041b      	lsls	r3, r3, #16
 8001fb2:	0c1b      	lsrs	r3, r3, #16
 8001fb4:	8003      	strh	r3, [r0, #0]
 8001fb6:	4770      	bx	lr
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 8001fb8:	b29b      	uxth	r3, r3
 8001fba:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001fbe:	8003      	strh	r3, [r0, #0]
 8001fc0:	4770      	bx	lr
 8001fc2:	bf00      	nop

08001fc4 <SPI_TransmitCRC>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
 8001fc4:	8803      	ldrh	r3, [r0, #0]
 8001fc6:	b29b      	uxth	r3, r3
 8001fc8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001fcc:	8003      	strh	r3, [r0, #0]
 8001fce:	4770      	bx	lr

08001fd0 <SPI_GetCRC>:
{
  uint16_t crcreg = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));
  if (SPI_CRC != SPI_CRC_Rx)
 8001fd0:	2901      	cmp	r1, #1
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 8001fd2:	bf14      	ite	ne
 8001fd4:	8b00      	ldrhne	r0, [r0, #24]
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 8001fd6:	8a80      	ldrheq	r0, [r0, #20]
 8001fd8:	b280      	uxth	r0, r0
  }
  /* Return the selected CRC register */
  return crcreg;
}
 8001fda:	4770      	bx	lr

08001fdc <SPI_GetCRCPolynomial>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 8001fdc:	8a00      	ldrh	r0, [r0, #16]
}
 8001fde:	b280      	uxth	r0, r0
 8001fe0:	4770      	bx	lr
 8001fe2:	bf00      	nop

08001fe4 <SPI_I2S_DMACmd>:
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8001fe4:	8883      	ldrh	r3, [r0, #4]
 8001fe6:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
 8001fe8:	b91a      	cbnz	r2, 8001ff2 <SPI_I2S_DMACmd+0xe>
    SPIx->CR2 |= SPI_I2S_DMAReq;
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8001fea:	ea23 0101 	bic.w	r1, r3, r1
 8001fee:	8081      	strh	r1, [r0, #4]
 8001ff0:	4770      	bx	lr
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8001ff2:	4319      	orrs	r1, r3
 8001ff4:	8081      	strh	r1, [r0, #4]
 8001ff6:	4770      	bx	lr

08001ff8 <SPI_I2S_ITConfig>:

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 8001ff8:	2301      	movs	r3, #1
 8001ffa:	0909      	lsrs	r1, r1, #4
 8001ffc:	fa03 f101 	lsl.w	r1, r3, r1

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 8002000:	8883      	ldrh	r3, [r0, #4]

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 8002002:	b289      	uxth	r1, r1

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 8002004:	b29b      	uxth	r3, r3
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;

  if (NewState != DISABLE)
 8002006:	b91a      	cbnz	r2, 8002010 <SPI_I2S_ITConfig+0x18>
    SPIx->CR2 |= itmask;
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 8002008:	ea23 0101 	bic.w	r1, r3, r1
 800200c:	8081      	strh	r1, [r0, #4]
 800200e:	4770      	bx	lr
  itmask = (uint16_t)1 << (uint16_t)itpos;

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 8002010:	4319      	orrs	r1, r3
 8002012:	8081      	strh	r1, [r0, #4]
 8002014:	4770      	bx	lr
 8002016:	bf00      	nop

08002018 <SPI_I2S_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 8002018:	8903      	ldrh	r3, [r0, #8]
 800201a:	4219      	tst	r1, r3
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}
 800201c:	bf0c      	ite	eq
 800201e:	2000      	moveq	r0, #0
 8002020:	2001      	movne	r0, #1
 8002022:	4770      	bx	lr

08002024 <SPI_I2S_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    
  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 8002024:	43c9      	mvns	r1, r1
 8002026:	b289      	uxth	r1, r1
 8002028:	8101      	strh	r1, [r0, #8]
 800202a:	4770      	bx	lr

0800202c <SPI_I2S_GetITStatus>:
  *            @arg I2S_IT_UDR: Underrun interrupt.  
  *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 800202c:	b410      	push	{r4}

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 800202e:	8884      	ldrh	r4, [r0, #4]

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8002030:	8900      	ldrh	r0, [r0, #8]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8002032:	f001 030f 	and.w	r3, r1, #15
 8002036:	2201      	movs	r2, #1

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8002038:	b280      	uxth	r0, r0
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 800203a:	fa02 f303 	lsl.w	r3, r2, r3

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 800203e:	4018      	ands	r0, r3

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8002040:	b2a4      	uxth	r4, r4

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8002042:	d005      	beq.n	8002050 <SPI_I2S_GetITStatus+0x24>

  /* Get the SPI_I2S_IT IT mask */
  itmask = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = 0x01 << itmask;
 8002044:	0909      	lsrs	r1, r1, #4
 8002046:	408a      	lsls	r2, r1

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8002048:	4214      	tst	r4, r2
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
 800204a:	bf0c      	ite	eq
 800204c:	2000      	moveq	r0, #0
 800204e:	2001      	movne	r0, #1
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}
 8002050:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002054:	4770      	bx	lr
 8002056:	bf00      	nop

08002058 <SPI_I2S_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));

  /* Get the SPI_I2S IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8002058:	f001 010f 	and.w	r1, r1, #15
 800205c:	2301      	movs	r3, #1
 800205e:	fa03 f101 	lsl.w	r1, r3, r1

  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
  SPIx->SR = (uint16_t)~itpos;
 8002062:	43c9      	mvns	r1, r1
 8002064:	b289      	uxth	r1, r1
 8002066:	8101      	strh	r1, [r0, #8]
 8002068:	4770      	bx	lr
 800206a:	bf00      	nop

0800206c <SYSCFG_DeInit>:
  *   registers to their default reset values.
  * @param  None
  * @retval None
  */
void SYSCFG_DeInit(void)
{
 800206c:	b508      	push	{r3, lr}
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800206e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8002072:	2101      	movs	r1, #1
 8002074:	f7ff fd6c 	bl	8001b50 <RCC_APB2PeriphResetCmd>
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
 8002078:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800207c:	2100      	movs	r1, #0
}
 800207e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void SYSCFG_DeInit(void)
{
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
 8002082:	f7ff bd65 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
 8002086:	bf00      	nop

08002088 <SYSCFG_MemoryRemapConfig>:
void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));

  SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
 8002088:	4b01      	ldr	r3, [pc, #4]	; (8002090 <SYSCFG_MemoryRemapConfig+0x8>)
 800208a:	6018      	str	r0, [r3, #0]
 800208c:	4770      	bx	lr
 800208e:	bf00      	nop
 8002090:	40013800 	.word	0x40013800

08002094 <SYSCFG_MemorySwappingBank>:
void SYSCFG_MemorySwappingBank(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) UFB_MODE_BB = (uint32_t)NewState;
 8002094:	4b01      	ldr	r3, [pc, #4]	; (800209c <SYSCFG_MemorySwappingBank+0x8>)
 8002096:	6018      	str	r0, [r3, #0]
 8002098:	4770      	bx	lr
 800209a:	bf00      	nop
 800209c:	42270020 	.word	0x42270020

080020a0 <SYSCFG_EXTILineConfig>:
  *           be (0..7) for STM32F42xxx/43xxx devices. 
  *             
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 80020a0:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 80020a4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80020a8:	f503 339c 	add.w	r3, r3, #79872	; 0x13800

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 80020ac:	f001 0103 	and.w	r1, r1, #3
  *           be (0..7) for STM32F42xxx/43xxx devices. 
  *             
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 80020b0:	b410      	push	{r4}

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 80020b2:	0089      	lsls	r1, r1, #2
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 80020b4:	689c      	ldr	r4, [r3, #8]

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 80020b6:	220f      	movs	r2, #15
 80020b8:	408a      	lsls	r2, r1
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 80020ba:	ea24 0202 	bic.w	r2, r4, r2
 80020be:	609a      	str	r2, [r3, #8]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 80020c0:	689a      	ldr	r2, [r3, #8]
}
 80020c2:	f85d 4b04 	ldr.w	r4, [sp], #4
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 80020c6:	4088      	lsls	r0, r1
 80020c8:	4302      	orrs	r2, r0
 80020ca:	609a      	str	r2, [r3, #8]
}
 80020cc:	4770      	bx	lr
 80020ce:	bf00      	nop

080020d0 <SYSCFG_ETH_MediaInterfaceConfig>:
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
 80020d0:	4b01      	ldr	r3, [pc, #4]	; (80020d8 <SYSCFG_ETH_MediaInterfaceConfig+0x8>)
 80020d2:	6018      	str	r0, [r3, #0]
 80020d4:	4770      	bx	lr
 80020d6:	bf00      	nop
 80020d8:	422700dc 	.word	0x422700dc

080020dc <SYSCFG_CompensationCellCmd>:
void SYSCFG_CompensationCellCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CMPCR_CMP_PD_BB = (uint32_t)NewState;
 80020dc:	4b01      	ldr	r3, [pc, #4]	; (80020e4 <SYSCFG_CompensationCellCmd+0x8>)
 80020de:	6018      	str	r0, [r3, #0]
 80020e0:	4770      	bx	lr
 80020e2:	bf00      	nop
 80020e4:	42270400 	.word	0x42270400

080020e8 <SYSCFG_GetCompensationCellStatus>:
  */
FlagStatus SYSCFG_GetCompensationCellStatus(void)
{
  FlagStatus bitstatus = RESET;
    
  if ((SYSCFG->CMPCR & SYSCFG_CMPCR_READY ) != (uint32_t)RESET)
 80020e8:	4b02      	ldr	r3, [pc, #8]	; (80020f4 <SYSCFG_GetCompensationCellStatus+0xc>)
 80020ea:	6a18      	ldr	r0, [r3, #32]
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80020ec:	f3c0 2000 	ubfx	r0, r0, #8, #1
 80020f0:	4770      	bx	lr
 80020f2:	bf00      	nop
 80020f4:	40013800 	.word	0x40013800

080020f8 <TIM_DeInit>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval None

  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 80020f8:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
 80020fa:	4b60      	ldr	r3, [pc, #384]	; (800227c <TIM_DeInit+0x184>)
 80020fc:	4298      	cmp	r0, r3
 80020fe:	d035      	beq.n	800216c <TIM_DeInit+0x74>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
  } 
  else if (TIMx == TIM2) 
 8002100:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8002104:	d03c      	beq.n	8002180 <TIM_DeInit+0x88>
  {     
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
  }  
  else if (TIMx == TIM3)
 8002106:	4b5e      	ldr	r3, [pc, #376]	; (8002280 <TIM_DeInit+0x188>)
 8002108:	4298      	cmp	r0, r3
 800210a:	d043      	beq.n	8002194 <TIM_DeInit+0x9c>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
  }  
  else if (TIMx == TIM4)
 800210c:	4b5d      	ldr	r3, [pc, #372]	; (8002284 <TIM_DeInit+0x18c>)
 800210e:	4298      	cmp	r0, r3
 8002110:	d04a      	beq.n	80021a8 <TIM_DeInit+0xb0>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
  }  
  else if (TIMx == TIM5)
 8002112:	4b5d      	ldr	r3, [pc, #372]	; (8002288 <TIM_DeInit+0x190>)
 8002114:	4298      	cmp	r0, r3
 8002116:	d051      	beq.n	80021bc <TIM_DeInit+0xc4>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
  }  
  else if (TIMx == TIM6)  
 8002118:	4b5c      	ldr	r3, [pc, #368]	; (800228c <TIM_DeInit+0x194>)
 800211a:	4298      	cmp	r0, r3
 800211c:	d058      	beq.n	80021d0 <TIM_DeInit+0xd8>
  {    
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
  }  
  else if (TIMx == TIM7)
 800211e:	4b5c      	ldr	r3, [pc, #368]	; (8002290 <TIM_DeInit+0x198>)
 8002120:	4298      	cmp	r0, r3
 8002122:	d05f      	beq.n	80021e4 <TIM_DeInit+0xec>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
  }  
  else if (TIMx == TIM8)
 8002124:	4b5b      	ldr	r3, [pc, #364]	; (8002294 <TIM_DeInit+0x19c>)
 8002126:	4298      	cmp	r0, r3
 8002128:	d066      	beq.n	80021f8 <TIM_DeInit+0x100>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
  }  
  else if (TIMx == TIM9)
 800212a:	4b5b      	ldr	r3, [pc, #364]	; (8002298 <TIM_DeInit+0x1a0>)
 800212c:	4298      	cmp	r0, r3
 800212e:	d06d      	beq.n	800220c <TIM_DeInit+0x114>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
   }  
  else if (TIMx == TIM10)
 8002130:	4b5a      	ldr	r3, [pc, #360]	; (800229c <TIM_DeInit+0x1a4>)
 8002132:	4298      	cmp	r0, r3
 8002134:	d076      	beq.n	8002224 <TIM_DeInit+0x12c>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
  }  
  else if (TIMx == TIM11) 
 8002136:	4b5a      	ldr	r3, [pc, #360]	; (80022a0 <TIM_DeInit+0x1a8>)
 8002138:	4298      	cmp	r0, r3
 800213a:	d07f      	beq.n	800223c <TIM_DeInit+0x144>
  {     
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
  }  
  else if (TIMx == TIM12)
 800213c:	4b59      	ldr	r3, [pc, #356]	; (80022a4 <TIM_DeInit+0x1ac>)
 800213e:	4298      	cmp	r0, r3
 8002140:	f000 8088 	beq.w	8002254 <TIM_DeInit+0x15c>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
  }  
  else if (TIMx == TIM13) 
 8002144:	4b58      	ldr	r3, [pc, #352]	; (80022a8 <TIM_DeInit+0x1b0>)
 8002146:	4298      	cmp	r0, r3
 8002148:	f000 808e 	beq.w	8002268 <TIM_DeInit+0x170>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
  }  
  else
  { 
    if (TIMx == TIM14) 
 800214c:	4b57      	ldr	r3, [pc, #348]	; (80022ac <TIM_DeInit+0x1b4>)
 800214e:	4298      	cmp	r0, r3
 8002150:	d000      	beq.n	8002154 <TIM_DeInit+0x5c>
 8002152:	bd08      	pop	{r3, pc}
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
 8002154:	f44f 7080 	mov.w	r0, #256	; 0x100
 8002158:	2101      	movs	r1, #1
 800215a:	f7ff fced 	bl	8001b38 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
 800215e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8002162:	2100      	movs	r1, #0
    }   
  }
}
 8002164:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  { 
    if (TIMx == TIM14) 
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
 8002168:	f7ff bce6 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 800216c:	2001      	movs	r0, #1
 800216e:	4601      	mov	r1, r0
 8002170:	f7ff fcee 	bl	8001b50 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 8002174:	2001      	movs	r0, #1
 8002176:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 8002178:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 800217c:	f7ff bce8 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
  } 
  else if (TIMx == TIM2) 
  {     
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 8002180:	2001      	movs	r0, #1
 8002182:	4601      	mov	r1, r0
 8002184:	f7ff fcd8 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 8002188:	2001      	movs	r0, #1
 800218a:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 800218c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
  } 
  else if (TIMx == TIM2) 
  {     
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 8002190:	f7ff bcd2 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM3)
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 8002194:	2002      	movs	r0, #2
 8002196:	2101      	movs	r1, #1
 8002198:	f7ff fcce 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 800219c:	2002      	movs	r0, #2
 800219e:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 80021a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
  }  
  else if (TIMx == TIM3)
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 80021a4:	f7ff bcc8 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM4)
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 80021a8:	2004      	movs	r0, #4
 80021aa:	2101      	movs	r1, #1
 80021ac:	f7ff fcc4 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 80021b0:	2004      	movs	r0, #4
 80021b2:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 80021b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
  }  
  else if (TIMx == TIM4)
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 80021b8:	f7ff bcbe 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM5)
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
 80021bc:	2008      	movs	r0, #8
 80021be:	2101      	movs	r1, #1
 80021c0:	f7ff fcba 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
 80021c4:	2008      	movs	r0, #8
 80021c6:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 80021c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
  }  
  else if (TIMx == TIM5)
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
 80021cc:	f7ff bcb4 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM6)  
  {    
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 80021d0:	2010      	movs	r0, #16
 80021d2:	2101      	movs	r1, #1
 80021d4:	f7ff fcb0 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 80021d8:	2010      	movs	r0, #16
 80021da:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 80021dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
  }  
  else if (TIMx == TIM6)  
  {    
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 80021e0:	f7ff bcaa 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM7)
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 80021e4:	2020      	movs	r0, #32
 80021e6:	2101      	movs	r1, #1
 80021e8:	f7ff fca6 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 80021ec:	2020      	movs	r0, #32
 80021ee:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 80021f0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
  }  
  else if (TIMx == TIM7)
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 80021f4:	f7ff bca0 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM8)
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 80021f8:	2002      	movs	r0, #2
 80021fa:	2101      	movs	r1, #1
 80021fc:	f7ff fca8 	bl	8001b50 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 8002200:	2002      	movs	r0, #2
 8002202:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 8002204:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
  }  
  else if (TIMx == TIM8)
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 8002208:	f7ff bca2 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
  }  
  else if (TIMx == TIM9)
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
 800220c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8002210:	2101      	movs	r1, #1
 8002212:	f7ff fc9d 	bl	8001b50 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
 8002216:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800221a:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 800221c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
  }  
  else if (TIMx == TIM9)
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
 8002220:	f7ff bc96 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
   }  
  else if (TIMx == TIM10)
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
 8002224:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8002228:	2101      	movs	r1, #1
 800222a:	f7ff fc91 	bl	8001b50 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
 800222e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8002232:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 8002234:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
   }  
  else if (TIMx == TIM10)
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
 8002238:	f7ff bc8a 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
  }  
  else if (TIMx == TIM11) 
  {     
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
 800223c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8002240:	2101      	movs	r1, #1
 8002242:	f7ff fc85 	bl	8001b50 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
 8002246:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800224a:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 800224c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
  }  
  else if (TIMx == TIM11) 
  {     
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
 8002250:	f7ff bc7e 	b.w	8001b50 <RCC_APB2PeriphResetCmd>
  }  
  else if (TIMx == TIM12)
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
 8002254:	2040      	movs	r0, #64	; 0x40
 8002256:	2101      	movs	r1, #1
 8002258:	f7ff fc6e 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
 800225c:	2040      	movs	r0, #64	; 0x40
 800225e:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 8002260:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
  }  
  else if (TIMx == TIM12)
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
 8002264:	f7ff bc68 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM13) 
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
 8002268:	2080      	movs	r0, #128	; 0x80
 800226a:	2101      	movs	r1, #1
 800226c:	f7ff fc64 	bl	8001b38 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
 8002270:	2080      	movs	r0, #128	; 0x80
 8002272:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 8002274:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
  }  
  else if (TIMx == TIM13) 
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
 8002278:	f7ff bc5e 	b.w	8001b38 <RCC_APB1PeriphResetCmd>
 800227c:	40010000 	.word	0x40010000
 8002280:	40000400 	.word	0x40000400
 8002284:	40000800 	.word	0x40000800
 8002288:	40000c00 	.word	0x40000c00
 800228c:	40001000 	.word	0x40001000
 8002290:	40001400 	.word	0x40001400
 8002294:	40010400 	.word	0x40010400
 8002298:	40014000 	.word	0x40014000
 800229c:	40014400 	.word	0x40014400
 80022a0:	40014800 	.word	0x40014800
 80022a4:	40001800 	.word	0x40001800
 80022a8:	40001c00 	.word	0x40001c00
 80022ac:	40002000 	.word	0x40002000

080022b0 <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)||
 80022b0:	4a23      	ldr	r2, [pc, #140]	; (8002340 <TIM_TimeBaseInit+0x90>)
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80022b2:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)||
 80022b4:	4290      	cmp	r0, r2
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 80022b6:	b470      	push	{r4, r5, r6}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80022b8:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)||
 80022ba:	d012      	beq.n	80022e2 <TIM_TimeBaseInit+0x32>
 80022bc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80022c0:	4290      	cmp	r0, r2
 80022c2:	d00e      	beq.n	80022e2 <TIM_TimeBaseInit+0x32>
 80022c4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80022c8:	d00b      	beq.n	80022e2 <TIM_TimeBaseInit+0x32>
     (TIMx == TIM2) || (TIMx == TIM3)||
 80022ca:	f5a2 3280 	sub.w	r2, r2, #65536	; 0x10000
 80022ce:	4290      	cmp	r0, r2
 80022d0:	d007      	beq.n	80022e2 <TIM_TimeBaseInit+0x32>
 80022d2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80022d6:	4290      	cmp	r0, r2
 80022d8:	d003      	beq.n	80022e2 <TIM_TimeBaseInit+0x32>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 80022da:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80022de:	4290      	cmp	r0, r2
 80022e0:	d103      	bne.n	80022ea <TIM_TimeBaseInit+0x3a>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 80022e2:	884a      	ldrh	r2, [r1, #2]
  if((TIMx == TIM1) || (TIMx == TIM8)||
     (TIMx == TIM2) || (TIMx == TIM3)||
     (TIMx == TIM4) || (TIMx == TIM5)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 80022e4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 80022e8:	4313      	orrs	r3, r2
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 80022ea:	4a16      	ldr	r2, [pc, #88]	; (8002344 <TIM_TimeBaseInit+0x94>)
 80022ec:	4290      	cmp	r0, r2
 80022ee:	d01e      	beq.n	800232e <TIM_TimeBaseInit+0x7e>
 80022f0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80022f4:	4290      	cmp	r0, r2
 80022f6:	d01a      	beq.n	800232e <TIM_TimeBaseInit+0x7e>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 80022f8:	890e      	ldrh	r6, [r1, #8]
  }

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 80022fa:	684d      	ldr	r5, [r1, #4]
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 80022fc:	880c      	ldrh	r4, [r1, #0]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 80022fe:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 8002302:	f502 426c 	add.w	r2, r2, #60416	; 0xec00
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8002306:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8002308:	4333      	orrs	r3, r6
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 800230a:	4290      	cmp	r0, r2
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
  }

  TIMx->CR1 = tmpcr1;
 800230c:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 800230e:	62c5      	str	r5, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8002310:	8504      	strh	r4, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 8002312:	d006      	beq.n	8002322 <TIM_TimeBaseInit+0x72>
 8002314:	4b0c      	ldr	r3, [pc, #48]	; (8002348 <TIM_TimeBaseInit+0x98>)
 8002316:	4298      	cmp	r0, r3
 8002318:	d003      	beq.n	8002322 <TIM_TimeBaseInit+0x72>
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 800231a:	2301      	movs	r3, #1
 800231c:	8283      	strh	r3, [r0, #20]
}
 800231e:	bc70      	pop	{r4, r5, r6}
 8002320:	4770      	bx	lr
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8002322:	7a8b      	ldrb	r3, [r1, #10]
 8002324:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 8002326:	2301      	movs	r3, #1
 8002328:	8283      	strh	r3, [r0, #20]
}
 800232a:	bc70      	pop	{r4, r5, r6}
 800232c:	4770      	bx	lr
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
  }

  TIMx->CR1 = tmpcr1;
 800232e:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8002330:	880b      	ldrh	r3, [r1, #0]
  }

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8002332:	684a      	ldr	r2, [r1, #4]
 8002334:	62c2      	str	r2, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8002336:	8503      	strh	r3, [r0, #40]	; 0x28
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 8002338:	2301      	movs	r3, #1
 800233a:	8283      	strh	r3, [r0, #20]
}
 800233c:	bc70      	pop	{r4, r5, r6}
 800233e:	4770      	bx	lr
 8002340:	40010000 	.word	0x40010000
 8002344:	40001000 	.word	0x40001000
 8002348:	40010400 	.word	0x40010400

0800234c <TIM_TimeBaseStructInit>:
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 800234c:	2300      	movs	r3, #0
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 800234e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002352:	6042      	str	r2, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 8002354:	8003      	strh	r3, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 8002356:	8103      	strh	r3, [r0, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 8002358:	8043      	strh	r3, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 800235a:	7283      	strb	r3, [r0, #10]
 800235c:	4770      	bx	lr
 800235e:	bf00      	nop

08002360 <TIM_PrescalerConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 8002360:	8501      	strh	r1, [r0, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 8002362:	8282      	strh	r2, [r0, #20]
 8002364:	4770      	bx	lr
 8002366:	bf00      	nop

08002368 <TIM_CounterModeConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));

  tmpcr1 = TIMx->CR1;
 8002368:	8803      	ldrh	r3, [r0, #0]

  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
 800236a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800236e:	041b      	lsls	r3, r3, #16
 8002370:	0c1b      	lsrs	r3, r3, #16

  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 8002372:	4319      	orrs	r1, r3

  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 8002374:	8001      	strh	r1, [r0, #0]
 8002376:	4770      	bx	lr

08002378 <TIM_SetCounter>:
{
  /* Check the parameters */
   assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 8002378:	6241      	str	r1, [r0, #36]	; 0x24
 800237a:	4770      	bx	lr

0800237c <TIM_SetAutoreload>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 800237c:	62c1      	str	r1, [r0, #44]	; 0x2c
 800237e:	4770      	bx	lr

08002380 <TIM_GetCounter>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Counter Register value */
  return TIMx->CNT;
 8002380:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
 8002382:	4770      	bx	lr

08002384 <TIM_GetPrescaler>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Prescaler Register value */
  return TIMx->PSC;
 8002384:	8d00      	ldrh	r0, [r0, #40]	; 0x28
}
 8002386:	b280      	uxth	r0, r0
 8002388:	4770      	bx	lr
 800238a:	bf00      	nop

0800238c <TIM_UpdateDisableConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 800238c:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800238e:	b929      	cbnz	r1, 800239c <TIM_UpdateDisableConfig+0x10>
    TIMx->CR1 |= TIM_CR1_UDIS;
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
 8002390:	f023 0302 	bic.w	r3, r3, #2
 8002394:	041b      	lsls	r3, r3, #16
 8002396:	0c1b      	lsrs	r3, r3, #16
 8002398:	8003      	strh	r3, [r0, #0]
 800239a:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 800239c:	b29b      	uxth	r3, r3
 800239e:	f043 0302 	orr.w	r3, r3, #2
 80023a2:	8003      	strh	r3, [r0, #0]
 80023a4:	4770      	bx	lr
 80023a6:	bf00      	nop

080023a8 <TIM_UpdateRequestConfig>:
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 80023a8:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 80023aa:	b929      	cbnz	r1, 80023b8 <TIM_UpdateRequestConfig+0x10>
    TIMx->CR1 |= TIM_CR1_URS;
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
 80023ac:	f023 0304 	bic.w	r3, r3, #4
 80023b0:	041b      	lsls	r3, r3, #16
 80023b2:	0c1b      	lsrs	r3, r3, #16
 80023b4:	8003      	strh	r3, [r0, #0]
 80023b6:	4770      	bx	lr
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 80023b8:	b29b      	uxth	r3, r3
 80023ba:	f043 0304 	orr.w	r3, r3, #4
 80023be:	8003      	strh	r3, [r0, #0]
 80023c0:	4770      	bx	lr
 80023c2:	bf00      	nop

080023c4 <TIM_ARRPreloadConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 80023c4:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80023c6:	b929      	cbnz	r1, 80023d4 <TIM_ARRPreloadConfig+0x10>
    TIMx->CR1 |= TIM_CR1_ARPE;
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 80023c8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80023cc:	041b      	lsls	r3, r3, #16
 80023ce:	0c1b      	lsrs	r3, r3, #16
 80023d0:	8003      	strh	r3, [r0, #0]
 80023d2:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 80023d4:	b29b      	uxth	r3, r3
 80023d6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80023da:	8003      	strh	r3, [r0, #0]
 80023dc:	4770      	bx	lr
 80023de:	bf00      	nop

080023e0 <TIM_SelectOnePulseMode>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));

  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
 80023e0:	8803      	ldrh	r3, [r0, #0]
 80023e2:	f023 0308 	bic.w	r3, r3, #8
 80023e6:	041b      	lsls	r3, r3, #16
 80023e8:	0c1b      	lsrs	r3, r3, #16
 80023ea:	8003      	strh	r3, [r0, #0]

  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 80023ec:	8803      	ldrh	r3, [r0, #0]
 80023ee:	b29b      	uxth	r3, r3
 80023f0:	4319      	orrs	r1, r3
 80023f2:	8001      	strh	r1, [r0, #0]
 80023f4:	4770      	bx	lr
 80023f6:	bf00      	nop

080023f8 <TIM_SetClockDivision>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));

  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
 80023f8:	8803      	ldrh	r3, [r0, #0]
 80023fa:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80023fe:	041b      	lsls	r3, r3, #16
 8002400:	0c1b      	lsrs	r3, r3, #16
 8002402:	8003      	strh	r3, [r0, #0]

  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 8002404:	8803      	ldrh	r3, [r0, #0]
 8002406:	b29b      	uxth	r3, r3
 8002408:	4319      	orrs	r1, r3
 800240a:	8001      	strh	r1, [r0, #0]
 800240c:	4770      	bx	lr
 800240e:	bf00      	nop

08002410 <TIM_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8002410:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8002412:	b929      	cbnz	r1, 8002420 <TIM_Cmd+0x10>
    TIMx->CR1 |= TIM_CR1_CEN;
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 8002414:	f023 0301 	bic.w	r3, r3, #1
 8002418:	041b      	lsls	r3, r3, #16
 800241a:	0c1b      	lsrs	r3, r3, #16
 800241c:	8003      	strh	r3, [r0, #0]
 800241e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8002420:	b29b      	uxth	r3, r3
 8002422:	f043 0301 	orr.w	r3, r3, #1
 8002426:	8003      	strh	r3, [r0, #0]
 8002428:	4770      	bx	lr
 800242a:	bf00      	nop

0800242c <TIM_OC1Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800242c:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 800242e:	8c04      	ldrh	r4, [r0, #32]
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8002430:	f8b1 c002 	ldrh.w	ip, [r1, #2]
 8002434:	898f      	ldrh	r7, [r1, #12]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8002436:	880e      	ldrh	r6, [r1, #0]
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8002438:	4d1b      	ldr	r5, [pc, #108]	; (80024a8 <TIM_OC1Init+0x7c>)
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 800243a:	f024 0401 	bic.w	r4, r4, #1
 800243e:	0424      	lsls	r4, r4, #16
 8002440:	0c24      	lsrs	r4, r4, #16
 8002442:	8404      	strh	r4, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002444:	8c02      	ldrh	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002446:	8884      	ldrh	r4, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8002448:	8b03      	ldrh	r3, [r0, #24]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 800244a:	f022 0202 	bic.w	r2, r2, #2
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 800244e:	f023 0373 	bic.w	r3, r3, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 8002452:	0412      	lsls	r2, r2, #16
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8002454:	ea4c 0707 	orr.w	r7, ip, r7
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 8002458:	041b      	lsls	r3, r3, #16
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 800245a:	0c12      	lsrs	r2, r2, #16
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 800245c:	b2bf      	uxth	r7, r7
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 800245e:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8002460:	42a8      	cmp	r0, r5
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8002462:	ea47 0202 	orr.w	r2, r7, r2
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002466:	b2a4      	uxth	r4, r4
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8002468:	ea43 0306 	orr.w	r3, r3, r6
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800246c:	d00a      	beq.n	8002484 <TIM_OC1Init+0x58>
 800246e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002472:	42a8      	cmp	r0, r5
 8002474:	d006      	beq.n	8002484 <TIM_OC1Init+0x58>
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8002476:	6889      	ldr	r1, [r1, #8]
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8002478:	8084      	strh	r4, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800247a:	8303      	strh	r3, [r0, #24]
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 800247c:	bcf0      	pop	{r4, r5, r6, r7}
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 800247e:	6341      	str	r1, [r0, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8002480:	8402      	strh	r2, [r0, #32]
}
 8002482:	4770      	bx	lr
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8002484:	f8b1 c00e 	ldrh.w	ip, [r1, #14]
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8002488:	8a4f      	ldrh	r7, [r1, #18]
 800248a:	8a0d      	ldrh	r5, [r1, #16]
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 800248c:	888e      	ldrh	r6, [r1, #4]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 800248e:	f022 0208 	bic.w	r2, r2, #8
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8002492:	ea42 020c 	orr.w	r2, r2, ip
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8002496:	433d      	orrs	r5, r7
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
 8002498:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
 800249c:	f022 0204 	bic.w	r2, r2, #4
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 80024a0:	b2ad      	uxth	r5, r5
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 80024a2:	4332      	orrs	r2, r6
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 80024a4:	432c      	orrs	r4, r5
 80024a6:	e7e6      	b.n	8002476 <TIM_OC1Init+0x4a>
 80024a8:	40010000 	.word	0x40010000

080024ac <TIM_OC2Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 80024ac:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 80024ae:	8c04      	ldrh	r4, [r0, #32]
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 80024b0:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 80024b4:	884f      	ldrh	r7, [r1, #2]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80024b6:	880e      	ldrh	r6, [r1, #0]
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 80024b8:	4d1f      	ldr	r5, [pc, #124]	; (8002538 <TIM_OC2Init+0x8c>)
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 80024ba:	f024 0410 	bic.w	r4, r4, #16
 80024be:	0424      	lsls	r4, r4, #16
 80024c0:	0c24      	lsrs	r4, r4, #16
 80024c2:	8404      	strh	r4, [r0, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 80024c4:	8c02      	ldrh	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80024c6:	8884      	ldrh	r4, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80024c8:	8b03      	ldrh	r3, [r0, #24]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 80024ca:	f022 0220 	bic.w	r2, r2, #32
 80024ce:	0412      	lsls	r2, r2, #16
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 80024d0:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 80024d4:	0c12      	lsrs	r2, r2, #16
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 80024d6:	041b      	lsls	r3, r3, #16
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 80024d8:	ea42 120c 	orr.w	r2, r2, ip, lsl #4
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 80024dc:	0c1b      	lsrs	r3, r3, #16
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 80024de:	ea42 1207 	orr.w	r2, r2, r7, lsl #4
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80024e2:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 80024e6:	42a8      	cmp	r0, r5
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 80024e8:	b292      	uxth	r2, r2
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80024ea:	b2a4      	uxth	r4, r4
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80024ec:	b29b      	uxth	r3, r3
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 80024ee:	d00a      	beq.n	8002506 <TIM_OC2Init+0x5a>
 80024f0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80024f4:	42a8      	cmp	r0, r5
 80024f6:	d006      	beq.n	8002506 <TIM_OC2Init+0x5a>
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 80024f8:	6889      	ldr	r1, [r1, #8]
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80024fa:	8084      	strh	r4, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80024fc:	8303      	strh	r3, [r0, #24]
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 80024fe:	bcf0      	pop	{r4, r5, r6, r7}
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8002500:	6381      	str	r1, [r0, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8002502:	8402      	strh	r2, [r0, #32]
}
 8002504:	4770      	bx	lr
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8002506:	89cd      	ldrh	r5, [r1, #14]
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 8002508:	f8b1 c010 	ldrh.w	ip, [r1, #16]
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 800250c:	888f      	ldrh	r7, [r1, #4]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 800250e:	8a4e      	ldrh	r6, [r1, #18]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 8002510:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002514:	b292      	uxth	r2, r2
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8002516:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
 800251a:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
 800251e:	f64f 75bf 	movw	r5, #65471	; 0xffbf
 8002522:	4015      	ands	r5, r2
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 8002524:	ea44 048c 	orr.w	r4, r4, ip, lsl #2
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 8002528:	ea45 1207 	orr.w	r2, r5, r7, lsl #4
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 800252c:	ea44 0486 	orr.w	r4, r4, r6, lsl #2
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 8002530:	b292      	uxth	r2, r2
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8002532:	b2a4      	uxth	r4, r4
 8002534:	e7e0      	b.n	80024f8 <TIM_OC2Init+0x4c>
 8002536:	bf00      	nop
 8002538:	40010000 	.word	0x40010000

0800253c <TIM_OC3Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800253c:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 800253e:	8c04      	ldrh	r4, [r0, #32]
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 8002540:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8002544:	884f      	ldrh	r7, [r1, #2]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8002546:	880e      	ldrh	r6, [r1, #0]
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8002548:	4d1e      	ldr	r5, [pc, #120]	; (80025c4 <TIM_OC3Init+0x88>)
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 800254a:	f424 7480 	bic.w	r4, r4, #256	; 0x100
 800254e:	0424      	lsls	r4, r4, #16
 8002550:	0c24      	lsrs	r4, r4, #16
 8002552:	8404      	strh	r4, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002554:	8c02      	ldrh	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002556:	8884      	ldrh	r4, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8002558:	8b83      	ldrh	r3, [r0, #28]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 800255a:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800255e:	0412      	lsls	r2, r2, #16
 8002560:	0c12      	lsrs	r2, r2, #16
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
 8002562:	f023 0373 	bic.w	r3, r3, #115	; 0x73
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 8002566:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
 800256a:	041b      	lsls	r3, r3, #16
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 800256c:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
 8002570:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8002572:	42a8      	cmp	r0, r5
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8002574:	b292      	uxth	r2, r2
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002576:	b2a4      	uxth	r4, r4
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8002578:	ea43 0306 	orr.w	r3, r3, r6
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800257c:	d00a      	beq.n	8002594 <TIM_OC3Init+0x58>
 800257e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002582:	42a8      	cmp	r0, r5
 8002584:	d006      	beq.n	8002594 <TIM_OC3Init+0x58>
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8002586:	6889      	ldr	r1, [r1, #8]
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8002588:	8084      	strh	r4, [r0, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800258a:	8383      	strh	r3, [r0, #28]
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 800258c:	bcf0      	pop	{r4, r5, r6, r7}
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 800258e:	63c1      	str	r1, [r0, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8002590:	8402      	strh	r2, [r0, #32]
}
 8002592:	4770      	bx	lr
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8002594:	89cd      	ldrh	r5, [r1, #14]
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 8002596:	f8b1 c010 	ldrh.w	ip, [r1, #16]
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 800259a:	888f      	ldrh	r7, [r1, #4]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 800259c:	8a4e      	ldrh	r6, [r1, #18]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 800259e:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80025a2:	b292      	uxth	r2, r2
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 80025a4:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
 80025a8:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
 80025ac:	f64f 35ff 	movw	r5, #64511	; 0xfbff
 80025b0:	4015      	ands	r5, r2
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 80025b2:	ea44 140c 	orr.w	r4, r4, ip, lsl #4
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 80025b6:	ea45 2207 	orr.w	r2, r5, r7, lsl #8
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 80025ba:	ea44 1406 	orr.w	r4, r4, r6, lsl #4
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 80025be:	b292      	uxth	r2, r2
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 80025c0:	b2a4      	uxth	r4, r4
 80025c2:	e7e0      	b.n	8002586 <TIM_OC3Init+0x4a>
 80025c4:	40010000 	.word	0x40010000

080025c8 <TIM_OC4Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 80025c8:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 80025ca:	8c04      	ldrh	r4, [r0, #32]
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 80025cc:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 80025d0:	884f      	ldrh	r7, [r1, #2]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80025d2:	880e      	ldrh	r6, [r1, #0]
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 80025d4:	4d16      	ldr	r5, [pc, #88]	; (8002630 <TIM_OC4Init+0x68>)
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 80025d6:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
 80025da:	0424      	lsls	r4, r4, #16
 80025dc:	0c24      	lsrs	r4, r4, #16
 80025de:	8404      	strh	r4, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80025e0:	8c02      	ldrh	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80025e2:	8884      	ldrh	r4, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80025e4:	8b83      	ldrh	r3, [r0, #28]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 80025e6:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80025ea:	0412      	lsls	r2, r2, #16
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
 80025ec:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 80025f0:	0c12      	lsrs	r2, r2, #16
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
 80025f2:	041b      	lsls	r3, r3, #16
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 80025f4:	ea42 320c 	orr.w	r2, r2, ip, lsl #12
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
 80025f8:	0c1b      	lsrs	r3, r3, #16
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 80025fa:	ea42 3207 	orr.w	r2, r2, r7, lsl #12
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80025fe:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8002602:	42a8      	cmp	r0, r5
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 8002604:	b292      	uxth	r2, r2
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002606:	b2a4      	uxth	r4, r4
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8002608:	b29b      	uxth	r3, r3
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 800260a:	d00a      	beq.n	8002622 <TIM_OC4Init+0x5a>
 800260c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002610:	42a8      	cmp	r0, r5
 8002612:	d006      	beq.n	8002622 <TIM_OC4Init+0x5a>
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 8002614:	6889      	ldr	r1, [r1, #8]
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8002616:	8084      	strh	r4, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 8002618:	8383      	strh	r3, [r0, #28]
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 800261a:	bcf0      	pop	{r4, r5, r6, r7}
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 800261c:	6401      	str	r1, [r0, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800261e:	8402      	strh	r2, [r0, #32]
}
 8002620:	4770      	bx	lr
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 8002622:	8a0d      	ldrh	r5, [r1, #16]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
 8002624:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 8002628:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 800262c:	b2a4      	uxth	r4, r4
 800262e:	e7f1      	b.n	8002614 <TIM_OC4Init+0x4c>
 8002630:	40010000 	.word	0x40010000

08002634 <TIM_OCStructInit>:
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 8002634:	2300      	movs	r3, #0
 8002636:	8003      	strh	r3, [r0, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 8002638:	8043      	strh	r3, [r0, #2]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 800263a:	8083      	strh	r3, [r0, #4]
  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
 800263c:	6083      	str	r3, [r0, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 800263e:	8183      	strh	r3, [r0, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 8002640:	81c3      	strh	r3, [r0, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 8002642:	8203      	strh	r3, [r0, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 8002644:	8243      	strh	r3, [r0, #18]
 8002646:	4770      	bx	lr

08002648 <TIM_SelectOCxM>:
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8002648:	8c03      	ldrh	r3, [r0, #32]
  *            @arg TIM_ForcedAction_Active
  *            @arg TIM_ForcedAction_InActive
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
{
 800264a:	b410      	push	{r4}
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 800264c:	2401      	movs	r4, #1

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 800264e:	b29b      	uxth	r3, r3
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 8002650:	408c      	lsls	r4, r1

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8002652:	ea23 0404 	bic.w	r4, r3, r4

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 8002656:	f021 0308 	bic.w	r3, r1, #8
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 800265a:	8404      	strh	r4, [r0, #32]
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;
 800265c:	3018      	adds	r0, #24
  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 800265e:	b17b      	cbz	r3, 8002680 <TIM_SelectOCxM+0x38>
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
  }
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
 8002660:	3904      	subs	r1, #4
 8002662:	f3c1 014e 	ubfx	r1, r1, #1, #15

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 8002666:	f648 73ff 	movw	r3, #36863	; 0x8fff
 800266a:	580c      	ldr	r4, [r1, r0]
 800266c:	4023      	ands	r3, r4
 800266e:	500b      	str	r3, [r1, r0]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8002670:	0212      	lsls	r2, r2, #8
 8002672:	580b      	ldr	r3, [r1, r0]
  }
}
 8002674:	f85d 4b04 	ldr.w	r4, [sp], #4

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8002678:	b292      	uxth	r2, r2
 800267a:	431a      	orrs	r2, r3
 800267c:	500a      	str	r2, [r1, r0]
  }
}
 800267e:	4770      	bx	lr
  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
  {
    tmp += (TIM_Channel>>1);
 8002680:	0849      	lsrs	r1, r1, #1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
 8002682:	f64f 738f 	movw	r3, #65423	; 0xff8f
 8002686:	5844      	ldr	r4, [r0, r1]
 8002688:	4023      	ands	r3, r4
 800268a:	5043      	str	r3, [r0, r1]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 800268c:	5843      	ldr	r3, [r0, r1]
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
  }
}
 800268e:	f85d 4b04 	ldr.w	r4, [sp], #4

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 8002692:	431a      	orrs	r2, r3
 8002694:	5042      	str	r2, [r0, r1]
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
  }
}
 8002696:	4770      	bx	lr

08002698 <TIM_SetCompare1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 8002698:	6341      	str	r1, [r0, #52]	; 0x34
 800269a:	4770      	bx	lr

0800269c <TIM_SetCompare2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 800269c:	6381      	str	r1, [r0, #56]	; 0x38
 800269e:	4770      	bx	lr

080026a0 <TIM_SetCompare3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 80026a0:	63c1      	str	r1, [r0, #60]	; 0x3c
 80026a2:	4770      	bx	lr

080026a4 <TIM_SetCompare4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 80026a4:	6401      	str	r1, [r0, #64]	; 0x40
 80026a6:	4770      	bx	lr

080026a8 <TIM_ForcedOC1Config>:
  uint16_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 80026a8:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
 80026aa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80026ae:	041b      	lsls	r3, r3, #16
 80026b0:	0c1b      	lsrs	r3, r3, #16

  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 80026b2:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 80026b4:	8301      	strh	r1, [r0, #24]
 80026b6:	4770      	bx	lr

080026b8 <TIM_ForcedOC2Config>:
  uint16_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 80026b8:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
 80026ba:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80026be:	041b      	lsls	r3, r3, #16
 80026c0:	0c1b      	lsrs	r3, r3, #16

  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
 80026c2:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80026c6:	b28b      	uxth	r3, r1

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 80026c8:	8303      	strh	r3, [r0, #24]
 80026ca:	4770      	bx	lr

080026cc <TIM_ForcedOC3Config>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));

  tmpccmr2 = TIMx->CCMR2;
 80026cc:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
 80026ce:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80026d2:	041b      	lsls	r3, r3, #16
 80026d4:	0c1b      	lsrs	r3, r3, #16

  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 80026d6:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 80026d8:	8381      	strh	r1, [r0, #28]
 80026da:	4770      	bx	lr

080026dc <TIM_ForcedOC4Config>:
  uint16_t tmpccmr2 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 80026dc:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
 80026de:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80026e2:	041b      	lsls	r3, r3, #16
 80026e4:	0c1b      	lsrs	r3, r3, #16

  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
 80026e6:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80026ea:	b28b      	uxth	r3, r1

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 80026ec:	8383      	strh	r3, [r0, #28]
 80026ee:	4770      	bx	lr

080026f0 <TIM_OC1PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 80026f0:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
 80026f2:	f023 0308 	bic.w	r3, r3, #8
 80026f6:	041b      	lsls	r3, r3, #16
 80026f8:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 80026fa:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 80026fc:	8301      	strh	r1, [r0, #24]
 80026fe:	4770      	bx	lr

08002700 <TIM_OC2PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8002700:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
 8002702:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8002706:	041b      	lsls	r3, r3, #16
 8002708:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 800270a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800270e:	b28b      	uxth	r3, r1

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8002710:	8303      	strh	r3, [r0, #24]
 8002712:	4770      	bx	lr

08002714 <TIM_OC3PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8002714:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
 8002716:	f023 0308 	bic.w	r3, r3, #8
 800271a:	041b      	lsls	r3, r3, #16
 800271c:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 800271e:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8002720:	8381      	strh	r1, [r0, #28]
 8002722:	4770      	bx	lr

08002724 <TIM_OC4PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8002724:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
 8002726:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800272a:	041b      	lsls	r3, r3, #16
 800272c:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
 800272e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8002732:	b28b      	uxth	r3, r1

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8002734:	8383      	strh	r3, [r0, #28]
 8002736:	4770      	bx	lr

08002738 <TIM_OC1FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8002738:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
 800273a:	f023 0304 	bic.w	r3, r3, #4
 800273e:	041b      	lsls	r3, r3, #16
 8002740:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 8002742:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8002744:	8301      	strh	r1, [r0, #24]
 8002746:	4770      	bx	lr

08002748 <TIM_OC2FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8002748:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
 800274a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800274e:	041b      	lsls	r3, r3, #16
 8002750:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
 8002752:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8002756:	b28b      	uxth	r3, r1

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8002758:	8303      	strh	r3, [r0, #24]
 800275a:	4770      	bx	lr

0800275c <TIM_OC3FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 800275c:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
 800275e:	f023 0304 	bic.w	r3, r3, #4
 8002762:	041b      	lsls	r3, r3, #16
 8002764:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 8002766:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8002768:	8381      	strh	r1, [r0, #28]
 800276a:	4770      	bx	lr

0800276c <TIM_OC4FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 800276c:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
 800276e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002772:	041b      	lsls	r3, r3, #16
 8002774:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
 8002776:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800277a:	b28b      	uxth	r3, r1

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 800277c:	8383      	strh	r3, [r0, #28]
 800277e:	4770      	bx	lr

08002780 <TIM_ClearOC1Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8002780:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
 8002782:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002786:	041b      	lsls	r3, r3, #16
 8002788:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 800278a:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800278c:	8301      	strh	r1, [r0, #24]
 800278e:	4770      	bx	lr

08002790 <TIM_ClearOC2Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8002790:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
 8002792:	f3c3 030e 	ubfx	r3, r3, #0, #15

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 8002796:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800279a:	b28b      	uxth	r3, r1

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800279c:	8303      	strh	r3, [r0, #24]
 800279e:	4770      	bx	lr

080027a0 <TIM_ClearOC3Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 80027a0:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
 80027a2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80027a6:	041b      	lsls	r3, r3, #16
 80027a8:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 80027aa:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 80027ac:	8381      	strh	r1, [r0, #28]
 80027ae:	4770      	bx	lr

080027b0 <TIM_ClearOC4Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 80027b0:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
 80027b2:	f3c3 030e 	ubfx	r3, r3, #0, #15

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 80027b6:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80027ba:	b28b      	uxth	r3, r1

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 80027bc:	8383      	strh	r3, [r0, #28]
 80027be:	4770      	bx	lr

080027c0 <TIM_OC1PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 80027c0:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
 80027c2:	f023 0302 	bic.w	r3, r3, #2
 80027c6:	041b      	lsls	r3, r3, #16
 80027c8:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= TIM_OCPolarity;
 80027ca:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80027cc:	8401      	strh	r1, [r0, #32]
 80027ce:	4770      	bx	lr

080027d0 <TIM_OC1NPolarityConfig>:
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 80027d0:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 80027d2:	f023 0308 	bic.w	r3, r3, #8
 80027d6:	041b      	lsls	r3, r3, #16
 80027d8:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= TIM_OCNPolarity;
 80027da:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80027dc:	8401      	strh	r1, [r0, #32]
 80027de:	4770      	bx	lr

080027e0 <TIM_OC2PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 80027e0:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
 80027e2:	f023 0320 	bic.w	r3, r3, #32
 80027e6:	041b      	lsls	r3, r3, #16
 80027e8:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
 80027ea:	ea43 1101 	orr.w	r1, r3, r1, lsl #4
 80027ee:	b28b      	uxth	r3, r1

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80027f0:	8403      	strh	r3, [r0, #32]
 80027f2:	4770      	bx	lr

080027f4 <TIM_OC2NPolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 80027f4:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 80027f6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80027fa:	041b      	lsls	r3, r3, #16
 80027fc:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
 80027fe:	ea43 1101 	orr.w	r1, r3, r1, lsl #4
 8002802:	b28b      	uxth	r3, r1

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8002804:	8403      	strh	r3, [r0, #32]
 8002806:	4770      	bx	lr

08002808 <TIM_OC3PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8002808:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 800280a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800280e:	041b      	lsls	r3, r3, #16
 8002810:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
 8002812:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8002816:	b28b      	uxth	r3, r1

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8002818:	8403      	strh	r3, [r0, #32]
 800281a:	4770      	bx	lr

0800281c <TIM_OC3NPolarityConfig>:
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 800281c:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 800281e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8002822:	041b      	lsls	r3, r3, #16
 8002824:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
 8002826:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800282a:	b28b      	uxth	r3, r1

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800282c:	8403      	strh	r3, [r0, #32]
 800282e:	4770      	bx	lr

08002830 <TIM_OC4PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8002830:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 8002832:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002836:	041b      	lsls	r3, r3, #16
 8002838:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
 800283a:	ea43 3101 	orr.w	r1, r3, r1, lsl #12
 800283e:	b28b      	uxth	r3, r1

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8002840:	8403      	strh	r3, [r0, #32]
 8002842:	4770      	bx	lr

08002844 <TIM_CCxCmd>:
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 8002844:	8c03      	ldrh	r3, [r0, #32]
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 8002846:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;
 8002848:	2401      	movs	r4, #1
 800284a:	408c      	lsls	r4, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 800284c:	b29b      	uxth	r3, r3
 800284e:	ea23 0304 	bic.w	r3, r3, r4
 8002852:	8403      	strh	r3, [r0, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 8002854:	8c03      	ldrh	r3, [r0, #32]
}
 8002856:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 800285a:	408a      	lsls	r2, r1
 800285c:	4313      	orrs	r3, r2
 800285e:	b29b      	uxth	r3, r3
 8002860:	8403      	strh	r3, [r0, #32]
}
 8002862:	4770      	bx	lr

08002864 <TIM_CCxNCmd>:
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 8002864:	8c03      	ldrh	r3, [r0, #32]
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 8002866:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;
 8002868:	2404      	movs	r4, #4
 800286a:	408c      	lsls	r4, r1

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 800286c:	b29b      	uxth	r3, r3
 800286e:	ea23 0304 	bic.w	r3, r3, r4
 8002872:	8403      	strh	r3, [r0, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 8002874:	8c03      	ldrh	r3, [r0, #32]
}
 8002876:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 800287a:	408a      	lsls	r2, r1
 800287c:	4313      	orrs	r3, r2
 800287e:	b29b      	uxth	r3, r3
 8002880:	8403      	strh	r3, [r0, #32]
}
 8002882:	4770      	bx	lr

08002884 <TIM_ICInit>:
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8002884:	880b      	ldrh	r3, [r1, #0]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8002886:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8002888:	2b00      	cmp	r3, #0
 800288a:	d032      	beq.n	80028f2 <TIM_ICInit+0x6e>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 800288c:	2b04      	cmp	r3, #4
 800288e:	d058      	beq.n	8002942 <TIM_ICInit+0xbe>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 8002890:	2b08      	cmp	r3, #8
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8002892:	8c03      	ldrh	r3, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 8002894:	f000 8083 	beq.w	800299e <TIM_ICInit+0x11a>
  }
  else
  {
    /* TI4 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8002898:	884e      	ldrh	r6, [r1, #2]
 800289a:	888f      	ldrh	r7, [r1, #4]
 800289c:	890d      	ldrh	r5, [r1, #8]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800289e:	88cc      	ldrh	r4, [r1, #6]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 80028a0:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 80028a4:	0409      	lsls	r1, r1, #16
 80028a6:	0c09      	lsrs	r1, r1, #16
 80028a8:	8401      	strh	r1, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 80028aa:	8b82      	ldrh	r2, [r0, #28]
  tmpccer = TIMx->CCER;
 80028ac:	8c03      	ldrh	r3, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 80028ae:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 80028b2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 80028b6:	0512      	lsls	r2, r2, #20
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 80028b8:	045b      	lsls	r3, r3, #17
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 80028ba:	0d12      	lsrs	r2, r2, #20
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 80028bc:	0c5b      	lsrs	r3, r3, #17
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 80028be:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 80028c2:	ea43 3306 	orr.w	r3, r3, r6, lsl #12
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 80028c6:	ea42 3205 	orr.w	r2, r2, r5, lsl #12

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 80028ca:	b29b      	uxth	r3, r3
 80028cc:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 80028d0:	b292      	uxth	r2, r2
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 80028d2:	8382      	strh	r2, [r0, #28]
  TIMx->CCER = tmpccer ;
 80028d4:	8403      	strh	r3, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 80028d6:	8b83      	ldrh	r3, [r0, #28]
 80028d8:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80028dc:	041b      	lsls	r3, r3, #16
 80028de:	0c1b      	lsrs	r3, r3, #16
 80028e0:	8383      	strh	r3, [r0, #28]

  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 80028e2:	8b83      	ldrh	r3, [r0, #28]
 80028e4:	b29b      	uxth	r3, r3
 80028e6:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 80028ea:	b29b      	uxth	r3, r3
 80028ec:	8383      	strh	r3, [r0, #28]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 80028ee:	bcf0      	pop	{r4, r5, r6, r7}
 80028f0:	4770      	bx	lr
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 80028f2:	8c02      	ldrh	r2, [r0, #32]
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 80028f4:	888d      	ldrh	r5, [r1, #4]
 80028f6:	890e      	ldrh	r6, [r1, #8]
 80028f8:	884c      	ldrh	r4, [r1, #2]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80028fa:	88c9      	ldrh	r1, [r1, #6]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 80028fc:	f022 0201 	bic.w	r2, r2, #1
 8002900:	0412      	lsls	r2, r2, #16
 8002902:	0c12      	lsrs	r2, r2, #16
 8002904:	8402      	strh	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002906:	8b02      	ldrh	r2, [r0, #24]
  tmpccer = TIMx->CCER;
 8002908:	8c03      	ldrh	r3, [r0, #32]
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;
 800290a:	b292      	uxth	r2, r2
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
 800290c:	f022 02f3 	bic.w	r2, r2, #243	; 0xf3
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002910:	f023 030a 	bic.w	r3, r3, #10
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002914:	ea42 1206 	orr.w	r2, r2, r6, lsl #4

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002918:	041b      	lsls	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 800291a:	f044 0401 	orr.w	r4, r4, #1
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 800291e:	b292      	uxth	r2, r2

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002920:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8002922:	4323      	orrs	r3, r4
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002924:	432a      	orrs	r2, r5
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8002926:	8302      	strh	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 8002928:	8403      	strh	r3, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
 800292a:	8b03      	ldrh	r3, [r0, #24]
 800292c:	f023 030c 	bic.w	r3, r3, #12
 8002930:	041b      	lsls	r3, r3, #16
 8002932:	0c1b      	lsrs	r3, r3, #16
 8002934:	8303      	strh	r3, [r0, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8002936:	8b03      	ldrh	r3, [r0, #24]
 8002938:	b29b      	uxth	r3, r3
 800293a:	430b      	orrs	r3, r1
 800293c:	8303      	strh	r3, [r0, #24]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 800293e:	bcf0      	pop	{r4, r5, r6, r7}
 8002940:	4770      	bx	lr
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8002942:	8c02      	ldrh	r2, [r0, #32]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
  {
    /* TI2 Configuration */
    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8002944:	884e      	ldrh	r6, [r1, #2]
 8002946:	888c      	ldrh	r4, [r1, #4]
 8002948:	890f      	ldrh	r7, [r1, #8]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800294a:	88c9      	ldrh	r1, [r1, #6]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 800294c:	f022 0210 	bic.w	r2, r2, #16
 8002950:	0412      	lsls	r2, r2, #16
 8002952:	0c12      	lsrs	r2, r2, #16
 8002954:	8402      	strh	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002956:	8b03      	ldrh	r3, [r0, #24]
  tmpccer = TIMx->CCER;
 8002958:	8c05      	ldrh	r5, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 800295a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800295e:	051b      	lsls	r3, r3, #20
 8002960:	0d1b      	lsrs	r3, r3, #20
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8002962:	b2ad      	uxth	r5, r5
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8002964:	ea43 3207 	orr.w	r2, r3, r7, lsl #12
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8002968:	f025 05a0 	bic.w	r5, r5, #160	; 0xa0
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 800296c:	ea45 1306 	orr.w	r3, r5, r6, lsl #4
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8002970:	b292      	uxth	r2, r2
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8002972:	ea42 2204 	orr.w	r2, r2, r4, lsl #8

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8002976:	b29b      	uxth	r3, r3
 8002978:	f043 0310 	orr.w	r3, r3, #16
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 800297c:	b292      	uxth	r2, r2
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800297e:	8302      	strh	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 8002980:	8403      	strh	r3, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
 8002982:	8b03      	ldrh	r3, [r0, #24]
 8002984:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8002988:	041b      	lsls	r3, r3, #16
 800298a:	0c1b      	lsrs	r3, r3, #16
 800298c:	8303      	strh	r3, [r0, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 800298e:	8b03      	ldrh	r3, [r0, #24]
 8002990:	b29b      	uxth	r3, r3
 8002992:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8002996:	b29b      	uxth	r3, r3
 8002998:	8303      	strh	r3, [r0, #24]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 800299a:	bcf0      	pop	{r4, r5, r6, r7}
 800299c:	4770      	bx	lr
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 800299e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80029a2:	041b      	lsls	r3, r3, #16
 80029a4:	0c1b      	lsrs	r3, r3, #16
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
  {
    /* TI3 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 80029a6:	884d      	ldrh	r5, [r1, #2]
 80029a8:	888c      	ldrh	r4, [r1, #4]
 80029aa:	890e      	ldrh	r6, [r1, #8]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80029ac:	88ca      	ldrh	r2, [r1, #6]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 80029ae:	8403      	strh	r3, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 80029b0:	8b81      	ldrh	r1, [r0, #28]
  tmpccer = TIMx->CCER;
 80029b2:	8c03      	ldrh	r3, [r0, #32]
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
  tmpccmr2 = TIMx->CCMR2;
 80029b4:	b289      	uxth	r1, r1
  tmpccer = TIMx->CCER;
 80029b6:	b29b      	uxth	r3, r3
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 80029b8:	f021 01f3 	bic.w	r1, r1, #243	; 0xf3
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 80029bc:	f423 6320 	bic.w	r3, r3, #2560	; 0xa00
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 80029c0:	ea41 1106 	orr.w	r1, r1, r6, lsl #4

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 80029c4:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 80029c8:	b289      	uxth	r1, r1

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 80029ca:	b29b      	uxth	r3, r3
 80029cc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 80029d0:	4321      	orrs	r1, r4
  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 80029d2:	8381      	strh	r1, [r0, #28]
  TIMx->CCER = tmpccer;
 80029d4:	8403      	strh	r3, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 80029d6:	8b83      	ldrh	r3, [r0, #28]
 80029d8:	f023 030c 	bic.w	r3, r3, #12
 80029dc:	041b      	lsls	r3, r3, #16
 80029de:	0c1b      	lsrs	r3, r3, #16
 80029e0:	8383      	strh	r3, [r0, #28]

  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 80029e2:	8b83      	ldrh	r3, [r0, #28]
 80029e4:	b29b      	uxth	r3, r3
 80029e6:	4313      	orrs	r3, r2
 80029e8:	8383      	strh	r3, [r0, #28]
 80029ea:	e780      	b.n	80028ee <TIM_ICInit+0x6a>

080029ec <TIM_ICStructInit>:
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 80029ec:	2300      	movs	r3, #0
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 80029ee:	2201      	movs	r2, #1
 80029f0:	8082      	strh	r2, [r0, #4]
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 80029f2:	8003      	strh	r3, [r0, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 80029f4:	8043      	strh	r3, [r0, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 80029f6:	80c3      	strh	r3, [r0, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 80029f8:	8103      	strh	r3, [r0, #8]
 80029fa:	4770      	bx	lr

080029fc <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 80029fc:	b4f0      	push	{r4, r5, r6, r7}

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 80029fe:	884d      	ldrh	r5, [r1, #2]
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 8002a00:	888c      	ldrh	r4, [r1, #4]
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8002a02:	880b      	ldrh	r3, [r1, #0]
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8002a04:	f8b1 c008 	ldrh.w	ip, [r1, #8]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8002a08:	8c02      	ldrh	r2, [r0, #32]
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8002a0a:	88c9      	ldrh	r1, [r1, #6]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 8002a0c:	2d00      	cmp	r5, #0
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
 8002a0e:	bf14      	ite	ne
 8002a10:	2600      	movne	r6, #0
 8002a12:	2602      	moveq	r6, #2
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 8002a14:	2c01      	cmp	r4, #1
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
 8002a16:	bf14      	ite	ne
 8002a18:	2701      	movne	r7, #1
 8002a1a:	2702      	moveq	r7, #2
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8002a1c:	2b00      	cmp	r3, #0
 8002a1e:	d04b      	beq.n	8002ab8 <TIM_PWMIConfig+0xbc>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8002a20:	f022 0210 	bic.w	r2, r2, #16
 8002a24:	0412      	lsls	r2, r2, #16
 8002a26:	0c12      	lsrs	r2, r2, #16
 8002a28:	8402      	strh	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002a2a:	8b03      	ldrh	r3, [r0, #24]
  tmpccer = TIMx->CCER;
 8002a2c:	8c02      	ldrh	r2, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8002a2e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002a32:	051b      	lsls	r3, r3, #20
 8002a34:	0d1b      	lsrs	r3, r3, #20
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8002a36:	b292      	uxth	r2, r2
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8002a38:	ea43 330c 	orr.w	r3, r3, ip, lsl #12
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8002a3c:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8002a40:	b29b      	uxth	r3, r3
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8002a42:	ea42 1505 	orr.w	r5, r2, r5, lsl #4
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8002a46:	ea43 2404 	orr.w	r4, r3, r4, lsl #8

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8002a4a:	b2ad      	uxth	r5, r5
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8002a4c:	b2a4      	uxth	r4, r4

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8002a4e:	f045 0510 	orr.w	r5, r5, #16

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8002a52:	8304      	strh	r4, [r0, #24]
  TIMx->CCER = tmpccer;
 8002a54:	8405      	strh	r5, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
 8002a56:	8b03      	ldrh	r3, [r0, #24]
 8002a58:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8002a5c:	041b      	lsls	r3, r3, #16
 8002a5e:	0c1b      	lsrs	r3, r3, #16
 8002a60:	8303      	strh	r3, [r0, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8002a62:	8b03      	ldrh	r3, [r0, #24]
 8002a64:	b29b      	uxth	r3, r3
 8002a66:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8002a6a:	b29b      	uxth	r3, r3
 8002a6c:	8303      	strh	r3, [r0, #24]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8002a6e:	8c03      	ldrh	r3, [r0, #32]
 8002a70:	f023 0301 	bic.w	r3, r3, #1
 8002a74:	041b      	lsls	r3, r3, #16
 8002a76:	0c1b      	lsrs	r3, r3, #16
 8002a78:	8403      	strh	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002a7a:	8b02      	ldrh	r2, [r0, #24]
  tmpccer = TIMx->CCER;
 8002a7c:	8c03      	ldrh	r3, [r0, #32]
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;
 8002a7e:	b292      	uxth	r2, r2
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
 8002a80:	f022 02f3 	bic.w	r2, r2, #243	; 0xf3
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8002a84:	b29b      	uxth	r3, r3

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002a86:	ea42 1c0c 	orr.w	ip, r2, ip, lsl #4

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002a8a:	f023 030a 	bic.w	r3, r3, #10
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8002a8e:	f043 0301 	orr.w	r3, r3, #1
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002a92:	fa1f fc8c 	uxth.w	ip, ip

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8002a96:	431e      	orrs	r6, r3
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002a98:	ea4c 0707 	orr.w	r7, ip, r7
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8002a9c:	8307      	strh	r7, [r0, #24]
  TIMx->CCER = tmpccer;
 8002a9e:	8406      	strh	r6, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
 8002aa0:	8b03      	ldrh	r3, [r0, #24]
 8002aa2:	f023 030c 	bic.w	r3, r3, #12
 8002aa6:	041b      	lsls	r3, r3, #16
 8002aa8:	0c1b      	lsrs	r3, r3, #16
 8002aaa:	8303      	strh	r3, [r0, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8002aac:	8b03      	ldrh	r3, [r0, #24]
 8002aae:	b29b      	uxth	r3, r3
 8002ab0:	4319      	orrs	r1, r3
 8002ab2:	8301      	strh	r1, [r0, #24]
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8002ab4:	bcf0      	pop	{r4, r5, r6, r7}
 8002ab6:	4770      	bx	lr
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8002ab8:	f022 0201 	bic.w	r2, r2, #1
 8002abc:	0412      	lsls	r2, r2, #16
 8002abe:	0c12      	lsrs	r2, r2, #16
 8002ac0:	8402      	strh	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002ac2:	8b03      	ldrh	r3, [r0, #24]
  tmpccer = TIMx->CCER;
 8002ac4:	8c02      	ldrh	r2, [r0, #32]
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;
 8002ac6:	b29b      	uxth	r3, r3
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
 8002ac8:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002acc:	f022 020a 	bic.w	r2, r2, #10
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002ad0:	ea43 130c 	orr.w	r3, r3, ip, lsl #4

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002ad4:	0412      	lsls	r2, r2, #16
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8002ad6:	f045 0501 	orr.w	r5, r5, #1
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002ada:	b29b      	uxth	r3, r3

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002adc:	0c12      	lsrs	r2, r2, #16
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002ade:	431c      	orrs	r4, r3

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8002ae0:	432a      	orrs	r2, r5

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8002ae2:	8304      	strh	r4, [r0, #24]
  TIMx->CCER = tmpccer;
 8002ae4:	8402      	strh	r2, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
 8002ae6:	8b02      	ldrh	r2, [r0, #24]
 8002ae8:	f022 020c 	bic.w	r2, r2, #12
 8002aec:	0412      	lsls	r2, r2, #16
 8002aee:	0c12      	lsrs	r2, r2, #16
 8002af0:	8302      	strh	r2, [r0, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8002af2:	8b03      	ldrh	r3, [r0, #24]
 8002af4:	b29b      	uxth	r3, r3
 8002af6:	430b      	orrs	r3, r1
 8002af8:	8303      	strh	r3, [r0, #24]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8002afa:	8c02      	ldrh	r2, [r0, #32]
 8002afc:	f022 0210 	bic.w	r2, r2, #16
 8002b00:	0412      	lsls	r2, r2, #16
 8002b02:	0c12      	lsrs	r2, r2, #16
 8002b04:	8402      	strh	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002b06:	8b03      	ldrh	r3, [r0, #24]
  tmpccer = TIMx->CCER;
 8002b08:	8c02      	ldrh	r2, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8002b0a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002b0e:	051b      	lsls	r3, r3, #20
 8002b10:	0d1b      	lsrs	r3, r3, #20
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8002b12:	b292      	uxth	r2, r2
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8002b14:	ea43 330c 	orr.w	r3, r3, ip, lsl #12
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8002b18:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8002b1c:	b29b      	uxth	r3, r3
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8002b1e:	f042 0210 	orr.w	r2, r2, #16
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8002b22:	ea43 2707 	orr.w	r7, r3, r7, lsl #8

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8002b26:	ea42 1606 	orr.w	r6, r2, r6, lsl #4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8002b2a:	8307      	strh	r7, [r0, #24]
  TIMx->CCER = tmpccer;
 8002b2c:	8406      	strh	r6, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
 8002b2e:	8b03      	ldrh	r3, [r0, #24]
 8002b30:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8002b34:	041b      	lsls	r3, r3, #16
 8002b36:	0c1b      	lsrs	r3, r3, #16
 8002b38:	8303      	strh	r3, [r0, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8002b3a:	8b03      	ldrh	r3, [r0, #24]
 8002b3c:	b29b      	uxth	r3, r3
 8002b3e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8002b42:	b289      	uxth	r1, r1
 8002b44:	8301      	strh	r1, [r0, #24]
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8002b46:	bcf0      	pop	{r4, r5, r6, r7}
 8002b48:	4770      	bx	lr
 8002b4a:	bf00      	nop

08002b4c <TIM_GetCapture1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 8002b4c:	6b40      	ldr	r0, [r0, #52]	; 0x34
}
 8002b4e:	4770      	bx	lr

08002b50 <TIM_GetCapture2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 8002b50:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 8002b52:	4770      	bx	lr

08002b54 <TIM_GetCapture3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 

  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 8002b54:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 8002b56:	4770      	bx	lr

08002b58 <TIM_GetCapture4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 8002b58:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 8002b5a:	4770      	bx	lr

08002b5c <TIM_SetIC1Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
 8002b5c:	8b03      	ldrh	r3, [r0, #24]
 8002b5e:	f023 030c 	bic.w	r3, r3, #12
 8002b62:	041b      	lsls	r3, r3, #16
 8002b64:	0c1b      	lsrs	r3, r3, #16
 8002b66:	8303      	strh	r3, [r0, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8002b68:	8b03      	ldrh	r3, [r0, #24]
 8002b6a:	b29b      	uxth	r3, r3
 8002b6c:	4319      	orrs	r1, r3
 8002b6e:	8301      	strh	r1, [r0, #24]
 8002b70:	4770      	bx	lr
 8002b72:	bf00      	nop

08002b74 <TIM_SetIC2Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
 8002b74:	8b03      	ldrh	r3, [r0, #24]
 8002b76:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8002b7a:	041b      	lsls	r3, r3, #16
 8002b7c:	0c1b      	lsrs	r3, r3, #16
 8002b7e:	8303      	strh	r3, [r0, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8002b80:	8b03      	ldrh	r3, [r0, #24]
 8002b82:	b29b      	uxth	r3, r3
 8002b84:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8002b88:	b28b      	uxth	r3, r1
 8002b8a:	8303      	strh	r3, [r0, #24]
 8002b8c:	4770      	bx	lr
 8002b8e:	bf00      	nop

08002b90 <TIM_SetIC3Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 8002b90:	8b83      	ldrh	r3, [r0, #28]
 8002b92:	f023 030c 	bic.w	r3, r3, #12
 8002b96:	041b      	lsls	r3, r3, #16
 8002b98:	0c1b      	lsrs	r3, r3, #16
 8002b9a:	8383      	strh	r3, [r0, #28]

  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 8002b9c:	8b83      	ldrh	r3, [r0, #28]
 8002b9e:	b29b      	uxth	r3, r3
 8002ba0:	4319      	orrs	r1, r3
 8002ba2:	8381      	strh	r1, [r0, #28]
 8002ba4:	4770      	bx	lr
 8002ba6:	bf00      	nop

08002ba8 <TIM_SetIC4Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 8002ba8:	8b83      	ldrh	r3, [r0, #28]
 8002baa:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8002bae:	041b      	lsls	r3, r3, #16
 8002bb0:	0c1b      	lsrs	r3, r3, #16
 8002bb2:	8383      	strh	r3, [r0, #28]

  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 8002bb4:	8b83      	ldrh	r3, [r0, #28]
 8002bb6:	b29b      	uxth	r3, r3
 8002bb8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8002bbc:	b28b      	uxth	r3, r1
 8002bbe:	8383      	strh	r3, [r0, #28]
 8002bc0:	4770      	bx	lr
 8002bc2:	bf00      	nop

08002bc4 <TIM_BDTRConfig>:
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8002bc4:	f8b1 c002 	ldrh.w	ip, [r1, #2]
 8002bc8:	880b      	ldrh	r3, [r1, #0]
 8002bca:	898a      	ldrh	r2, [r1, #12]
  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval None
  */
void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
{
 8002bcc:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8002bce:	888f      	ldrh	r7, [r1, #4]
 8002bd0:	88ce      	ldrh	r6, [r1, #6]
 8002bd2:	890d      	ldrh	r5, [r1, #8]
 8002bd4:	894c      	ldrh	r4, [r1, #10]
 8002bd6:	ea4c 0303 	orr.w	r3, ip, r3
 8002bda:	433b      	orrs	r3, r7
 8002bdc:	4333      	orrs	r3, r6
 8002bde:	432b      	orrs	r3, r5
 8002be0:	4323      	orrs	r3, r4
 8002be2:	4313      	orrs	r3, r2
 8002be4:	b29b      	uxth	r3, r3
 8002be6:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
}
 8002bea:	bcf0      	pop	{r4, r5, r6, r7}
 8002bec:	4770      	bx	lr
 8002bee:	bf00      	nop

08002bf0 <TIM_BDTRStructInit>:
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 8002bf0:	2300      	movs	r3, #0
 8002bf2:	8003      	strh	r3, [r0, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 8002bf4:	8043      	strh	r3, [r0, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 8002bf6:	8083      	strh	r3, [r0, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 8002bf8:	80c3      	strh	r3, [r0, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 8002bfa:	8103      	strh	r3, [r0, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 8002bfc:	8143      	strh	r3, [r0, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 8002bfe:	8183      	strh	r3, [r0, #12]
 8002c00:	4770      	bx	lr
 8002c02:	bf00      	nop

08002c04 <TIM_CtrlPWMOutputs>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 8002c04:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002c08:	b921      	cbnz	r1, 8002c14 <TIM_CtrlPWMOutputs+0x10>
    TIMx->BDTR |= TIM_BDTR_MOE;
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 8002c0a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8002c0e:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 8002c12:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 8002c14:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8002c18:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8002c1c:	b29b      	uxth	r3, r3
 8002c1e:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 8002c22:	4770      	bx	lr

08002c24 <TIM_SelectCOM>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 8002c24:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002c26:	b929      	cbnz	r1, 8002c34 <TIM_SelectCOM+0x10>
    TIMx->CR2 |= TIM_CR2_CCUS;
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
 8002c28:	f023 0304 	bic.w	r3, r3, #4
 8002c2c:	041b      	lsls	r3, r3, #16
 8002c2e:	0c1b      	lsrs	r3, r3, #16
 8002c30:	8083      	strh	r3, [r0, #4]
 8002c32:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 8002c34:	b29b      	uxth	r3, r3
 8002c36:	f043 0304 	orr.w	r3, r3, #4
 8002c3a:	8083      	strh	r3, [r0, #4]
 8002c3c:	4770      	bx	lr
 8002c3e:	bf00      	nop

08002c40 <TIM_CCPreloadControl>:
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 8002c40:	8883      	ldrh	r3, [r0, #4]
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8002c42:	b929      	cbnz	r1, 8002c50 <TIM_CCPreloadControl+0x10>
    TIMx->CR2 |= TIM_CR2_CCPC;
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
 8002c44:	f023 0301 	bic.w	r3, r3, #1
 8002c48:	041b      	lsls	r3, r3, #16
 8002c4a:	0c1b      	lsrs	r3, r3, #16
 8002c4c:	8083      	strh	r3, [r0, #4]
 8002c4e:	4770      	bx	lr
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 8002c50:	b29b      	uxth	r3, r3
 8002c52:	f043 0301 	orr.w	r3, r3, #1
 8002c56:	8083      	strh	r3, [r0, #4]
 8002c58:	4770      	bx	lr
 8002c5a:	bf00      	nop

08002c5c <TIM_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8002c5c:	8983      	ldrh	r3, [r0, #12]
 8002c5e:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8002c60:	b91a      	cbnz	r2, 8002c6a <TIM_ITConfig+0xe>
    TIMx->DIER |= TIM_IT;
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 8002c62:	ea23 0101 	bic.w	r1, r3, r1
 8002c66:	8181      	strh	r1, [r0, #12]
 8002c68:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8002c6a:	4319      	orrs	r1, r3
 8002c6c:	8181      	strh	r1, [r0, #12]
 8002c6e:	4770      	bx	lr

08002c70 <TIM_GenerateEvent>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
 
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 8002c70:	8281      	strh	r1, [r0, #20]
 8002c72:	4770      	bx	lr

08002c74 <TIM_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));

  
  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
 8002c74:	8a03      	ldrh	r3, [r0, #16]
 8002c76:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8002c78:	bf0c      	ite	eq
 8002c7a:	2000      	moveq	r0, #0
 8002c7c:	2001      	movne	r0, #1
 8002c7e:	4770      	bx	lr

08002c80 <TIM_ClearFlag>:
{  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 8002c80:	43c9      	mvns	r1, r1
 8002c82:	b289      	uxth	r1, r1
 8002c84:	8201      	strh	r1, [r0, #16]
 8002c86:	4770      	bx	lr

08002c88 <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8002c88:	8a03      	ldrh	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 8002c8a:	8982      	ldrh	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8002c8c:	ea11 0003 	ands.w	r0, r1, r3
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
 8002c90:	b292      	uxth	r2, r2
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8002c92:	d003      	beq.n	8002c9c <TIM_GetITStatus+0x14>
 8002c94:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 8002c96:	bf0c      	ite	eq
 8002c98:	2000      	moveq	r0, #0
 8002c9a:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8002c9c:	4770      	bx	lr
 8002c9e:	bf00      	nop

08002ca0 <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8002ca0:	43c9      	mvns	r1, r1
 8002ca2:	b289      	uxth	r1, r1
 8002ca4:	8201      	strh	r1, [r0, #16]
 8002ca6:	4770      	bx	lr

08002ca8 <TIM_DMAConfig>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));

  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 8002ca8:	430a      	orrs	r2, r1
 8002caa:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
 8002cae:	4770      	bx	lr

08002cb0 <TIM_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 8002cb0:	8983      	ldrh	r3, [r0, #12]
 8002cb2:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8002cb4:	b91a      	cbnz	r2, 8002cbe <TIM_DMACmd+0xe>
    TIMx->DIER |= TIM_DMASource; 
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 8002cb6:	ea23 0101 	bic.w	r1, r3, r1
 8002cba:	8181      	strh	r1, [r0, #12]
 8002cbc:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 8002cbe:	4319      	orrs	r1, r3
 8002cc0:	8181      	strh	r1, [r0, #12]
 8002cc2:	4770      	bx	lr

08002cc4 <TIM_SelectCCDMA>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 8002cc4:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002cc6:	b929      	cbnz	r1, 8002cd4 <TIM_SelectCCDMA+0x10>
    TIMx->CR2 |= TIM_CR2_CCDS;
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
 8002cc8:	f023 0308 	bic.w	r3, r3, #8
 8002ccc:	041b      	lsls	r3, r3, #16
 8002cce:	0c1b      	lsrs	r3, r3, #16
 8002cd0:	8083      	strh	r3, [r0, #4]
 8002cd2:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 8002cd4:	b29b      	uxth	r3, r3
 8002cd6:	f043 0308 	orr.w	r3, r3, #8
 8002cda:	8083      	strh	r3, [r0, #4]
 8002cdc:	4770      	bx	lr
 8002cde:	bf00      	nop

08002ce0 <TIM_InternalClockConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
 8002ce0:	8903      	ldrh	r3, [r0, #8]
 8002ce2:	f023 0307 	bic.w	r3, r3, #7
 8002ce6:	041b      	lsls	r3, r3, #16
 8002ce8:	0c1b      	lsrs	r3, r3, #16
 8002cea:	8103      	strh	r3, [r0, #8]
 8002cec:	4770      	bx	lr
 8002cee:	bf00      	nop

08002cf0 <TIM_ITRxExternalClockConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8002cf0:	8903      	ldrh	r3, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8002cf2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002cf6:	041b      	lsls	r3, r3, #16
 8002cf8:	0c1b      	lsrs	r3, r3, #16

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 8002cfa:	4319      	orrs	r1, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8002cfc:	8101      	strh	r1, [r0, #8]

  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);

  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8002cfe:	8903      	ldrh	r3, [r0, #8]
 8002d00:	b29b      	uxth	r3, r3
 8002d02:	f043 0307 	orr.w	r3, r3, #7
 8002d06:	8103      	strh	r3, [r0, #8]
 8002d08:	4770      	bx	lr
 8002d0a:	bf00      	nop

08002d0c <TIM_TIxExternalClockConfig>:
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 8002d0c:	2960      	cmp	r1, #96	; 0x60
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 8002d0e:	b430      	push	{r4, r5}
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8002d10:	8c04      	ldrh	r4, [r0, #32]
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 8002d12:	d024      	beq.n	8002d5e <TIM_TIxExternalClockConfig+0x52>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8002d14:	f024 0401 	bic.w	r4, r4, #1
 8002d18:	0424      	lsls	r4, r4, #16
 8002d1a:	0c24      	lsrs	r4, r4, #16
 8002d1c:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002d1e:	8b05      	ldrh	r5, [r0, #24]
  tmpccer = TIMx->CCER;
 8002d20:	8c04      	ldrh	r4, [r0, #32]
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;
 8002d22:	b2ad      	uxth	r5, r5
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
 8002d24:	f025 05f3 	bic.w	r5, r5, #243	; 0xf3
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8002d28:	b2a4      	uxth	r4, r4

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002d2a:	f045 0501 	orr.w	r5, r5, #1

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002d2e:	f024 040a 	bic.w	r4, r4, #10
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002d32:	ea45 1303 	orr.w	r3, r5, r3, lsl #4

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8002d36:	f044 0401 	orr.w	r4, r4, #1
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002d3a:	b29b      	uxth	r3, r3

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8002d3c:	4322      	orrs	r2, r4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8002d3e:	8303      	strh	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8002d40:	8402      	strh	r2, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8002d42:	8903      	ldrh	r3, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8002d44:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002d48:	041b      	lsls	r3, r3, #16
 8002d4a:	0c1b      	lsrs	r3, r3, #16

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 8002d4c:	430b      	orrs	r3, r1

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8002d4e:	8103      	strh	r3, [r0, #8]
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8002d50:	8903      	ldrh	r3, [r0, #8]
 8002d52:	b29b      	uxth	r3, r3
 8002d54:	f043 0307 	orr.w	r3, r3, #7
 8002d58:	8103      	strh	r3, [r0, #8]
}
 8002d5a:	bc30      	pop	{r4, r5}
 8002d5c:	4770      	bx	lr
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8002d5e:	f024 0410 	bic.w	r4, r4, #16
 8002d62:	0424      	lsls	r4, r4, #16
 8002d64:	0c24      	lsrs	r4, r4, #16
 8002d66:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002d68:	8b04      	ldrh	r4, [r0, #24]
  tmpccer = TIMx->CCER;
 8002d6a:	8c05      	ldrh	r5, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8002d6c:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 8002d70:	0524      	lsls	r4, r4, #20
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8002d72:	b2ad      	uxth	r5, r5
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8002d74:	0d24      	lsrs	r4, r4, #20
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8002d76:	f025 05a0 	bic.w	r5, r5, #160	; 0xa0
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8002d7a:	f444 7480 	orr.w	r4, r4, #256	; 0x100
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8002d7e:	f045 0510 	orr.w	r5, r5, #16
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8002d82:	ea44 3303 	orr.w	r3, r4, r3, lsl #12

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8002d86:	ea45 1202 	orr.w	r2, r5, r2, lsl #4
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8002d8a:	b29b      	uxth	r3, r3

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8002d8c:	b292      	uxth	r2, r2

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8002d8e:	8303      	strh	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8002d90:	8402      	strh	r2, [r0, #32]
 8002d92:	e7d6      	b.n	8002d42 <TIM_TIxExternalClockConfig+0x36>

08002d94 <TIM_ETRClockMode1Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8002d94:	b410      	push	{r4}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 8002d96:	8904      	ldrh	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8002d98:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8002d9c:	b2e4      	uxtb	r4, r4

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8002d9e:	4323      	orrs	r3, r4
 8002da0:	b29b      	uxth	r3, r3
 8002da2:	4319      	orrs	r1, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8002da4:	8101      	strh	r1, [r0, #8]
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8002da6:	8903      	ldrh	r3, [r0, #8]
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
  tmpsmcr |= TIM_TS_ETRF;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
}
 8002da8:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;

  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8002dac:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 8002db0:	041b      	lsls	r3, r3, #16
 8002db2:	0c1b      	lsrs	r3, r3, #16
  tmpsmcr |= TIM_TS_ETRF;
 8002db4:	f043 0377 	orr.w	r3, r3, #119	; 0x77

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8002db8:	8103      	strh	r3, [r0, #8]
}
 8002dba:	4770      	bx	lr

08002dbc <TIM_ETRClockMode2Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8002dbc:	b410      	push	{r4}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 8002dbe:	8904      	ldrh	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8002dc0:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8002dc4:	b2e4      	uxtb	r4, r4

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8002dc6:	4323      	orrs	r3, r4
 8002dc8:	b29b      	uxth	r3, r3
 8002dca:	4319      	orrs	r1, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8002dcc:	8101      	strh	r1, [r0, #8]

  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);

  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 8002dce:	8903      	ldrh	r3, [r0, #8]
}
 8002dd0:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);

  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 8002dd4:	b29b      	uxth	r3, r3
 8002dd6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002dda:	8103      	strh	r3, [r0, #8]
}
 8002ddc:	4770      	bx	lr
 8002dde:	bf00      	nop

08002de0 <TIM_SelectInputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8002de0:	8903      	ldrh	r3, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8002de2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002de6:	041b      	lsls	r3, r3, #16
 8002de8:	0c1b      	lsrs	r3, r3, #16

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 8002dea:	4319      	orrs	r1, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8002dec:	8101      	strh	r1, [r0, #8]
 8002dee:	4770      	bx	lr

08002df0 <TIM_SelectOutputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
 8002df0:	8883      	ldrh	r3, [r0, #4]
 8002df2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002df6:	041b      	lsls	r3, r3, #16
 8002df8:	0c1b      	lsrs	r3, r3, #16
 8002dfa:	8083      	strh	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 8002dfc:	8883      	ldrh	r3, [r0, #4]
 8002dfe:	b29b      	uxth	r3, r3
 8002e00:	4319      	orrs	r1, r3
 8002e02:	8081      	strh	r1, [r0, #4]
 8002e04:	4770      	bx	lr
 8002e06:	bf00      	nop

08002e08 <TIM_SelectSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));

  /* Reset the SMS Bits */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
 8002e08:	8903      	ldrh	r3, [r0, #8]
 8002e0a:	f023 0307 	bic.w	r3, r3, #7
 8002e0e:	041b      	lsls	r3, r3, #16
 8002e10:	0c1b      	lsrs	r3, r3, #16
 8002e12:	8103      	strh	r3, [r0, #8]

  /* Select the Slave Mode */
  TIMx->SMCR |= TIM_SlaveMode;
 8002e14:	8903      	ldrh	r3, [r0, #8]
 8002e16:	b29b      	uxth	r3, r3
 8002e18:	4319      	orrs	r1, r3
 8002e1a:	8101      	strh	r1, [r0, #8]
 8002e1c:	4770      	bx	lr
 8002e1e:	bf00      	nop

08002e20 <TIM_SelectMasterSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));

  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
 8002e20:	8903      	ldrh	r3, [r0, #8]
 8002e22:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002e26:	041b      	lsls	r3, r3, #16
 8002e28:	0c1b      	lsrs	r3, r3, #16
 8002e2a:	8103      	strh	r3, [r0, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 8002e2c:	8903      	ldrh	r3, [r0, #8]
 8002e2e:	b29b      	uxth	r3, r3
 8002e30:	4319      	orrs	r1, r3
 8002e32:	8101      	strh	r1, [r0, #8]
 8002e34:	4770      	bx	lr
 8002e36:	bf00      	nop

08002e38 <TIM_ETRConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                   uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8002e38:	b410      	push	{r4}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 8002e3a:	8904      	ldrh	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8002e3c:	b2e4      	uxtb	r4, r4

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8002e3e:	4321      	orrs	r1, r4
 8002e40:	430a      	orrs	r2, r1
 8002e42:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8002e46:	b29c      	uxth	r4, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8002e48:	8104      	strh	r4, [r0, #8]
}
 8002e4a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002e4e:	4770      	bx	lr

08002e50 <TIM_EncoderInterfaceConfig>:
  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 8002e50:	b470      	push	{r4, r5, r6}
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8002e52:	8905      	ldrh	r5, [r0, #8]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8002e54:	8b04      	ldrh	r4, [r0, #24]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002e56:	8c06      	ldrh	r6, [r0, #32]
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 8002e58:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 8002e5c:	f024 0403 	bic.w	r4, r4, #3

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002e60:	b2b6      	uxth	r6, r6
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
 8002e62:	f026 0622 	bic.w	r6, r6, #34	; 0x22

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 8002e66:	f025 0507 	bic.w	r5, r5, #7
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 8002e6a:	0424      	lsls	r4, r4, #16
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 8002e6c:	4332      	orrs	r2, r6

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 8002e6e:	042d      	lsls	r5, r5, #16
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 8002e70:	0c24      	lsrs	r4, r4, #16

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 8002e72:	0c2d      	lsrs	r5, r5, #16
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 8002e74:	f444 7480 	orr.w	r4, r4, #256	; 0x100

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 8002e78:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
  tmpsmcr |= TIM_EncoderMode;
 8002e7c:	4329      	orrs	r1, r5

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 8002e7e:	f044 0401 	orr.w	r4, r4, #1

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 8002e82:	b29e      	uxth	r6, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8002e84:	8101      	strh	r1, [r0, #8]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8002e86:	8304      	strh	r4, [r0, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8002e88:	8406      	strh	r6, [r0, #32]
}
 8002e8a:	bc70      	pop	{r4, r5, r6}
 8002e8c:	4770      	bx	lr
 8002e8e:	bf00      	nop

08002e90 <TIM_SelectHallSensor>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 8002e90:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002e92:	b929      	cbnz	r1, 8002ea0 <TIM_SelectHallSensor+0x10>
    TIMx->CR2 |= TIM_CR2_TI1S;
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
 8002e94:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002e98:	041b      	lsls	r3, r3, #16
 8002e9a:	0c1b      	lsrs	r3, r3, #16
 8002e9c:	8083      	strh	r3, [r0, #4]
 8002e9e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 8002ea0:	b29b      	uxth	r3, r3
 8002ea2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002ea6:	8083      	strh	r3, [r0, #4]
 8002ea8:	4770      	bx	lr
 8002eaa:	bf00      	nop

08002eac <TIM_RemapConfig>:
 /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_REMAP(TIM_Remap));

  /* Set the Timer remapping configuration */
  TIMx->OR =  TIM_Remap;
 8002eac:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
 8002eb0:	4770      	bx	lr
 8002eb2:	bf00      	nop

08002eb4 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8002eb4:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8002eb8:	4b02      	ldr	r3, [pc, #8]	; (8002ec4 <NVIC_PriorityGroupConfig+0x10>)
 8002eba:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 8002ebe:	60d8      	str	r0, [r3, #12]
 8002ec0:	4770      	bx	lr
 8002ec2:	bf00      	nop
 8002ec4:	e000ed00 	.word	0xe000ed00

08002ec8 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8002ec8:	78c3      	ldrb	r3, [r0, #3]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8002eca:	b4f0      	push	{r4, r5, r6, r7}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8002ecc:	b963      	cbnz	r3, 8002ee8 <NVIC_Init+0x20>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002ece:	7803      	ldrb	r3, [r0, #0]
 8002ed0:	4a19      	ldr	r2, [pc, #100]	; (8002f38 <NVIC_Init+0x70>)
 8002ed2:	0959      	lsrs	r1, r3, #5
 8002ed4:	3120      	adds	r1, #32
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002ed6:	f003 031f 	and.w	r3, r3, #31
 8002eda:	2001      	movs	r0, #1
 8002edc:	fa00 f303 	lsl.w	r3, r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002ee0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8002ee4:	bcf0      	pop	{r4, r5, r6, r7}
 8002ee6:	4770      	bx	lr
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8002ee8:	4b14      	ldr	r3, [pc, #80]	; (8002f3c <NVIC_Init+0x74>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8002eea:	7847      	ldrb	r7, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8002eec:	68da      	ldr	r2, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8002eee:	7885      	ldrb	r5, [r0, #2]
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8002ef0:	7803      	ldrb	r3, [r0, #0]
 8002ef2:	4911      	ldr	r1, [pc, #68]	; (8002f38 <NVIC_Init+0x70>)
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8002ef4:	43d2      	mvns	r2, r2
 8002ef6:	f3c2 2202 	ubfx	r2, r2, #8, #3
    tmppre = (0x4 - tmppriority);
 8002efa:	f1c2 0404 	rsb	r4, r2, #4
    tmpsub = tmpsub >> tmppriority;
 8002efe:	260f      	movs	r6, #15

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8002f00:	b2e4      	uxtb	r4, r4
 8002f02:	fa07 f404 	lsl.w	r4, r7, r4
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 8002f06:	fa46 f202 	asr.w	r2, r6, r2

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8002f0a:	b2e4      	uxtb	r4, r4
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8002f0c:	402a      	ands	r2, r5
 8002f0e:	4322      	orrs	r2, r4
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8002f10:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8002f14:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
 8002f18:	0112      	lsls	r2, r2, #4
 8002f1a:	b2d2      	uxtb	r2, r2
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8002f1c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002f20:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002f22:	2001      	movs	r0, #1
 8002f24:	f003 021f 	and.w	r2, r3, #31
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002f28:	095b      	lsrs	r3, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002f2a:	fa00 f202 	lsl.w	r2, r0, r2
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002f2e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8002f32:	bcf0      	pop	{r4, r5, r6, r7}
 8002f34:	4770      	bx	lr
 8002f36:	bf00      	nop
 8002f38:	e000e100 	.word	0xe000e100
 8002f3c:	e000ed00 	.word	0xe000ed00

08002f40 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8002f40:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8002f44:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8002f48:	4b01      	ldr	r3, [pc, #4]	; (8002f50 <NVIC_SetVectorTable+0x10>)
 8002f4a:	4308      	orrs	r0, r1
 8002f4c:	6098      	str	r0, [r3, #8]
 8002f4e:	4770      	bx	lr
 8002f50:	e000ed00 	.word	0xe000ed00

08002f54 <NVIC_SystemLPConfig>:
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8002f54:	4b04      	ldr	r3, [pc, #16]	; (8002f68 <NVIC_SystemLPConfig+0x14>)
 8002f56:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8002f58:	b919      	cbnz	r1, 8002f62 <NVIC_SystemLPConfig+0xe>
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8002f5a:	ea22 0000 	bic.w	r0, r2, r0
 8002f5e:	6118      	str	r0, [r3, #16]
 8002f60:	4770      	bx	lr
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8002f62:	4310      	orrs	r0, r2
 8002f64:	6118      	str	r0, [r3, #16]
 8002f66:	4770      	bx	lr
 8002f68:	e000ed00 	.word	0xe000ed00

08002f6c <SysTick_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8002f6c:	4b04      	ldr	r3, [pc, #16]	; (8002f80 <SysTick_CLKSourceConfig+0x14>)
 8002f6e:	681a      	ldr	r2, [r3, #0]
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8002f70:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8002f72:	bf0c      	ite	eq
 8002f74:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8002f78:	f022 0204 	bicne.w	r2, r2, #4
 8002f7c:	601a      	str	r2, [r3, #0]
 8002f7e:	4770      	bx	lr
 8002f80:	e000e010 	.word	0xe000e010

08002f84 <Delay>:
  * @brief  Inserts a delay time.
  * @param  nTime: specifies the delay time length, in 10 ms.
  * @retval None
  */
void Delay(__IO uint32_t nTime)
{
 8002f84:	b082      	sub	sp, #8
  TimingDelay = nTime;
 8002f86:	4b04      	ldr	r3, [pc, #16]	; (8002f98 <Delay+0x14>)
  * @brief  Inserts a delay time.
  * @param  nTime: specifies the delay time length, in 10 ms.
  * @retval None
  */
void Delay(__IO uint32_t nTime)
{
 8002f88:	9001      	str	r0, [sp, #4]
  TimingDelay = nTime;
 8002f8a:	9a01      	ldr	r2, [sp, #4]
 8002f8c:	601a      	str	r2, [r3, #0]

  while(TimingDelay != 0);
 8002f8e:	681a      	ldr	r2, [r3, #0]
 8002f90:	2a00      	cmp	r2, #0
 8002f92:	d1fc      	bne.n	8002f8e <Delay+0xa>
}
 8002f94:	b002      	add	sp, #8
 8002f96:	4770      	bx	lr
 8002f98:	200005f0 	.word	0x200005f0

08002f9c <Demo_Exec>:
  * @brief  Execute the demo application.
  * @param  None
  * @retval None
  */
static void Demo_Exec(void)
{
 8002f9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  LSM303DLHCAcc_InitTypeDef LSM303DLHCAcc_InitStructure;
  LSM303DLHCAcc_FilterConfigTypeDef LSM303DLHCFilter_InitStructure;
  
  RCC_ClocksTypeDef RCC_Clocks;
  uint8_t togglecounter = 0x00;
 8002fa0:	2500      	movs	r5, #0
  * @brief  Execute the demo application.
  * @param  None
  * @retval None
  */
static void Demo_Exec(void)
{
 8002fa2:	b094      	sub	sp, #80	; 0x50
  RCC_ClocksTypeDef RCC_Clocks;
  uint8_t togglecounter = 0x00;
  
  while(1)
  {
    DemoEnterCondition = 0x00;
 8002fa4:	2400      	movs	r4, #0
    
    /* Reset UserButton_Pressed variable */
    UserButtonPressed = 0x00;
 8002fa6:	4eb0      	ldr	r6, [pc, #704]	; (8003268 <Demo_Exec+0x2cc>)
  RCC_ClocksTypeDef RCC_Clocks;
  uint8_t togglecounter = 0x00;
  
  while(1)
  {
    DemoEnterCondition = 0x00;
 8002fa8:	f8df 82fc 	ldr.w	r8, [pc, #764]	; 80032a8 <Demo_Exec+0x30c>
    
    /* Reset UserButton_Pressed variable */
    UserButtonPressed = 0x00;
    
    /* Initialize LEDs to be managed by GPIO */
    STM_EVAL_LEDInit(LED4);
 8002fac:	4620      	mov	r0, r4
  RCC_ClocksTypeDef RCC_Clocks;
  uint8_t togglecounter = 0x00;
  
  while(1)
  {
    DemoEnterCondition = 0x00;
 8002fae:	f888 4000 	strb.w	r4, [r8]
    
    /* Reset UserButton_Pressed variable */
    UserButtonPressed = 0x00;
 8002fb2:	7034      	strb	r4, [r6, #0]
    
    /* Initialize LEDs to be managed by GPIO */
    STM_EVAL_LEDInit(LED4);
 8002fb4:	f000 fa2a 	bl	800340c <STM_EVAL_LEDInit>
    STM_EVAL_LEDInit(LED3);
 8002fb8:	2001      	movs	r0, #1
 8002fba:	f000 fa27 	bl	800340c <STM_EVAL_LEDInit>
    STM_EVAL_LEDInit(LED5);
 8002fbe:	2002      	movs	r0, #2
 8002fc0:	f000 fa24 	bl	800340c <STM_EVAL_LEDInit>
    STM_EVAL_LEDInit(LED6);
 8002fc4:	2003      	movs	r0, #3
 8002fc6:	f000 fa21 	bl	800340c <STM_EVAL_LEDInit>
    
    /* SysTick end of count event each 10ms */
    RCC_GetClocksFreq(&RCC_Clocks);
 8002fca:	a80b      	add	r0, sp, #44	; 0x2c
 8002fcc:	f7fe fc9e 	bl	800190c <RCC_GetClocksFreq>
    SysTick_Config(RCC_Clocks.HCLK_Frequency / 100);  
 8002fd0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002fd2:	2264      	movs	r2, #100	; 0x64
 8002fd4:	fbb3 f2f2 	udiv	r2, r3, r2
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 8002fd8:	3a01      	subs	r2, #1
 8002fda:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
 8002fde:	4637      	mov	r7, r6
 8002fe0:	d208      	bcs.n	8002ff4 <Demo_Exec+0x58>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 8002fe2:	4ba2      	ldr	r3, [pc, #648]	; (800326c <Demo_Exec+0x2d0>)
 8002fe4:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8002fe6:	4aa2      	ldr	r2, [pc, #648]	; (8003270 <Demo_Exec+0x2d4>)
 8002fe8:	21f0      	movs	r1, #240	; 0xf0
 8002fea:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002fee:	2207      	movs	r2, #7
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8002ff0:	609c      	str	r4, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002ff2:	601a      	str	r2, [r3, #0]
    
    /* Turn OFF all LEDs */
    STM_EVAL_LEDOff(LED4);
 8002ff4:	2000      	movs	r0, #0
 8002ff6:	f000 fa3b 	bl	8003470 <STM_EVAL_LEDOff>
    STM_EVAL_LEDOff(LED3);
 8002ffa:	2001      	movs	r0, #1
 8002ffc:	f000 fa38 	bl	8003470 <STM_EVAL_LEDOff>
    STM_EVAL_LEDOff(LED5);
 8003000:	2002      	movs	r0, #2
 8003002:	f000 fa35 	bl	8003470 <STM_EVAL_LEDOff>
    STM_EVAL_LEDOff(LED6);
 8003006:	2003      	movs	r0, #3
 8003008:	f000 fa32 	bl	8003470 <STM_EVAL_LEDOff>
    
    /* Waiting User Button is pressed */
    while (UserButtonPressed == 0x00)
 800300c:	783b      	ldrb	r3, [r7, #0]
 800300e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8003012:	bb73      	cbnz	r3, 8003072 <Demo_Exec+0xd6>
    {
      /* Toggle LED4 */
      STM_EVAL_LEDToggle(LED4);
 8003014:	f000 fa38 	bl	8003488 <STM_EVAL_LEDToggle>
      Delay(10);
 8003018:	200a      	movs	r0, #10
 800301a:	f7ff ffb3 	bl	8002f84 <Delay>
      /* Toggle LED4 */
      STM_EVAL_LEDToggle(LED3);
 800301e:	2001      	movs	r0, #1
 8003020:	f000 fa32 	bl	8003488 <STM_EVAL_LEDToggle>
      Delay(10);
 8003024:	200a      	movs	r0, #10
 8003026:	f7ff ffad 	bl	8002f84 <Delay>
      /* Toggle LED4 */
      STM_EVAL_LEDToggle(LED5);
 800302a:	2002      	movs	r0, #2
 800302c:	f000 fa2c 	bl	8003488 <STM_EVAL_LEDToggle>
      Delay(10);
 8003030:	200a      	movs	r0, #10
 8003032:	f7ff ffa7 	bl	8002f84 <Delay>
      /* Toggle LED4 */
      STM_EVAL_LEDToggle(LED6);
      Delay(10);
      togglecounter ++;
 8003036:	3501      	adds	r5, #1
      Delay(10);
      /* Toggle LED4 */
      STM_EVAL_LEDToggle(LED5);
      Delay(10);
      /* Toggle LED4 */
      STM_EVAL_LEDToggle(LED6);
 8003038:	2003      	movs	r0, #3
 800303a:	f000 fa25 	bl	8003488 <STM_EVAL_LEDToggle>
      Delay(10);
      togglecounter ++;
 800303e:	b2ed      	uxtb	r5, r5
      /* Toggle LED4 */
      STM_EVAL_LEDToggle(LED5);
      Delay(10);
      /* Toggle LED4 */
      STM_EVAL_LEDToggle(LED6);
      Delay(10);
 8003040:	200a      	movs	r0, #10
 8003042:	f7ff ff9f 	bl	8002f84 <Delay>
      togglecounter ++;
      if (togglecounter == 0x10)
 8003046:	2d10      	cmp	r5, #16
 8003048:	d1e0      	bne.n	800300c <Demo_Exec+0x70>
      {
        togglecounter = 0x00;
        while (togglecounter < 0x10)
        {
          STM_EVAL_LEDToggle(LED4);
 800304a:	2000      	movs	r0, #0
 800304c:	f000 fa1c 	bl	8003488 <STM_EVAL_LEDToggle>
          STM_EVAL_LEDToggle(LED3);
 8003050:	2001      	movs	r0, #1
 8003052:	f000 fa19 	bl	8003488 <STM_EVAL_LEDToggle>
          STM_EVAL_LEDToggle(LED5);
 8003056:	2002      	movs	r0, #2
 8003058:	f000 fa16 	bl	8003488 <STM_EVAL_LEDToggle>
          STM_EVAL_LEDToggle(LED6);
 800305c:	2003      	movs	r0, #3
 800305e:	f000 fa13 	bl	8003488 <STM_EVAL_LEDToggle>
 8003062:	3d01      	subs	r5, #1
          Delay(10);
 8003064:	200a      	movs	r0, #10
 8003066:	f7ff ff8d 	bl	8002f84 <Delay>
      Delay(10);
      togglecounter ++;
      if (togglecounter == 0x10)
      {
        togglecounter = 0x00;
        while (togglecounter < 0x10)
 800306a:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 800306e:	d1ec      	bne.n	800304a <Demo_Exec+0xae>
 8003070:	e7cc      	b.n	800300c <Demo_Exec+0x70>
        togglecounter = 0x00;
      }
    }
    
    /* Waiting User Button is Released */
    while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_SET)
 8003072:	2000      	movs	r0, #0
 8003074:	f000 fa54 	bl	8003520 <STM_EVAL_PBGetState>
 8003078:	2801      	cmp	r0, #1
 800307a:	d0fa      	beq.n	8003072 <Demo_Exec+0xd6>
    {}
    UserButtonPressed = 0x00;
 800307c:	2400      	movs	r4, #0
  TIM_OCInitTypeDef  TIM_OCInitStructure;
  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
  
  /* --------------------------- System Clocks Configuration -----------------*/
  /* TIM4 clock enable */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
 800307e:	2004      	movs	r0, #4
 8003080:	2101      	movs	r1, #1
    }
    
    /* Waiting User Button is Released */
    while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_SET)
    {}
    UserButtonPressed = 0x00;
 8003082:	7034      	strb	r4, [r6, #0]
  TIM_OCInitTypeDef  TIM_OCInitStructure;
  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
  
  /* --------------------------- System Clocks Configuration -----------------*/
  /* TIM4 clock enable */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
 8003084:	f7fe fd1c 	bl	8001ac0 <RCC_APB1PeriphClockCmd>
  
  /* GPIOD clock enable */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8003088:	2008      	movs	r0, #8
 800308a:	2101      	movs	r1, #1
 800308c:	f7fe fcf4 	bl	8001a78 <RCC_AHB1PeriphClockCmd>

  /*-------------------------- GPIO Configuration ----------------------------*/
  /* GPIOD Configuration: Pins 12, 13, 14 and 15 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
 8003090:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003094:	2602      	movs	r6, #2
  /* GPIOD clock enable */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

  /*-------------------------- GPIO Configuration ----------------------------*/
  /* GPIOD Configuration: Pins 12, 13, 14 and 15 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
 8003096:	9306      	str	r3, [sp, #24]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 8003098:	4876      	ldr	r0, [pc, #472]	; (8003274 <Demo_Exec+0x2d8>)
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

  /*-------------------------- GPIO Configuration ----------------------------*/
  /* GPIOD Configuration: Pins 12, 13, 14 and 15 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800309a:	f88d 601c 	strb.w	r6, [sp, #28]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 800309e:	2303      	movs	r3, #3
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 80030a0:	a906      	add	r1, sp, #24
  /* GPIOD Configuration: Pins 12, 13, 14 and 15 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80030a2:	f88d 301d 	strb.w	r3, [sp, #29]

  /*-------------------------- GPIO Configuration ----------------------------*/
  /* GPIOD Configuration: Pins 12, 13, 14 and 15 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80030a6:	f88d 401e 	strb.w	r4, [sp, #30]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80030aa:	f88d 401f 	strb.w	r4, [sp, #31]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 80030ae:	f7fe f845 	bl	800113c <GPIO_Init>

  /* Connect TIM4 pins to AF2 */  
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_TIM4);
 80030b2:	4632      	mov	r2, r6
 80030b4:	486f      	ldr	r0, [pc, #444]	; (8003274 <Demo_Exec+0x2d8>)
 80030b6:	210c      	movs	r1, #12
 80030b8:	f7fe f8de 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_TIM4); 
 80030bc:	4632      	mov	r2, r6
 80030be:	486d      	ldr	r0, [pc, #436]	; (8003274 <Demo_Exec+0x2d8>)
 80030c0:	210d      	movs	r1, #13
 80030c2:	f7fe f8d9 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_TIM4);
 80030c6:	4632      	mov	r2, r6
 80030c8:	486a      	ldr	r0, [pc, #424]	; (8003274 <Demo_Exec+0x2d8>)
 80030ca:	210e      	movs	r1, #14
 80030cc:	f7fe f8d4 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_TIM4); 
 80030d0:	4632      	mov	r2, r6
 80030d2:	4868      	ldr	r0, [pc, #416]	; (8003274 <Demo_Exec+0x2d8>)
 80030d4:	210f      	movs	r1, #15
 80030d6:	f7fe f8cf 	bl	8001278 <GPIO_PinAFConfig>
     based on this variable will be incorrect.    
  ----------------------------------------------------------------------- */ 
  
  
  /* Compute the prescaler value */
  PrescalerValue = (uint16_t) ((SystemCoreClock /2) / 2000) - 1;
 80030da:	4b67      	ldr	r3, [pc, #412]	; (8003278 <Demo_Exec+0x2dc>)
  /* Time base configuration */
  TIM_TimeBaseStructure.TIM_Period = TIM_ARR;
  TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 80030dc:	4867      	ldr	r0, [pc, #412]	; (800327c <Demo_Exec+0x2e0>)
     based on this variable will be incorrect.    
  ----------------------------------------------------------------------- */ 
  
  
  /* Compute the prescaler value */
  PrescalerValue = (uint16_t) ((SystemCoreClock /2) / 2000) - 1;
 80030de:	681a      	ldr	r2, [r3, #0]
  
  /* Time base configuration */
  TIM_TimeBaseStructure.TIM_Period = TIM_ARR;
  TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80030e0:	f8ad 4028 	strh.w	r4, [sp, #40]	; 0x28
     based on this variable will be incorrect.    
  ----------------------------------------------------------------------- */ 
  
  
  /* Compute the prescaler value */
  PrescalerValue = (uint16_t) ((SystemCoreClock /2) / 2000) - 1;
 80030e4:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
 80030e8:	fbb2 f3f3 	udiv	r3, r2, r3
 80030ec:	3b01      	subs	r3, #1
 80030ee:	4a64      	ldr	r2, [pc, #400]	; (8003280 <Demo_Exec+0x2e4>)
  
  /* Time base configuration */
  TIM_TimeBaseStructure.TIM_Period = TIM_ARR;
  TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80030f0:	f8ad 4022 	strh.w	r4, [sp, #34]	; 0x22
     based on this variable will be incorrect.    
  ----------------------------------------------------------------------- */ 
  
  
  /* Compute the prescaler value */
  PrescalerValue = (uint16_t) ((SystemCoreClock /2) / 2000) - 1;
 80030f4:	b29b      	uxth	r3, r3
 80030f6:	8013      	strh	r3, [r2, #0]
  /* Time base configuration */
  TIM_TimeBaseStructure.TIM_Period = TIM_ARR;
  TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 80030f8:	a908      	add	r1, sp, #32
  
  /* Compute the prescaler value */
  PrescalerValue = (uint16_t) ((SystemCoreClock /2) / 2000) - 1;
  
  /* Time base configuration */
  TIM_TimeBaseStructure.TIM_Period = TIM_ARR;
 80030fa:	f240 72cf 	movw	r2, #1999	; 0x7cf
 80030fe:	9209      	str	r2, [sp, #36]	; 0x24
  TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 8003100:	f8ad 3020 	strh.w	r3, [sp, #32]
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 8003104:	f7ff f8d4 	bl	80022b0 <TIM_TimeBaseInit>
  
  /* Enable TIM4 Preload register on ARR */
  TIM_ARRPreloadConfig(TIM4, ENABLE);
 8003108:	485c      	ldr	r0, [pc, #368]	; (800327c <Demo_Exec+0x2e0>)
 800310a:	2101      	movs	r1, #1
 800310c:	f7ff f95a 	bl	80023c4 <TIM_ARRPreloadConfig>
  
  /* TIM PWM1 Mode configuration: Channel */
  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8003110:	2360      	movs	r3, #96	; 0x60
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8003112:	2601      	movs	r6, #1
  
  /* Enable TIM4 Preload register on ARR */
  TIM_ARRPreloadConfig(TIM4, ENABLE);
  
  /* TIM PWM1 Mode configuration: Channel */
  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8003114:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStructure.TIM_Pulse = TIM_CCR;
  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
  
  /* Output Compare PWM1 Mode configuration: Channel1 */
  TIM_OC1Init(TIM4, &TIM_OCInitStructure);
 8003118:	4858      	ldr	r0, [pc, #352]	; (800327c <Demo_Exec+0x2e0>)
  
  /* TIM PWM1 Mode configuration: Channel */
  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStructure.TIM_Pulse = TIM_CCR;
  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 800311a:	f8ad 4048 	strh.w	r4, [sp, #72]	; 0x48
  TIM_ARRPreloadConfig(TIM4, ENABLE);
  
  /* TIM PWM1 Mode configuration: Channel */
  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStructure.TIM_Pulse = TIM_CCR;
 800311e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
  
  /* Output Compare PWM1 Mode configuration: Channel1 */
  TIM_OC1Init(TIM4, &TIM_OCInitStructure);
 8003122:	a90f      	add	r1, sp, #60	; 0x3c
  TIM_ARRPreloadConfig(TIM4, ENABLE);
  
  /* TIM PWM1 Mode configuration: Channel */
  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStructure.TIM_Pulse = TIM_CCR;
 8003124:	9311      	str	r3, [sp, #68]	; 0x44
  /* Enable TIM4 Preload register on ARR */
  TIM_ARRPreloadConfig(TIM4, ENABLE);
  
  /* TIM PWM1 Mode configuration: Channel */
  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8003126:	f8ad 603e 	strh.w	r6, [sp, #62]	; 0x3e
  TIM_OCInitStructure.TIM_Pulse = TIM_CCR;
  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
  
  /* Output Compare PWM1 Mode configuration: Channel1 */
  TIM_OC1Init(TIM4, &TIM_OCInitStructure);
 800312a:	f7ff f97f 	bl	800242c <TIM_OC1Init>
  TIM_CCxCmd(TIM4, TIM_Channel_1, DISABLE);
 800312e:	4622      	mov	r2, r4
 8003130:	4621      	mov	r1, r4
 8003132:	4852      	ldr	r0, [pc, #328]	; (800327c <Demo_Exec+0x2e0>)
 8003134:	f7ff fb86 	bl	8002844 <TIM_CCxCmd>
  
  TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
 8003138:	4850      	ldr	r0, [pc, #320]	; (800327c <Demo_Exec+0x2e0>)
 800313a:	2108      	movs	r1, #8
 800313c:	f7ff fad8 	bl	80026f0 <TIM_OC1PreloadConfig>
  
  /* Output Compare PWM1 Mode configuration: Channel2 */
  TIM_OC2Init(TIM4, &TIM_OCInitStructure);
 8003140:	484e      	ldr	r0, [pc, #312]	; (800327c <Demo_Exec+0x2e0>)
 8003142:	a90f      	add	r1, sp, #60	; 0x3c
 8003144:	f7ff f9b2 	bl	80024ac <TIM_OC2Init>
  TIM_CCxCmd(TIM4, TIM_Channel_2, DISABLE);
 8003148:	4622      	mov	r2, r4
 800314a:	484c      	ldr	r0, [pc, #304]	; (800327c <Demo_Exec+0x2e0>)
 800314c:	2104      	movs	r1, #4
 800314e:	f7ff fb79 	bl	8002844 <TIM_CCxCmd>
  
  TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Enable);
 8003152:	484a      	ldr	r0, [pc, #296]	; (800327c <Demo_Exec+0x2e0>)
 8003154:	2108      	movs	r1, #8
 8003156:	f7ff fad3 	bl	8002700 <TIM_OC2PreloadConfig>
    
  /* Output Compare PWM1 Mode configuration: Channel3 */
  TIM_OC3Init(TIM4, &TIM_OCInitStructure);
 800315a:	4848      	ldr	r0, [pc, #288]	; (800327c <Demo_Exec+0x2e0>)
 800315c:	a90f      	add	r1, sp, #60	; 0x3c
 800315e:	f7ff f9ed 	bl	800253c <TIM_OC3Init>
  TIM_CCxCmd(TIM4, TIM_Channel_3, DISABLE);
 8003162:	4622      	mov	r2, r4
 8003164:	4845      	ldr	r0, [pc, #276]	; (800327c <Demo_Exec+0x2e0>)
 8003166:	2108      	movs	r1, #8
 8003168:	f7ff fb6c 	bl	8002844 <TIM_CCxCmd>
  
  TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Enable);
 800316c:	4843      	ldr	r0, [pc, #268]	; (800327c <Demo_Exec+0x2e0>)
 800316e:	2108      	movs	r1, #8
 8003170:	f7ff fad0 	bl	8002714 <TIM_OC3PreloadConfig>
  
  /* Output Compare PWM1 Mode configuration: Channel4 */
  TIM_OC4Init(TIM4, &TIM_OCInitStructure);
 8003174:	4841      	ldr	r0, [pc, #260]	; (800327c <Demo_Exec+0x2e0>)
 8003176:	a90f      	add	r1, sp, #60	; 0x3c
 8003178:	f7ff fa26 	bl	80025c8 <TIM_OC4Init>
  TIM_CCxCmd(TIM4, TIM_Channel_4, DISABLE);
 800317c:	4622      	mov	r2, r4
 800317e:	483f      	ldr	r0, [pc, #252]	; (800327c <Demo_Exec+0x2e0>)
 8003180:	210c      	movs	r1, #12
 8003182:	f7ff fb5f 	bl	8002844 <TIM_CCxCmd>
  
  TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable);
 8003186:	483d      	ldr	r0, [pc, #244]	; (800327c <Demo_Exec+0x2e0>)
 8003188:	2108      	movs	r1, #8
 800318a:	f7ff facb 	bl	8002724 <TIM_OC4PreloadConfig>
  
  /* TIM4 enable counter */
  TIM_Cmd(TIM4, ENABLE);
 800318e:	483b      	ldr	r0, [pc, #236]	; (800327c <Demo_Exec+0x2e0>)
 8003190:	4631      	mov	r1, r6
 8003192:	f7ff f93d 	bl	8002410 <TIM_Cmd>
    
    /* TIM4 channels configuration */
    TIM4_Config();
    
    /* Disable all Timer4 channels */
    TIM_CCxCmd(TIM4, TIM_Channel_1, DISABLE);
 8003196:	4621      	mov	r1, r4
 8003198:	4622      	mov	r2, r4
 800319a:	4838      	ldr	r0, [pc, #224]	; (800327c <Demo_Exec+0x2e0>)
 800319c:	f7ff fb52 	bl	8002844 <TIM_CCxCmd>
    TIM_CCxCmd(TIM4, TIM_Channel_2, DISABLE);
 80031a0:	4622      	mov	r2, r4
 80031a2:	4836      	ldr	r0, [pc, #216]	; (800327c <Demo_Exec+0x2e0>)
 80031a4:	2104      	movs	r1, #4
 80031a6:	f7ff fb4d 	bl	8002844 <TIM_CCxCmd>
    TIM_CCxCmd(TIM4, TIM_Channel_3, DISABLE);
 80031aa:	4622      	mov	r2, r4
 80031ac:	4833      	ldr	r0, [pc, #204]	; (800327c <Demo_Exec+0x2e0>)
 80031ae:	2108      	movs	r1, #8
 80031b0:	f7ff fb48 	bl	8002844 <TIM_CCxCmd>
    TIM_CCxCmd(TIM4, TIM_Channel_4, DISABLE);
 80031b4:	4622      	mov	r2, r4
 80031b6:	210c      	movs	r1, #12
 80031b8:	4830      	ldr	r0, [pc, #192]	; (800327c <Demo_Exec+0x2e0>)
 80031ba:	f7ff fb43 	bl	8002844 <TIM_CCxCmd>
    
    /* MEMS configuration ------------------------------------------------------*/
    /* Fill the accelerometer structure */
    LSM303DLHCAcc_InitStructure.Power_Mode = LSM303DLHC_NORMAL_MODE;
    LSM303DLHCAcc_InitStructure.AccOutput_DataRate = LSM303DLHC_ODR_50_HZ;
 80031be:	2340      	movs	r3, #64	; 0x40
 80031c0:	f88d 3011 	strb.w	r3, [sp, #17]
    LSM303DLHCAcc_InitStructure.Axes_Enable= LSM303DLHC_AXES_ENABLE;
 80031c4:	2307      	movs	r3, #7
 80031c6:	f88d 3012 	strb.w	r3, [sp, #18]
    LSM303DLHCAcc_InitStructure.AccFull_Scale = LSM303DLHC_FULLSCALE_2G;
    LSM303DLHCAcc_InitStructure.BlockData_Update = LSM303DLHC_BlockUpdate_Continous;
    LSM303DLHCAcc_InitStructure.Endianness=LSM303DLHC_BLE_LSB;
    LSM303DLHCAcc_InitStructure.High_Resolution=LSM303DLHC_HR_ENABLE;
    /* Configure the accelerometer main parameters */
    LSM303DLHC_AccInit(&LSM303DLHCAcc_InitStructure);
 80031ca:	a804      	add	r0, sp, #16
    LSM303DLHCAcc_InitStructure.AccOutput_DataRate = LSM303DLHC_ODR_50_HZ;
    LSM303DLHCAcc_InitStructure.Axes_Enable= LSM303DLHC_AXES_ENABLE;
    LSM303DLHCAcc_InitStructure.AccFull_Scale = LSM303DLHC_FULLSCALE_2G;
    LSM303DLHCAcc_InitStructure.BlockData_Update = LSM303DLHC_BlockUpdate_Continous;
    LSM303DLHCAcc_InitStructure.Endianness=LSM303DLHC_BLE_LSB;
    LSM303DLHCAcc_InitStructure.High_Resolution=LSM303DLHC_HR_ENABLE;
 80031cc:	2308      	movs	r3, #8
 80031ce:	f88d 3013 	strb.w	r3, [sp, #19]
    TIM_CCxCmd(TIM4, TIM_Channel_3, DISABLE);
    TIM_CCxCmd(TIM4, TIM_Channel_4, DISABLE);
    
    /* MEMS configuration ------------------------------------------------------*/
    /* Fill the accelerometer structure */
    LSM303DLHCAcc_InitStructure.Power_Mode = LSM303DLHC_NORMAL_MODE;
 80031d2:	f88d 4010 	strb.w	r4, [sp, #16]
    LSM303DLHCAcc_InitStructure.AccOutput_DataRate = LSM303DLHC_ODR_50_HZ;
    LSM303DLHCAcc_InitStructure.Axes_Enable= LSM303DLHC_AXES_ENABLE;
    LSM303DLHCAcc_InitStructure.AccFull_Scale = LSM303DLHC_FULLSCALE_2G;
 80031d6:	f88d 4016 	strb.w	r4, [sp, #22]
    LSM303DLHCAcc_InitStructure.BlockData_Update = LSM303DLHC_BlockUpdate_Continous;
 80031da:	f88d 4014 	strb.w	r4, [sp, #20]
    LSM303DLHCAcc_InitStructure.Endianness=LSM303DLHC_BLE_LSB;
 80031de:	f88d 4015 	strb.w	r4, [sp, #21]
    LSM303DLHCAcc_InitStructure.High_Resolution=LSM303DLHC_HR_ENABLE;
    /* Configure the accelerometer main parameters */
    LSM303DLHC_AccInit(&LSM303DLHCAcc_InitStructure);
 80031e2:	f001 f8e3 	bl	80043ac <LSM303DLHC_AccInit>
    
    /* Required delay for the MEMS Accelerometre: Turn-on time = 3/Output data Rate 
    = 3/100 = 30ms */
    Delay(30);
 80031e6:	201e      	movs	r0, #30
 80031e8:	f7ff fecc 	bl	8002f84 <Delay>
    
    DemoEnterCondition = 0x01; 
    
    /* Fill the accelerometer LPF structure */
    LSM303DLHCFilter_InitStructure.HighPassFilter_Mode_Selection =LSM303DLHC_HPM_NORMAL_MODE;
 80031ec:	2380      	movs	r3, #128	; 0x80
    LSM303DLHCFilter_InitStructure.HighPassFilter_CutOff_Frequency = LSM303DLHC_HPFCF_16;
    LSM303DLHCFilter_InitStructure.HighPassFilter_AOI1 = LSM303DLHC_HPF_AOI1_DISABLE;
 80031ee:	f88d 400e 	strb.w	r4, [sp, #14]
    LSM303DLHCFilter_InitStructure.HighPassFilter_AOI2 = LSM303DLHC_HPF_AOI2_DISABLE;
 80031f2:	f88d 400f 	strb.w	r4, [sp, #15]
    
    /* Configure the accelerometer LPF main parameters */
    LSM303DLHC_AccFilterConfig(&LSM303DLHCFilter_InitStructure);
    
    LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_H_A, 6, Buffer_X);
 80031f6:	4c23      	ldr	r4, [pc, #140]	; (8003284 <Demo_Exec+0x2e8>)
    Delay(30);
    
    DemoEnterCondition = 0x01; 
    
    /* Fill the accelerometer LPF structure */
    LSM303DLHCFilter_InitStructure.HighPassFilter_Mode_Selection =LSM303DLHC_HPM_NORMAL_MODE;
 80031f8:	f88d 300c 	strb.w	r3, [sp, #12]
    LSM303DLHCFilter_InitStructure.HighPassFilter_CutOff_Frequency = LSM303DLHC_HPFCF_16;
    LSM303DLHCFilter_InitStructure.HighPassFilter_AOI1 = LSM303DLHC_HPF_AOI1_DISABLE;
    LSM303DLHCFilter_InitStructure.HighPassFilter_AOI2 = LSM303DLHC_HPF_AOI2_DISABLE;
    
    /* Configure the accelerometer LPF main parameters */
    LSM303DLHC_AccFilterConfig(&LSM303DLHCFilter_InitStructure);
 80031fc:	a803      	add	r0, sp, #12
    
    DemoEnterCondition = 0x01; 
    
    /* Fill the accelerometer LPF structure */
    LSM303DLHCFilter_InitStructure.HighPassFilter_Mode_Selection =LSM303DLHC_HPM_NORMAL_MODE;
    LSM303DLHCFilter_InitStructure.HighPassFilter_CutOff_Frequency = LSM303DLHC_HPFCF_16;
 80031fe:	2310      	movs	r3, #16
 8003200:	f88d 300d 	strb.w	r3, [sp, #13]
    
    /* Required delay for the MEMS Accelerometre: Turn-on time = 3/Output data Rate 
    = 3/100 = 30ms */
    Delay(30);
    
    DemoEnterCondition = 0x01; 
 8003204:	f888 6000 	strb.w	r6, [r8]
    LSM303DLHCFilter_InitStructure.HighPassFilter_CutOff_Frequency = LSM303DLHC_HPFCF_16;
    LSM303DLHCFilter_InitStructure.HighPassFilter_AOI1 = LSM303DLHC_HPF_AOI1_DISABLE;
    LSM303DLHCFilter_InitStructure.HighPassFilter_AOI2 = LSM303DLHC_HPF_AOI2_DISABLE;
    
    /* Configure the accelerometer LPF main parameters */
    LSM303DLHC_AccFilterConfig(&LSM303DLHCFilter_InitStructure);
 8003208:	f001 f8ff 	bl	800440a <LSM303DLHC_AccFilterConfig>
    
    LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_H_A, 6, Buffer_X);
 800320c:	4623      	mov	r3, r4
 800320e:	2129      	movs	r1, #41	; 0x29
 8003210:	2206      	movs	r2, #6
 8003212:	2032      	movs	r0, #50	; 0x32
 8003214:	f000 fef0 	bl	8003ff8 <LSM303DLHC_Read>
    X_Offset = Buffer_X[0];
 8003218:	7822      	ldrb	r2, [r4, #0]
 800321a:	4b1b      	ldr	r3, [pc, #108]	; (8003288 <Demo_Exec+0x2ec>)
    LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_Y_H_A, 6, Buffer_Y);
 800321c:	4c1b      	ldr	r4, [pc, #108]	; (800328c <Demo_Exec+0x2f0>)
    
    /* Configure the accelerometer LPF main parameters */
    LSM303DLHC_AccFilterConfig(&LSM303DLHCFilter_InitStructure);
    
    LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_H_A, 6, Buffer_X);
    X_Offset = Buffer_X[0];
 800321e:	701a      	strb	r2, [r3, #0]
    LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_Y_H_A, 6, Buffer_Y);
 8003220:	212b      	movs	r1, #43	; 0x2b
 8003222:	2206      	movs	r2, #6
 8003224:	4623      	mov	r3, r4
 8003226:	2032      	movs	r0, #50	; 0x32
 8003228:	f000 fee6 	bl	8003ff8 <LSM303DLHC_Read>
    Y_Offset = Buffer_Y[0];
 800322c:	4b18      	ldr	r3, [pc, #96]	; (8003290 <Demo_Exec+0x2f4>)
 800322e:	7822      	ldrb	r2, [r4, #0]
 8003230:	701a      	strb	r2, [r3, #0]
  * @param  None
  * @retval None
  */
static uint32_t Demo_USBConfig(void)
{
  USBD_Init(&USB_OTG_dev,
 8003232:	4b18      	ldr	r3, [pc, #96]	; (8003294 <Demo_Exec+0x2f8>)
 8003234:	9300      	str	r3, [sp, #0]
 8003236:	4818      	ldr	r0, [pc, #96]	; (8003298 <Demo_Exec+0x2fc>)
 8003238:	4a18      	ldr	r2, [pc, #96]	; (800329c <Demo_Exec+0x300>)
 800323a:	4b19      	ldr	r3, [pc, #100]	; (80032a0 <Demo_Exec+0x304>)
 800323c:	4631      	mov	r1, r6
 800323e:	f002 f9cf 	bl	80055e0 <USBD_Init>
    
    /* USB configuration */
    Demo_USBConfig();
    
    /* Waiting User Button is pressed */
    while (UserButtonPressed == 0x00)
 8003242:	783b      	ldrb	r3, [r7, #0]
 8003244:	2b00      	cmp	r3, #0
 8003246:	d0fc      	beq.n	8003242 <Demo_Exec+0x2a6>
    {}
    
    /* Waiting User Button is Released */
    while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_SET)
 8003248:	2000      	movs	r0, #0
 800324a:	f000 f969 	bl	8003520 <STM_EVAL_PBGetState>
 800324e:	2801      	cmp	r0, #1
 8003250:	d0fa      	beq.n	8003248 <Demo_Exec+0x2ac>
    {}
    
    /* Disable I2C1 used to drive the MEMS accelerometre */
    I2C_Cmd(LSM303DLHC_I2C, DISABLE);
 8003252:	2100      	movs	r1, #0
 8003254:	4813      	ldr	r0, [pc, #76]	; (80032a4 <Demo_Exec+0x308>)
 8003256:	f7fe f8db 	bl	8001410 <I2C_Cmd>
    
    /* Disconnect the USB device */
    DCD_DevDisconnect(&USB_OTG_dev);
 800325a:	480f      	ldr	r0, [pc, #60]	; (8003298 <Demo_Exec+0x2fc>)
 800325c:	f003 f921 	bl	80064a2 <DCD_DevDisconnect>
    USB_OTG_StopDevice(&USB_OTG_dev);
 8003260:	480d      	ldr	r0, [pc, #52]	; (8003298 <Demo_Exec+0x2fc>)
 8003262:	f002 fff7 	bl	8006254 <USB_OTG_StopDevice>
  }
 8003266:	e69d      	b.n	8002fa4 <Demo_Exec+0x8>
 8003268:	200005bf 	.word	0x200005bf
 800326c:	e000e010 	.word	0xe000e010
 8003270:	e000ed00 	.word	0xe000ed00
 8003274:	40020c00 	.word	0x40020c00
 8003278:	20000058 	.word	0x20000058
 800327c:	40000800 	.word	0x40000800
 8003280:	200005bc 	.word	0x200005bc
 8003284:	20000bf0 	.word	0x20000bf0
 8003288:	200005fb 	.word	0x200005fb
 800328c:	200005f4 	.word	0x200005f4
 8003290:	200005fa 	.word	0x200005fa
 8003294:	20000090 	.word	0x20000090
 8003298:	200005fc 	.word	0x200005fc
 800329c:	2000005c 	.word	0x2000005c
 80032a0:	2000011c 	.word	0x2000011c
 80032a4:	40005400 	.word	0x40005400
 80032a8:	200005be 	.word	0x200005be

080032ac <main>:
  * @brief  Main program.
  * @param  None
  * @retval None
  */
int main(void)
{
 80032ac:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  RCC_ClocksTypeDef RCC_Clocks;
  
  /* Initialize LEDs and User_Button on STM32F401-Discovery ------------------*/
  STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_EXTI); 
 80032ae:	2101      	movs	r1, #1
 80032b0:	2000      	movs	r0, #0
 80032b2:	f000 f8f7 	bl	80034a4 <STM_EVAL_PBInit>
  
  STM_EVAL_LEDInit(LED4);
 80032b6:	2000      	movs	r0, #0
 80032b8:	f000 f8a8 	bl	800340c <STM_EVAL_LEDInit>
  STM_EVAL_LEDInit(LED3);
 80032bc:	2001      	movs	r0, #1
 80032be:	f000 f8a5 	bl	800340c <STM_EVAL_LEDInit>
  STM_EVAL_LEDInit(LED5);
 80032c2:	2002      	movs	r0, #2
 80032c4:	f000 f8a2 	bl	800340c <STM_EVAL_LEDInit>
  STM_EVAL_LEDInit(LED6);
 80032c8:	2003      	movs	r0, #3
 80032ca:	f000 f89f 	bl	800340c <STM_EVAL_LEDInit>
  
  /* SysTick end of count event each 10ms */
  RCC_GetClocksFreq(&RCC_Clocks);
 80032ce:	4668      	mov	r0, sp
 80032d0:	f7fe fb1c 	bl	800190c <RCC_GetClocksFreq>
  SysTick_Config(RCC_Clocks.HCLK_Frequency / 100);
 80032d4:	9b01      	ldr	r3, [sp, #4]
 80032d6:	2264      	movs	r2, #100	; 0x64
 80032d8:	fbb3 f2f2 	udiv	r2, r3, r2
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 80032dc:	3a01      	subs	r2, #1
 80032de:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
 80032e2:	d209      	bcs.n	80032f8 <main+0x4c>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 80032e4:	4b31      	ldr	r3, [pc, #196]	; (80033ac <main+0x100>)
 80032e6:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80032e8:	4a31      	ldr	r2, [pc, #196]	; (80033b0 <main+0x104>)
 80032ea:	21f0      	movs	r1, #240	; 0xf0
 80032ec:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 80032f0:	2200      	movs	r2, #0
 80032f2:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80032f4:	2207      	movs	r2, #7
 80032f6:	601a      	str	r2, [r3, #0]
  
  if (STM_EVAL_PBGetState(BUTTON_USER) == Bit_SET)
 80032f8:	2000      	movs	r0, #0
 80032fa:	f000 f911 	bl	8003520 <STM_EVAL_PBGetState>
 80032fe:	2801      	cmp	r0, #1
 8003300:	4604      	mov	r4, r0
 8003302:	d150      	bne.n	80033a6 <main+0xfa>
  {
    /* Turn on LEDs available on STM32F401-Discovery -------------------------*/
    STM_EVAL_LEDOn(LED4);
 8003304:	2000      	movs	r0, #0
 8003306:	f000 f8a7 	bl	8003458 <STM_EVAL_LEDOn>
    STM_EVAL_LEDOn(LED3);
 800330a:	4620      	mov	r0, r4
 800330c:	f000 f8a4 	bl	8003458 <STM_EVAL_LEDOn>
    STM_EVAL_LEDOn(LED5);
 8003310:	2002      	movs	r0, #2
 8003312:	f000 f8a1 	bl	8003458 <STM_EVAL_LEDOn>
    STM_EVAL_LEDOn(LED6); 
 8003316:	2003      	movs	r0, #3
 8003318:	f000 f89e 	bl	8003458 <STM_EVAL_LEDOn>
    
    if ((*(__IO uint32_t*) TESTRESULT_ADDRESS) == ALLTEST_PASS)
 800331c:	4b25      	ldr	r3, [pc, #148]	; (80033b4 <main+0x108>)
 800331e:	4c26      	ldr	r4, [pc, #152]	; (80033b8 <main+0x10c>)
 8003320:	681a      	ldr	r2, [r3, #0]
 8003322:	f44f 7396 	mov.w	r3, #300	; 0x12c
    {
      TimingDelay = 300;
 8003326:	6023      	str	r3, [r4, #0]
    STM_EVAL_LEDOn(LED4);
    STM_EVAL_LEDOn(LED3);
    STM_EVAL_LEDOn(LED5);
    STM_EVAL_LEDOn(LED6); 
    
    if ((*(__IO uint32_t*) TESTRESULT_ADDRESS) == ALLTEST_PASS)
 8003328:	b952      	cbnz	r2, 8003340 <main+0x94>
    {
      TimingDelay = 300;
      /* Waiting User Button is pressed or Test Program condition verified */
      while ((STM_EVAL_PBGetState(BUTTON_USER) == Bit_SET)&&(TimingDelay != 0x00))
 800332a:	2000      	movs	r0, #0
 800332c:	f000 f8f8 	bl	8003520 <STM_EVAL_PBGetState>
 8003330:	2801      	cmp	r0, #1
 8003332:	d10f      	bne.n	8003354 <main+0xa8>
 8003334:	6823      	ldr	r3, [r4, #0]
 8003336:	2b00      	cmp	r3, #0
 8003338:	d1f7      	bne.n	800332a <main+0x7e>
 800333a:	e00b      	b.n	8003354 <main+0xa8>
    }
    else
    {
      /* Waiting User Button is Released  or TimeOut*/
      TimingDelay = 300;
      while ((STM_EVAL_PBGetState(BUTTON_USER) == Bit_SET)&&(TimingDelay != 0x00))
 800333c:	6823      	ldr	r3, [r4, #0]
 800333e:	b123      	cbz	r3, 800334a <main+0x9e>
 8003340:	2000      	movs	r0, #0
 8003342:	f000 f8ed 	bl	8003520 <STM_EVAL_PBGetState>
 8003346:	2801      	cmp	r0, #1
 8003348:	d0f8      	beq.n	800333c <main+0x90>
      {}
      if (STM_EVAL_PBGetState(BUTTON_USER) == Bit_RESET)
 800334a:	2000      	movs	r0, #0
 800334c:	f000 f8e8 	bl	8003520 <STM_EVAL_PBGetState>
 8003350:	b900      	cbnz	r0, 8003354 <main+0xa8>
      {
        TimingDelay = 0x00;
 8003352:	6020      	str	r0, [r4, #0]
      }
    }
    if (TimingDelay == 0x00)
 8003354:	6820      	ldr	r0, [r4, #0]
 8003356:	bb30      	cbnz	r0, 80033a6 <main+0xfa>
    {
      /* Turn off LEDs available on STM32F401-Discovery ----------------------*/
      STM_EVAL_LEDOff(LED4);
 8003358:	f000 f88a 	bl	8003470 <STM_EVAL_LEDOff>
      STM_EVAL_LEDOff(LED3);
 800335c:	2001      	movs	r0, #1
 800335e:	f000 f887 	bl	8003470 <STM_EVAL_LEDOff>
      STM_EVAL_LEDOff(LED5);
 8003362:	2002      	movs	r0, #2
 8003364:	f000 f884 	bl	8003470 <STM_EVAL_LEDOff>
      STM_EVAL_LEDOff(LED6); 
 8003368:	2003      	movs	r0, #3
 800336a:	f000 f881 	bl	8003470 <STM_EVAL_LEDOff>
      
      /* Waiting User Button is released */
      while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_SET)
 800336e:	2000      	movs	r0, #0
 8003370:	f000 f8d6 	bl	8003520 <STM_EVAL_PBGetState>
 8003374:	2801      	cmp	r0, #1
 8003376:	d0fa      	beq.n	800336e <main+0xc2>
      {}
      
      /* Unlocks the FLASH control register access */
      FLASH_Unlock();
 8003378:	f7fd fb9a 	bl	8000ab0 <FLASH_Unlock>
      
      /* Move discovery kit to detect negative and positive acceleration values 
      on X, Y and Z axis for LSM303DLHC MEMS*/
      LSM303DLHC_MEMS_Test();
 800337c:	f001 ff0e 	bl	800519c <LSM303DLHC_MEMS_Test>
      
      /* Move discovery kit to detect negative and positive acceleration values 
      on X, Y and Z axis for L3GD20 MEMS*/
      L3GD20_MEMS_Test();
 8003380:	f001 faf0 	bl	8004964 <L3GD20_MEMS_Test>
      
      /* USB Hardware connection */
      USB_Test();
 8003384:	f001 fb42 	bl	8004a0c <USB_Test>
      
      /* Audio Hardware connection */
      Audio_Test();
 8003388:	f001 fd58 	bl	8004e3c <Audio_Test>
      
      /* Microphone MEMS Hardware connection */
      Microphone_MEMS_Test();
 800338c:	f001 fe24 	bl	8004fd8 <Microphone_MEMS_Test>
      
      /* Write PASS code at last word in the flash memory */
      FLASH_ProgramWord(TESTRESULT_ADDRESS, ALLTEST_PASS);
 8003390:	4808      	ldr	r0, [pc, #32]	; (80033b4 <main+0x108>)
 8003392:	2100      	movs	r1, #0
 8003394:	f7fd fd44 	bl	8000e20 <FLASH_ProgramWord>
      
      while(1)
      {
        /* Toggle Green LED: signaling the End of the Test program */
        STM_EVAL_LEDToggle(LED4);
 8003398:	2000      	movs	r0, #0
 800339a:	f000 f875 	bl	8003488 <STM_EVAL_LEDToggle>
        Delay(10);
 800339e:	200a      	movs	r0, #10
 80033a0:	f7ff fdf0 	bl	8002f84 <Delay>
 80033a4:	e7f8      	b.n	8003398 <main+0xec>
      }
    }
    else
    {
      Demo_Exec();
 80033a6:	f7ff fdf9 	bl	8002f9c <Demo_Exec>
 80033aa:	bf00      	nop
 80033ac:	e000e010 	.word	0xe000e010
 80033b0:	e000ed00 	.word	0xe000ed00
 80033b4:	0803fffc 	.word	0x0803fffc
 80033b8:	200005f0 	.word	0x200005f0

080033bc <TimingDelay_Decrement>:
  * @param  None
  * @retval None
  */
void TimingDelay_Decrement(void)
{
  if (TimingDelay != 0x00)
 80033bc:	4b03      	ldr	r3, [pc, #12]	; (80033cc <TimingDelay_Decrement+0x10>)
 80033be:	681a      	ldr	r2, [r3, #0]
 80033c0:	b112      	cbz	r2, 80033c8 <TimingDelay_Decrement+0xc>
  { 
    TimingDelay--;
 80033c2:	681a      	ldr	r2, [r3, #0]
 80033c4:	3a01      	subs	r2, #1
 80033c6:	601a      	str	r2, [r3, #0]
 80033c8:	4770      	bx	lr
 80033ca:	bf00      	nop
 80033cc:	200005f0 	.word	0x200005f0

080033d0 <Fail_Handler>:
  * @retval None
  */
void Fail_Handler(void)
{
  /* Erase last sector */ 
  FLASH_EraseSector(FLASH_Sector_11, VoltageRange_3);
 80033d0:	2102      	movs	r1, #2
  * @brief  This function handles the test program fail.
  * @param  None
  * @retval None
  */
void Fail_Handler(void)
{
 80033d2:	b508      	push	{r3, lr}
  /* Erase last sector */ 
  FLASH_EraseSector(FLASH_Sector_11, VoltageRange_3);
 80033d4:	2058      	movs	r0, #88	; 0x58
 80033d6:	f7fd fc3d 	bl	8000c54 <FLASH_EraseSector>
  /* Write FAIL code at last word in the flash memory */
  FLASH_ProgramWord(TESTRESULT_ADDRESS, ALLTEST_FAIL);
 80033da:	4806      	ldr	r0, [pc, #24]	; (80033f4 <Fail_Handler+0x24>)
 80033dc:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 80033e0:	f7fd fd1e 	bl	8000e20 <FLASH_ProgramWord>
  
  while(1)
  {
    /* Toggle Red LED */
    STM_EVAL_LEDToggle(LED5);
 80033e4:	2002      	movs	r0, #2
 80033e6:	f000 f84f 	bl	8003488 <STM_EVAL_LEDToggle>
    Delay(5);
 80033ea:	2005      	movs	r0, #5
 80033ec:	f7ff fdca 	bl	8002f84 <Delay>
 80033f0:	e7f8      	b.n	80033e4 <Fail_Handler+0x14>
 80033f2:	bf00      	nop
 80033f4:	0803fffc 	.word	0x0803fffc

080033f8 <L3GD20_TIMEOUT_UserCallback>:
  * @brief  L3GD20 MEMS accelerometre management of the timeout situation.
  * @param  None.
  * @retval None.
  */
uint32_t L3GD20_TIMEOUT_UserCallback(void)
{
 80033f8:	b508      	push	{r3, lr}
  /* MEMS Accelerometer Timeout error occured during Test program execution */
  if (DemoEnterCondition == 0x00)
 80033fa:	4b03      	ldr	r3, [pc, #12]	; (8003408 <L3GD20_TIMEOUT_UserCallback+0x10>)
 80033fc:	781b      	ldrb	r3, [r3, #0]
 80033fe:	b90b      	cbnz	r3, 8003404 <L3GD20_TIMEOUT_UserCallback+0xc>
  {
    /* Timeout error occured for SPI TXE/RXNE flags waiting loops.*/
    Fail_Handler();    
 8003400:	f7ff ffe6 	bl	80033d0 <Fail_Handler>
 8003404:	e7fe      	b.n	8003404 <L3GD20_TIMEOUT_UserCallback+0xc>
 8003406:	bf00      	nop
 8003408:	200005be 	.word	0x200005be

0800340c <STM_EVAL_LEDInit>:
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
  GPIO_InitTypeDef  GPIO_InitStructure;
  
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 800340c:	4b0f      	ldr	r3, [pc, #60]	; (800344c <STM_EVAL_LEDInit+0x40>)
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
 800340e:	b513      	push	{r0, r1, r4, lr}
 8003410:	4604      	mov	r4, r0
  GPIO_InitTypeDef  GPIO_InitStructure;
  
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 8003412:	2101      	movs	r1, #1
 8003414:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8003418:	f7fe fb2e 	bl	8001a78 <RCC_AHB1PeriphClockCmd>

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 800341c:	4b0c      	ldr	r3, [pc, #48]	; (8003450 <STM_EVAL_LEDInit+0x44>)
 800341e:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
 8003422:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8003424:	2301      	movs	r3, #1
 8003426:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800342a:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800342e:	2302      	movs	r3, #2
 8003430:	f88d 3005 	strb.w	r3, [sp, #5]
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 8003434:	4b07      	ldr	r3, [pc, #28]	; (8003454 <STM_EVAL_LEDInit+0x48>)
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003436:	2200      	movs	r2, #0
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 8003438:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800343c:	f88d 2006 	strb.w	r2, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 8003440:	4669      	mov	r1, sp
 8003442:	f7fd fe7b 	bl	800113c <GPIO_Init>
}
 8003446:	b002      	add	sp, #8
 8003448:	bd10      	pop	{r4, pc}
 800344a:	bf00      	nop
 800344c:	08006a3c 	.word	0x08006a3c
 8003450:	08006a4c 	.word	0x08006a4c
 8003454:	20000010 	.word	0x20000010

08003458 <STM_EVAL_LEDOn>:
  *     @arg LED6  
  * @retval None
  */
void STM_EVAL_LEDOn(Led_TypeDef Led)
{
  GPIO_PORT[Led]->BSRRL = GPIO_PIN[Led];
 8003458:	4b03      	ldr	r3, [pc, #12]	; (8003468 <STM_EVAL_LEDOn+0x10>)
 800345a:	4a04      	ldr	r2, [pc, #16]	; (800346c <STM_EVAL_LEDOn+0x14>)
 800345c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8003460:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
 8003464:	831a      	strh	r2, [r3, #24]
 8003466:	4770      	bx	lr
 8003468:	20000010 	.word	0x20000010
 800346c:	08006a4c 	.word	0x08006a4c

08003470 <STM_EVAL_LEDOff>:
  *     @arg LED6 
  * @retval None
  */
void STM_EVAL_LEDOff(Led_TypeDef Led)
{
  GPIO_PORT[Led]->BSRRH = GPIO_PIN[Led];  
 8003470:	4b03      	ldr	r3, [pc, #12]	; (8003480 <STM_EVAL_LEDOff+0x10>)
 8003472:	4a04      	ldr	r2, [pc, #16]	; (8003484 <STM_EVAL_LEDOff+0x14>)
 8003474:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8003478:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
 800347c:	835a      	strh	r2, [r3, #26]
 800347e:	4770      	bx	lr
 8003480:	20000010 	.word	0x20000010
 8003484:	08006a4c 	.word	0x08006a4c

08003488 <STM_EVAL_LEDToggle>:
  *     @arg LED6  
  * @retval None
  */
void STM_EVAL_LEDToggle(Led_TypeDef Led)
{
  GPIO_PORT[Led]->ODR ^= GPIO_PIN[Led];
 8003488:	4b04      	ldr	r3, [pc, #16]	; (800349c <STM_EVAL_LEDToggle+0x14>)
 800348a:	4905      	ldr	r1, [pc, #20]	; (80034a0 <STM_EVAL_LEDToggle+0x18>)
 800348c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8003490:	f831 1010 	ldrh.w	r1, [r1, r0, lsl #1]
 8003494:	695a      	ldr	r2, [r3, #20]
 8003496:	404a      	eors	r2, r1
 8003498:	615a      	str	r2, [r3, #20]
 800349a:	4770      	bx	lr
 800349c:	20000010 	.word	0x20000010
 80034a0:	08006a4c 	.word	0x08006a4c

080034a4 <STM_EVAL_PBInit>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval None
  */
void STM_EVAL_PBInit(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
{
 80034a4:	b570      	push	{r4, r5, r6, lr}
 80034a6:	4606      	mov	r6, r0
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the BUTTON Clock */
  RCC_AHB1PeriphClockCmd(BUTTON_CLK[Button], ENABLE);
 80034a8:	2001      	movs	r0, #1
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval None
  */
void STM_EVAL_PBInit(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
{
 80034aa:	b086      	sub	sp, #24
 80034ac:	460d      	mov	r5, r1
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the BUTTON Clock */
  RCC_AHB1PeriphClockCmd(BUTTON_CLK[Button], ENABLE);
 80034ae:	4601      	mov	r1, r0
 80034b0:	f7fe fae2 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 80034b4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80034b8:	2101      	movs	r1, #1
 80034ba:	f7fe fb0d 	bl	8001ad8 <RCC_APB2PeriphClockCmd>

  /* Configure Button pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
 80034be:	a906      	add	r1, sp, #24
 80034c0:	2301      	movs	r3, #1
 80034c2:	f841 3d10 	str.w	r3, [r1, #-16]!
  GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);
 80034c6:	4b15      	ldr	r3, [pc, #84]	; (800351c <STM_EVAL_PBInit+0x78>)
  /* Enable the BUTTON Clock */
  RCC_AHB1PeriphClockCmd(BUTTON_CLK[Button], ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Configure Button pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 80034c8:	2400      	movs	r4, #0
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
  GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);
 80034ca:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
  /* Enable the BUTTON Clock */
  RCC_AHB1PeriphClockCmd(BUTTON_CLK[Button], ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Configure Button pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 80034ce:	f88d 400c 	strb.w	r4, [sp, #12]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80034d2:	f88d 400f 	strb.w	r4, [sp, #15]
  GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
  GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);
 80034d6:	f7fd fe31 	bl	800113c <GPIO_Init>

  if (Button_Mode == BUTTON_MODE_EXTI)
 80034da:	2d01      	cmp	r5, #1
 80034dc:	d11b      	bne.n	8003516 <STM_EVAL_PBInit+0x72>
  {
    /* Connect Button EXTI Line to Button GPIO Pin */
    SYSCFG_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);
 80034de:	4620      	mov	r0, r4
 80034e0:	4621      	mov	r1, r4
 80034e2:	f7fe fddd 	bl	80020a0 <SYSCFG_EXTILineConfig>

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  
 80034e6:	2308      	movs	r3, #8
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);
 80034e8:	a804      	add	r0, sp, #16
    SYSCFG_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  
 80034ea:	f88d 3015 	strb.w	r3, [sp, #21]
  {
    /* Connect Button EXTI Line to Button GPIO Pin */
    SYSCFG_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
 80034ee:	9504      	str	r5, [sp, #16]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 80034f0:	f88d 4014 	strb.w	r4, [sp, #20]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 80034f4:	f88d 5016 	strb.w	r5, [sp, #22]
    EXTI_Init(&EXTI_InitStructure);
 80034f8:	f7fd fa2a 	bl	8000950 <EXTI_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
 80034fc:	2306      	movs	r3, #6
 80034fe:	f88d 3004 	strb.w	r3, [sp, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

    NVIC_Init(&NVIC_InitStructure); 
 8003502:	a801      	add	r0, sp, #4
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
 8003504:	230f      	movs	r3, #15
 8003506:	f88d 3005 	strb.w	r3, [sp, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
 800350a:	f88d 3006 	strb.w	r3, [sp, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800350e:	f88d 5007 	strb.w	r5, [sp, #7]

    NVIC_Init(&NVIC_InitStructure); 
 8003512:	f7ff fcd9 	bl	8002ec8 <NVIC_Init>
  }
}
 8003516:	b006      	add	sp, #24
 8003518:	bd70      	pop	{r4, r5, r6, pc}
 800351a:	bf00      	nop
 800351c:	20000020 	.word	0x20000020

08003520 <STM_EVAL_PBGetState>:
  * @param  Button: Specifies the Button to be checked.
  *   This parameter should be: BUTTON_USER  
  * @retval The Button GPIO pin value.
  */
uint32_t STM_EVAL_PBGetState(Button_TypeDef Button)
{
 8003520:	b508      	push	{r3, lr}
  return GPIO_ReadInputDataBit(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 8003522:	4b03      	ldr	r3, [pc, #12]	; (8003530 <STM_EVAL_PBGetState+0x10>)
 8003524:	2101      	movs	r1, #1
 8003526:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800352a:	f7fd fe81 	bl	8001230 <GPIO_ReadInputDataBit>
}
 800352e:	bd08      	pop	{r3, pc}
 8003530:	20000020 	.word	0x20000020

08003534 <Codec_WriteRegister>:
  * @param  RegisterAddr: The address (location) of the register to be written.
  * @param  RegisterValue: the Byte value to be written into destination register.
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue)
{
 8003534:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t result = 0;

  /*!< While the bus is busy */
  CODECTimeout = CODEC_LONG_TIMEOUT;
 8003536:	4c83      	ldr	r4, [pc, #524]	; (8003744 <Codec_WriteRegister+0x210>)
 8003538:	f44f 1396 	mov.w	r3, #1228800	; 0x12c000
  * @param  RegisterAddr: The address (location) of the register to be written.
  * @param  RegisterValue: the Byte value to be written into destination register.
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue)
{
 800353c:	4605      	mov	r5, r0
 800353e:	460e      	mov	r6, r1
  uint32_t result = 0;

  /*!< While the bus is busy */
  CODECTimeout = CODEC_LONG_TIMEOUT;
 8003540:	6023      	str	r3, [r4, #0]
  while(I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_BUSY))
 8003542:	4881      	ldr	r0, [pc, #516]	; (8003748 <Codec_WriteRegister+0x214>)
 8003544:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8003548:	f7fe f8b8 	bl	80016bc <I2C_GetFlagStatus>
 800354c:	b128      	cbz	r0, 800355a <Codec_WriteRegister+0x26>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 800354e:	6823      	ldr	r3, [r4, #0]
 8003550:	1e5a      	subs	r2, r3, #1
 8003552:	6022      	str	r2, [r4, #0]
 8003554:	2b00      	cmp	r3, #0
 8003556:	d1f4      	bne.n	8003542 <Codec_WriteRegister+0xe>
 8003558:	e035      	b.n	80035c6 <Codec_WriteRegister+0x92>
  }
  
  /* Start the config sequence */
  I2C_GenerateSTART(CODEC_I2C, ENABLE);
 800355a:	487b      	ldr	r0, [pc, #492]	; (8003748 <Codec_WriteRegister+0x214>)
 800355c:	2101      	movs	r1, #1
 800355e:	f7fd ff7d 	bl	800145c <I2C_GenerateSTART>

  /* Test on EV5 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 8003562:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003566:	6023      	str	r3, [r4, #0]
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8003568:	4877      	ldr	r0, [pc, #476]	; (8003748 <Codec_WriteRegister+0x214>)
 800356a:	4978      	ldr	r1, [pc, #480]	; (800374c <Codec_WriteRegister+0x218>)
 800356c:	f7fe f892 	bl	8001694 <I2C_CheckEvent>
 8003570:	b928      	cbnz	r0, 800357e <Codec_WriteRegister+0x4a>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 8003572:	6823      	ldr	r3, [r4, #0]
 8003574:	1e5a      	subs	r2, r3, #1
 8003576:	6022      	str	r2, [r4, #0]
 8003578:	2b00      	cmp	r3, #0
 800357a:	d1f5      	bne.n	8003568 <Codec_WriteRegister+0x34>
 800357c:	e023      	b.n	80035c6 <Codec_WriteRegister+0x92>
  }
  
  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(CODEC_I2C, CODEC_ADDRESS, I2C_Direction_Transmitter);
 800357e:	4872      	ldr	r0, [pc, #456]	; (8003748 <Codec_WriteRegister+0x214>)
 8003580:	2194      	movs	r1, #148	; 0x94
 8003582:	2200      	movs	r2, #0
 8003584:	f7fd ff86 	bl	8001494 <I2C_Send7bitAddress>

  /* Test on EV6 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 8003588:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800358c:	6023      	str	r3, [r4, #0]
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 800358e:	486e      	ldr	r0, [pc, #440]	; (8003748 <Codec_WriteRegister+0x214>)
 8003590:	496f      	ldr	r1, [pc, #444]	; (8003750 <Codec_WriteRegister+0x21c>)
 8003592:	f7fe f87f 	bl	8001694 <I2C_CheckEvent>
 8003596:	b928      	cbnz	r0, 80035a4 <Codec_WriteRegister+0x70>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 8003598:	6823      	ldr	r3, [r4, #0]
 800359a:	1e5a      	subs	r2, r3, #1
 800359c:	6022      	str	r2, [r4, #0]
 800359e:	2b00      	cmp	r3, #0
 80035a0:	d1f5      	bne.n	800358e <Codec_WriteRegister+0x5a>
 80035a2:	e010      	b.n	80035c6 <Codec_WriteRegister+0x92>
  }

  /* Transmit the first address for write operation */
  I2C_SendData(CODEC_I2C, RegisterAddr);
 80035a4:	4868      	ldr	r0, [pc, #416]	; (8003748 <Codec_WriteRegister+0x214>)
 80035a6:	4629      	mov	r1, r5
 80035a8:	f7fe f80c 	bl	80015c4 <I2C_SendData>

  /* Test on EV8 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 80035ac:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80035b0:	6023      	str	r3, [r4, #0]
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
 80035b2:	4865      	ldr	r0, [pc, #404]	; (8003748 <Codec_WriteRegister+0x214>)
 80035b4:	4967      	ldr	r1, [pc, #412]	; (8003754 <Codec_WriteRegister+0x220>)
 80035b6:	f7fe f86d 	bl	8001694 <I2C_CheckEvent>
 80035ba:	b940      	cbnz	r0, 80035ce <Codec_WriteRegister+0x9a>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 80035bc:	6823      	ldr	r3, [r4, #0]
 80035be:	1e5a      	subs	r2, r3, #1
 80035c0:	6022      	str	r2, [r4, #0]
 80035c2:	2b00      	cmp	r3, #0
 80035c4:	d1f5      	bne.n	80035b2 <Codec_WriteRegister+0x7e>
  result = (Codec_ReadRegister(RegisterAddr) == RegisterValue)? 0:1;
#endif /* VERIFY_WRITTENDATA */

  /* Return the verifying value: 0 (Passed) or 1 (Failed) */
  return result;  
}
 80035c6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  /* Test on EV8 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 80035ca:	f001 be79 	b.w	80052c0 <Codec_TIMEOUT_UserCallback>
  }
  
  /* Prepare the register value to be sent */
  I2C_SendData(CODEC_I2C, RegisterValue);
 80035ce:	485e      	ldr	r0, [pc, #376]	; (8003748 <Codec_WriteRegister+0x214>)
 80035d0:	4631      	mov	r1, r6
 80035d2:	f7fd fff7 	bl	80015c4 <I2C_SendData>
  
  /*!< Wait till all data have been physically transferred on the bus */
  CODECTimeout = CODEC_LONG_TIMEOUT;
 80035d6:	f44f 1396 	mov.w	r3, #1228800	; 0x12c000
 80035da:	6023      	str	r3, [r4, #0]
  while(!I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_BTF))
 80035dc:	485a      	ldr	r0, [pc, #360]	; (8003748 <Codec_WriteRegister+0x214>)
 80035de:	495e      	ldr	r1, [pc, #376]	; (8003758 <Codec_WriteRegister+0x224>)
 80035e0:	f7fe f86c 	bl	80016bc <I2C_GetFlagStatus>
 80035e4:	b938      	cbnz	r0, 80035f6 <Codec_WriteRegister+0xc2>
  {
    if((CODECTimeout--) == 0) Codec_TIMEOUT_UserCallback();
 80035e6:	6823      	ldr	r3, [r4, #0]
 80035e8:	1e5a      	subs	r2, r3, #1
 80035ea:	6022      	str	r2, [r4, #0]
 80035ec:	2b00      	cmp	r3, #0
 80035ee:	d1f5      	bne.n	80035dc <Codec_WriteRegister+0xa8>
 80035f0:	f001 fe66 	bl	80052c0 <Codec_TIMEOUT_UserCallback>
 80035f4:	e7f2      	b.n	80035dc <Codec_WriteRegister+0xa8>
  }
  
  /* End the configuration sequence */
  I2C_GenerateSTOP(CODEC_I2C, ENABLE);  
 80035f6:	4854      	ldr	r0, [pc, #336]	; (8003748 <Codec_WriteRegister+0x214>)
 80035f8:	2101      	movs	r1, #1
 80035fa:	f7fd ff3d 	bl	8001478 <I2C_GenerateSTOP>
static uint32_t Codec_ReadRegister(uint8_t RegisterAddr)
{
  uint32_t result = 0;

  /*!< While the bus is busy */
  CODECTimeout = CODEC_LONG_TIMEOUT;
 80035fe:	f44f 1396 	mov.w	r3, #1228800	; 0x12c000
 8003602:	6023      	str	r3, [r4, #0]
  while(I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_BUSY))
 8003604:	4850      	ldr	r0, [pc, #320]	; (8003748 <Codec_WriteRegister+0x214>)
 8003606:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 800360a:	f7fe f857 	bl	80016bc <I2C_GetFlagStatus>
 800360e:	b128      	cbz	r0, 800361c <Codec_WriteRegister+0xe8>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 8003610:	6823      	ldr	r3, [r4, #0]
 8003612:	1e5a      	subs	r2, r3, #1
 8003614:	6022      	str	r2, [r4, #0]
 8003616:	2b00      	cmp	r3, #0
 8003618:	d1f4      	bne.n	8003604 <Codec_WriteRegister+0xd0>
 800361a:	e083      	b.n	8003724 <Codec_WriteRegister+0x1f0>
  }
  
  /* Start the config sequence */
  I2C_GenerateSTART(CODEC_I2C, ENABLE);
 800361c:	484a      	ldr	r0, [pc, #296]	; (8003748 <Codec_WriteRegister+0x214>)
 800361e:	2101      	movs	r1, #1
 8003620:	f7fd ff1c 	bl	800145c <I2C_GenerateSTART>

  /* Test on EV5 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 8003624:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003628:	6023      	str	r3, [r4, #0]
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 800362a:	4847      	ldr	r0, [pc, #284]	; (8003748 <Codec_WriteRegister+0x214>)
 800362c:	4947      	ldr	r1, [pc, #284]	; (800374c <Codec_WriteRegister+0x218>)
 800362e:	f7fe f831 	bl	8001694 <I2C_CheckEvent>
 8003632:	b928      	cbnz	r0, 8003640 <Codec_WriteRegister+0x10c>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 8003634:	6823      	ldr	r3, [r4, #0]
 8003636:	1e5a      	subs	r2, r3, #1
 8003638:	6022      	str	r2, [r4, #0]
 800363a:	2b00      	cmp	r3, #0
 800363c:	d1f5      	bne.n	800362a <Codec_WriteRegister+0xf6>
 800363e:	e071      	b.n	8003724 <Codec_WriteRegister+0x1f0>
  }
  
  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(CODEC_I2C, CODEC_ADDRESS, I2C_Direction_Transmitter);
 8003640:	4841      	ldr	r0, [pc, #260]	; (8003748 <Codec_WriteRegister+0x214>)
 8003642:	2194      	movs	r1, #148	; 0x94
 8003644:	2200      	movs	r2, #0
 8003646:	f7fd ff25 	bl	8001494 <I2C_Send7bitAddress>

  /* Test on EV6 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 800364a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800364e:	6023      	str	r3, [r4, #0]
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 8003650:	483d      	ldr	r0, [pc, #244]	; (8003748 <Codec_WriteRegister+0x214>)
 8003652:	493f      	ldr	r1, [pc, #252]	; (8003750 <Codec_WriteRegister+0x21c>)
 8003654:	f7fe f81e 	bl	8001694 <I2C_CheckEvent>
 8003658:	b928      	cbnz	r0, 8003666 <Codec_WriteRegister+0x132>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 800365a:	6823      	ldr	r3, [r4, #0]
 800365c:	1e5a      	subs	r2, r3, #1
 800365e:	6022      	str	r2, [r4, #0]
 8003660:	2b00      	cmp	r3, #0
 8003662:	d1f5      	bne.n	8003650 <Codec_WriteRegister+0x11c>
 8003664:	e05e      	b.n	8003724 <Codec_WriteRegister+0x1f0>
  }

  /* Transmit the register address to be read */
  I2C_SendData(CODEC_I2C, RegisterAddr);
 8003666:	4838      	ldr	r0, [pc, #224]	; (8003748 <Codec_WriteRegister+0x214>)
 8003668:	4629      	mov	r1, r5
 800366a:	f7fd ffab 	bl	80015c4 <I2C_SendData>

  /* Test on EV8 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 800366e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003672:	6023      	str	r3, [r4, #0]
  while (I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_BTF) == RESET)
 8003674:	4834      	ldr	r0, [pc, #208]	; (8003748 <Codec_WriteRegister+0x214>)
 8003676:	4938      	ldr	r1, [pc, #224]	; (8003758 <Codec_WriteRegister+0x224>)
 8003678:	f7fe f820 	bl	80016bc <I2C_GetFlagStatus>
 800367c:	b928      	cbnz	r0, 800368a <Codec_WriteRegister+0x156>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 800367e:	6823      	ldr	r3, [r4, #0]
 8003680:	1e5a      	subs	r2, r3, #1
 8003682:	6022      	str	r2, [r4, #0]
 8003684:	2b00      	cmp	r3, #0
 8003686:	d1f5      	bne.n	8003674 <Codec_WriteRegister+0x140>
 8003688:	e04c      	b.n	8003724 <Codec_WriteRegister+0x1f0>
  }
  
  /*!< Send START condition a second time */  
  I2C_GenerateSTART(CODEC_I2C, ENABLE);
 800368a:	482f      	ldr	r0, [pc, #188]	; (8003748 <Codec_WriteRegister+0x214>)
 800368c:	2101      	movs	r1, #1
 800368e:	f7fd fee5 	bl	800145c <I2C_GenerateSTART>
  
  /*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 8003692:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003696:	6023      	str	r3, [r4, #0]
  while(!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8003698:	482b      	ldr	r0, [pc, #172]	; (8003748 <Codec_WriteRegister+0x214>)
 800369a:	492c      	ldr	r1, [pc, #176]	; (800374c <Codec_WriteRegister+0x218>)
 800369c:	f7fd fffa 	bl	8001694 <I2C_CheckEvent>
 80036a0:	b928      	cbnz	r0, 80036ae <Codec_WriteRegister+0x17a>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 80036a2:	6823      	ldr	r3, [r4, #0]
 80036a4:	1e5a      	subs	r2, r3, #1
 80036a6:	6022      	str	r2, [r4, #0]
 80036a8:	2b00      	cmp	r3, #0
 80036aa:	d1f5      	bne.n	8003698 <Codec_WriteRegister+0x164>
 80036ac:	e03a      	b.n	8003724 <Codec_WriteRegister+0x1f0>
  } 
  
  /*!< Send Codec address for read */
  I2C_Send7bitAddress(CODEC_I2C, CODEC_ADDRESS, I2C_Direction_Receiver);  
 80036ae:	4826      	ldr	r0, [pc, #152]	; (8003748 <Codec_WriteRegister+0x214>)
 80036b0:	2194      	movs	r1, #148	; 0x94
 80036b2:	2201      	movs	r2, #1
 80036b4:	f7fd feee 	bl	8001494 <I2C_Send7bitAddress>
  
  /* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 80036b8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80036bc:	6023      	str	r3, [r4, #0]
  while(I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_ADDR) == RESET)
 80036be:	4d22      	ldr	r5, [pc, #136]	; (8003748 <Codec_WriteRegister+0x214>)
 80036c0:	4926      	ldr	r1, [pc, #152]	; (800375c <Codec_WriteRegister+0x228>)
 80036c2:	4628      	mov	r0, r5
 80036c4:	f7fd fffa 	bl	80016bc <I2C_GetFlagStatus>
 80036c8:	b928      	cbnz	r0, 80036d6 <Codec_WriteRegister+0x1a2>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 80036ca:	6823      	ldr	r3, [r4, #0]
 80036cc:	1e5a      	subs	r2, r3, #1
 80036ce:	6022      	str	r2, [r4, #0]
 80036d0:	2b00      	cmp	r3, #0
 80036d2:	d1f4      	bne.n	80036be <Codec_WriteRegister+0x18a>
 80036d4:	e026      	b.n	8003724 <Codec_WriteRegister+0x1f0>
  }     
  
  /*!< Disable Acknowledgment */
  I2C_AcknowledgeConfig(CODEC_I2C, DISABLE);   
 80036d6:	4628      	mov	r0, r5
 80036d8:	2100      	movs	r1, #0
 80036da:	f7fd fee5 	bl	80014a8 <I2C_AcknowledgeConfig>
  
  /* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
  (void)CODEC_I2C->SR2;
  
  /*!< Send STOP Condition */
  I2C_GenerateSTOP(CODEC_I2C, ENABLE);
 80036de:	4628      	mov	r0, r5
 80036e0:	2101      	movs	r1, #1
  
  /*!< Disable Acknowledgment */
  I2C_AcknowledgeConfig(CODEC_I2C, DISABLE);   
  
  /* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
  (void)CODEC_I2C->SR2;
 80036e2:	8b2b      	ldrh	r3, [r5, #24]
  
  /*!< Send STOP Condition */
  I2C_GenerateSTOP(CODEC_I2C, ENABLE);
 80036e4:	f7fd fec8 	bl	8001478 <I2C_GenerateSTOP>
  
  /* Wait for the byte to be received */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 80036e8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80036ec:	6023      	str	r3, [r4, #0]
  while(I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_RXNE) == RESET)
 80036ee:	4816      	ldr	r0, [pc, #88]	; (8003748 <Codec_WriteRegister+0x214>)
 80036f0:	491b      	ldr	r1, [pc, #108]	; (8003760 <Codec_WriteRegister+0x22c>)
 80036f2:	f7fd ffe3 	bl	80016bc <I2C_GetFlagStatus>
 80036f6:	b928      	cbnz	r0, 8003704 <Codec_WriteRegister+0x1d0>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 80036f8:	6823      	ldr	r3, [r4, #0]
 80036fa:	1e5a      	subs	r2, r3, #1
 80036fc:	6022      	str	r2, [r4, #0]
 80036fe:	2b00      	cmp	r3, #0
 8003700:	d1f5      	bne.n	80036ee <Codec_WriteRegister+0x1ba>
 8003702:	e00f      	b.n	8003724 <Codec_WriteRegister+0x1f0>
  }
  
  /*!< Read the byte received from the Codec */
  result = I2C_ReceiveData(CODEC_I2C);
 8003704:	4810      	ldr	r0, [pc, #64]	; (8003748 <Codec_WriteRegister+0x214>)
 8003706:	f7fd ff5f 	bl	80015c8 <I2C_ReceiveData>
  
  /* Wait to make sure that STOP flag has been cleared */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 800370a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
  }
  
  /*!< Read the byte received from the Codec */
  result = I2C_ReceiveData(CODEC_I2C);
 800370e:	4607      	mov	r7, r0
  
  /* Wait to make sure that STOP flag has been cleared */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 8003710:	6023      	str	r3, [r4, #0]
  while(CODEC_I2C->CR1 & I2C_CR1_STOP)
 8003712:	4d0d      	ldr	r5, [pc, #52]	; (8003748 <Codec_WriteRegister+0x214>)
 8003714:	882b      	ldrh	r3, [r5, #0]
 8003716:	059b      	lsls	r3, r3, #22
 8003718:	d507      	bpl.n	800372a <Codec_WriteRegister+0x1f6>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 800371a:	6823      	ldr	r3, [r4, #0]
 800371c:	1e5a      	subs	r2, r3, #1
 800371e:	6022      	str	r2, [r4, #0]
 8003720:	2b00      	cmp	r3, #0
 8003722:	d1f6      	bne.n	8003712 <Codec_WriteRegister+0x1de>
 8003724:	f001 fdcc 	bl	80052c0 <Codec_TIMEOUT_UserCallback>
 8003728:	e008      	b.n	800373c <Codec_WriteRegister+0x208>
  }  
  
  /*!< Re-Enable Acknowledgment to be ready for another reception */
  I2C_AcknowledgeConfig(CODEC_I2C, ENABLE);  
 800372a:	4628      	mov	r0, r5
 800372c:	2101      	movs	r1, #1
 800372e:	f7fd febb 	bl	80014a8 <I2C_AcknowledgeConfig>
  
  /* Clear AF flag for next communication */
  I2C_ClearFlag(CODEC_I2C, I2C_FLAG_AF); 
 8003732:	4628      	mov	r0, r5
 8003734:	490b      	ldr	r1, [pc, #44]	; (8003764 <Codec_WriteRegister+0x230>)
 8003736:	f7fd ffdd 	bl	80016f4 <I2C_ClearFlag>
  
  /* Return the byte read from Codec */
  return result;
 800373a:	4638      	mov	r0, r7
  result = (Codec_ReadRegister(RegisterAddr) == RegisterValue)? 0:1;
#endif /* VERIFY_WRITTENDATA */

  /* Return the verifying value: 0 (Passed) or 1 (Failed) */
  return result;  
}
 800373c:	1b80      	subs	r0, r0, r6
 800373e:	bf18      	it	ne
 8003740:	2001      	movne	r0, #1
 8003742:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003744:	2000002c 	.word	0x2000002c
 8003748:	40005400 	.word	0x40005400
 800374c:	00030001 	.word	0x00030001
 8003750:	00070082 	.word	0x00070082
 8003754:	00070080 	.word	0x00070080
 8003758:	10000004 	.word	0x10000004
 800375c:	10000002 	.word	0x10000002
 8003760:	10000040 	.word	0x10000040
 8003764:	10000400 	.word	0x10000400

08003768 <Codec_VolumeCtrl>:
  uint32_t counter = 0;
  
  if (Volume > 0xE6)
  {
    /* Set the Master volume */
    counter += Codec_WriteRegister(0x20, Volume - 0xE7); 
 8003768:	3019      	adds	r0, #25
  * @param  Volume: a byte value from 0 to 255 (refer to codec registers 
  *         description for more details).
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_VolumeCtrl(uint8_t Volume)
{
 800376a:	b538      	push	{r3, r4, r5, lr}
  uint32_t counter = 0;
  
  if (Volume > 0xE6)
  {
    /* Set the Master volume */
    counter += Codec_WriteRegister(0x20, Volume - 0xE7); 
 800376c:	b2c4      	uxtb	r4, r0
 800376e:	4621      	mov	r1, r4
 8003770:	2020      	movs	r0, #32
 8003772:	f7ff fedf 	bl	8003534 <Codec_WriteRegister>
    counter += Codec_WriteRegister(0x21, Volume - 0xE7);     
 8003776:	4621      	mov	r1, r4
  uint32_t counter = 0;
  
  if (Volume > 0xE6)
  {
    /* Set the Master volume */
    counter += Codec_WriteRegister(0x20, Volume - 0xE7); 
 8003778:	4605      	mov	r5, r0
    counter += Codec_WriteRegister(0x21, Volume - 0xE7);     
 800377a:	2021      	movs	r0, #33	; 0x21
 800377c:	f7ff feda 	bl	8003534 <Codec_WriteRegister>
    counter += Codec_WriteRegister(0x20, Volume + 0x19); 
    counter += Codec_WriteRegister(0x21, Volume + 0x19); 
  }

  return counter;  
}
 8003780:	4428      	add	r0, r5
 8003782:	bd38      	pop	{r3, r4, r5, pc}

08003784 <Codec_Reset>:
  * @note   This function calls an external driver function: The IO Expander driver.
  * @param  None
  * @retval None
  */
static void Codec_Reset(void)
{
 8003784:	b508      	push	{r3, lr}
  /* Power Down the codec */
  GPIO_WriteBit(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, Bit_RESET);
 8003786:	4808      	ldr	r0, [pc, #32]	; (80037a8 <Codec_Reset+0x24>)
 8003788:	2110      	movs	r1, #16
 800378a:	2200      	movs	r2, #0
 800378c:	f7fd fd68 	bl	8001260 <GPIO_WriteBit>
 8003790:	f644 73ff 	movw	r3, #20479	; 0x4fff
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void Delay( __IO uint32_t nCount)
{
  for (; nCount != 0; nCount--);
 8003794:	b10b      	cbz	r3, 800379a <Codec_Reset+0x16>
 8003796:	3b01      	subs	r3, #1
 8003798:	e7fc      	b.n	8003794 <Codec_Reset+0x10>

  /* wait for a delay to insure registers erasing */
  Delay(CODEC_RESET_DELAY); 
  
  /* Power on the codec */
  GPIO_WriteBit(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, Bit_SET);
 800379a:	4803      	ldr	r0, [pc, #12]	; (80037a8 <Codec_Reset+0x24>)
 800379c:	2110      	movs	r1, #16
 800379e:	2201      	movs	r2, #1
 80037a0:	f7fd fd5e 	bl	8001260 <GPIO_WriteBit>
 80037a4:	bd08      	pop	{r3, pc}
 80037a6:	bf00      	nop
 80037a8:	40020c00 	.word	0x40020c00

080037ac <EVAL_AUDIO_SetAudioInterface>:
  * @retval None
  */
void EVAL_AUDIO_SetAudioInterface(void)
{    
    /* DMA Stream definitions */
    AUDIO_MAL_DMA_CLOCK    = AUDIO_I2S_DMA_CLOCK;
 80037ac:	4b13      	ldr	r3, [pc, #76]	; (80037fc <EVAL_AUDIO_SetAudioInterface+0x50>)
 80037ae:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 80037b2:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_STREAM   = AUDIO_I2S_DMA_STREAM;        
 80037b4:	4a12      	ldr	r2, [pc, #72]	; (8003800 <EVAL_AUDIO_SetAudioInterface+0x54>)
 80037b6:	4b13      	ldr	r3, [pc, #76]	; (8003804 <EVAL_AUDIO_SetAudioInterface+0x58>)
 80037b8:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_DREG     = AUDIO_I2S_DMA_DREG;
 80037ba:	4b13      	ldr	r3, [pc, #76]	; (8003808 <EVAL_AUDIO_SetAudioInterface+0x5c>)
 80037bc:	f5a2 3209 	sub.w	r2, r2, #140288	; 0x22400
 80037c0:	3aac      	subs	r2, #172	; 0xac
 80037c2:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_CHANNEL  = AUDIO_I2S_DMA_CHANNEL;
 80037c4:	4b11      	ldr	r3, [pc, #68]	; (800380c <EVAL_AUDIO_SetAudioInterface+0x60>)
 80037c6:	2200      	movs	r2, #0
 80037c8:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_IRQ      = AUDIO_I2S_DMA_IRQ  ;
 80037ca:	4b11      	ldr	r3, [pc, #68]	; (8003810 <EVAL_AUDIO_SetAudioInterface+0x64>)
 80037cc:	222f      	movs	r2, #47	; 0x2f
 80037ce:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_TC  = AUDIO_I2S_DMA_FLAG_TC;
 80037d0:	4b10      	ldr	r3, [pc, #64]	; (8003814 <EVAL_AUDIO_SetAudioInterface+0x68>)
 80037d2:	f04f 5220 	mov.w	r2, #671088640	; 0x28000000
 80037d6:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_HT  = AUDIO_I2S_DMA_FLAG_HT;
 80037d8:	4b0f      	ldr	r3, [pc, #60]	; (8003818 <EVAL_AUDIO_SetAudioInterface+0x6c>)
 80037da:	f04f 5210 	mov.w	r2, #603979776	; 0x24000000
 80037de:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_FE  = AUDIO_I2S_DMA_FLAG_FE;
 80037e0:	4b0e      	ldr	r3, [pc, #56]	; (800381c <EVAL_AUDIO_SetAudioInterface+0x70>)
 80037e2:	f04f 5201 	mov.w	r2, #541065216	; 0x20400000
 80037e6:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_TE  = AUDIO_I2S_DMA_FLAG_TE;
 80037e8:	4b0d      	ldr	r3, [pc, #52]	; (8003820 <EVAL_AUDIO_SetAudioInterface+0x74>)
 80037ea:	f04f 5208 	mov.w	r2, #570425344	; 0x22000000
 80037ee:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_DME = AUDIO_I2S_DMA_FLAG_DME;
 80037f0:	4b0c      	ldr	r3, [pc, #48]	; (8003824 <EVAL_AUDIO_SetAudioInterface+0x78>)
 80037f2:	f04f 5204 	mov.w	r2, #553648128	; 0x21000000
 80037f6:	601a      	str	r2, [r3, #0]
 80037f8:	4770      	bx	lr
 80037fa:	bf00      	nop
 80037fc:	20000034 	.word	0x20000034
 8003800:	400260b8 	.word	0x400260b8
 8003804:	2000003c 	.word	0x2000003c
 8003808:	2000004c 	.word	0x2000004c
 800380c:	200005c0 	.word	0x200005c0
 8003810:	20000044 	.word	0x20000044
 8003814:	20000040 	.word	0x20000040
 8003818:	20000048 	.word	0x20000048
 800381c:	20000024 	.word	0x20000024
 8003820:	20000030 	.word	0x20000030
 8003824:	20000038 	.word	0x20000038

08003828 <EVAL_AUDIO_Init>:
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
{    
  /* Perform low layer Codec initialization */
  if (Codec_Init(OutputDevice, VOLUME_CONVERT(Volume), AudioFreq) != 0)
 8003828:	2964      	cmp	r1, #100	; 0x64
  * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
  * @param  AudioFreq: Audio frequency used to play the audio stream.
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
{    
 800382a:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800382e:	4691      	mov	r9, r2
 8003830:	f04f 0764 	mov.w	r7, #100	; 0x64
  /* Perform low layer Codec initialization */
  if (Codec_Init(OutputDevice, VOLUME_CONVERT(Volume), AudioFreq) != 0)
 8003834:	d804      	bhi.n	8003840 <EVAL_AUDIO_Init+0x18>
 8003836:	ebc1 2101 	rsb	r1, r1, r1, lsl #8
 800383a:	fb91 f7f7 	sdiv	r7, r1, r7
 800383e:	b2ff      	uxtb	r7, r7
static void Codec_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  
  /* Enable Reset GPIO Clock */
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
 8003840:	2008      	movs	r0, #8
 8003842:	2101      	movs	r1, #1
  
  /* Audio reset pin configuration -------------------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN; 
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003844:	2400      	movs	r4, #0
static void Codec_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  
  /* Enable Reset GPIO Clock */
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
 8003846:	f7fe f917 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  
  /* Audio reset pin configuration -------------------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN; 
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800384a:	2602      	movs	r6, #2
  /* Enable Reset GPIO Clock */
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
  
  /* Audio reset pin configuration -------------------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN; 
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800384c:	2501      	movs	r5, #1
  
  /* Enable Reset GPIO Clock */
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
  
  /* Audio reset pin configuration -------------------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN; 
 800384e:	f04f 0810 	mov.w	r8, #16
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(AUDIO_RESET_GPIO, &GPIO_InitStructure);    
 8003852:	487d      	ldr	r0, [pc, #500]	; (8003a48 <EVAL_AUDIO_Init+0x220>)
  
  /* Enable Reset GPIO Clock */
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
  
  /* Audio reset pin configuration -------------------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN; 
 8003854:	f8cd 8000 	str.w	r8, [sp]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(AUDIO_RESET_GPIO, &GPIO_InitStructure);    
 8003858:	4669      	mov	r1, sp
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
  
  /* Audio reset pin configuration -------------------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN; 
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800385a:	f88d 6005 	strb.w	r6, [sp, #5]
  /* Enable Reset GPIO Clock */
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
  
  /* Audio reset pin configuration -------------------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN; 
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800385e:	f88d 5004 	strb.w	r5, [sp, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003862:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 8003866:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_Init(AUDIO_RESET_GPIO, &GPIO_InitStructure);    
 800386a:	f7fd fc67 	bl	800113c <GPIO_Init>
  
  /* Enable I2S and I2C GPIO clocks */
  RCC_AHB1PeriphClockCmd(CODEC_I2C_GPIO_CLOCK | CODEC_I2S_GPIO_CLOCK, ENABLE);
 800386e:	2007      	movs	r0, #7
 8003870:	4629      	mov	r1, r5
 8003872:	f7fe f901 	bl	8001a78 <RCC_AHB1PeriphClockCmd>

  /* CODEC_I2C SCL and SDA pins configuration -------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2C_SCL_PIN | CODEC_I2C_SDA_PIN; 
 8003876:	f44f 7310 	mov.w	r3, #576	; 0x240
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(CODEC_I2C_GPIO, &GPIO_InitStructure);     
 800387a:	4874      	ldr	r0, [pc, #464]	; (8003a4c <EVAL_AUDIO_Init+0x224>)
  
  /* Enable I2S and I2C GPIO clocks */
  RCC_AHB1PeriphClockCmd(CODEC_I2C_GPIO_CLOCK | CODEC_I2S_GPIO_CLOCK, ENABLE);

  /* CODEC_I2C SCL and SDA pins configuration -------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2C_SCL_PIN | CODEC_I2C_SDA_PIN; 
 800387c:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(CODEC_I2C_GPIO, &GPIO_InitStructure);     
 800387e:	4669      	mov	r1, sp
  /* Enable I2S and I2C GPIO clocks */
  RCC_AHB1PeriphClockCmd(CODEC_I2C_GPIO_CLOCK | CODEC_I2S_GPIO_CLOCK, ENABLE);

  /* CODEC_I2C SCL and SDA pins configuration -------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2C_SCL_PIN | CODEC_I2C_SDA_PIN; 
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003880:	f88d 6004 	strb.w	r6, [sp, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003884:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8003888:	f88d 5006 	strb.w	r5, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 800388c:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_Init(CODEC_I2C_GPIO, &GPIO_InitStructure);     
 8003890:	f7fd fc54 	bl	800113c <GPIO_Init>
  /* Connect pins to I2C peripheral */
  GPIO_PinAFConfig(CODEC_I2C_GPIO, CODEC_I2S_SCL_PINSRC, CODEC_I2C_GPIO_AF);  
 8003894:	486d      	ldr	r0, [pc, #436]	; (8003a4c <EVAL_AUDIO_Init+0x224>)
 8003896:	2106      	movs	r1, #6
 8003898:	2204      	movs	r2, #4
 800389a:	f7fd fced 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(CODEC_I2C_GPIO, CODEC_I2S_SDA_PINSRC, CODEC_I2C_GPIO_AF);  
 800389e:	2204      	movs	r2, #4
 80038a0:	486a      	ldr	r0, [pc, #424]	; (8003a4c <EVAL_AUDIO_Init+0x224>)
 80038a2:	2109      	movs	r1, #9
 80038a4:	f7fd fce8 	bl	8001278 <GPIO_PinAFConfig>

  /* CODEC_I2S pins configuration: WS, SCK and SD pins -----------------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN; 
 80038a8:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);
 80038ac:	4868      	ldr	r0, [pc, #416]	; (8003a50 <EVAL_AUDIO_Init+0x228>)
  /* Connect pins to I2C peripheral */
  GPIO_PinAFConfig(CODEC_I2C_GPIO, CODEC_I2S_SCL_PINSRC, CODEC_I2C_GPIO_AF);  
  GPIO_PinAFConfig(CODEC_I2C_GPIO, CODEC_I2S_SDA_PINSRC, CODEC_I2C_GPIO_AF);  

  /* CODEC_I2S pins configuration: WS, SCK and SD pins -----------------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN; 
 80038ae:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);
 80038b0:	4669      	mov	r1, sp
  GPIO_PinAFConfig(CODEC_I2C_GPIO, CODEC_I2S_SCL_PINSRC, CODEC_I2C_GPIO_AF);  
  GPIO_PinAFConfig(CODEC_I2C_GPIO, CODEC_I2S_SDA_PINSRC, CODEC_I2C_GPIO_AF);  

  /* CODEC_I2S pins configuration: WS, SCK and SD pins -----------------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN; 
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80038b2:	f88d 6004 	strb.w	r6, [sp, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80038b6:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80038ba:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80038be:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);
 80038c2:	f7fd fc3b 	bl	800113c <GPIO_Init>
  
  /* Connect pins to I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_WS_GPIO, CODEC_I2S_WS_PINSRC, CODEC_I2S_GPIO_AF);  
 80038c6:	4863      	ldr	r0, [pc, #396]	; (8003a54 <EVAL_AUDIO_Init+0x22c>)
 80038c8:	2104      	movs	r1, #4
 80038ca:	2206      	movs	r2, #6
 80038cc:	f7fd fcd4 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SCK_PINSRC, CODEC_I2S_GPIO_AF);
 80038d0:	2206      	movs	r2, #6
 80038d2:	485f      	ldr	r0, [pc, #380]	; (8003a50 <EVAL_AUDIO_Init+0x228>)
 80038d4:	210a      	movs	r1, #10
 80038d6:	f7fd fccf 	bl	8001278 <GPIO_PinAFConfig>

  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_WS_PIN ;
  GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure); 
 80038da:	485e      	ldr	r0, [pc, #376]	; (8003a54 <EVAL_AUDIO_Init+0x22c>)
  
  /* Connect pins to I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_WS_GPIO, CODEC_I2S_WS_PINSRC, CODEC_I2S_GPIO_AF);  
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SCK_PINSRC, CODEC_I2S_GPIO_AF);

  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_WS_PIN ;
 80038dc:	f8cd 8000 	str.w	r8, [sp]
  GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure); 
 80038e0:	4669      	mov	r1, sp
 80038e2:	f7fd fc2b 	bl	800113c <GPIO_Init>
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SD_PINSRC, CODEC_I2S_GPIO_AF);
 80038e6:	2206      	movs	r2, #6
 80038e8:	4859      	ldr	r0, [pc, #356]	; (8003a50 <EVAL_AUDIO_Init+0x228>)
 80038ea:	210c      	movs	r1, #12
 80038ec:	f7fd fcc4 	bl	8001278 <GPIO_PinAFConfig>

#ifdef CODEC_MCLK_ENABLED
  /* CODEC_I2S pins configuration: MCK pin */
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_MCK_PIN; 
 80038f0:	2380      	movs	r3, #128	; 0x80
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure);   
 80038f2:	4857      	ldr	r0, [pc, #348]	; (8003a50 <EVAL_AUDIO_Init+0x228>)
  GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure); 
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SD_PINSRC, CODEC_I2S_GPIO_AF);

#ifdef CODEC_MCLK_ENABLED
  /* CODEC_I2S pins configuration: MCK pin */
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_MCK_PIN; 
 80038f4:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure);   
 80038f6:	4669      	mov	r1, sp
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SD_PINSRC, CODEC_I2S_GPIO_AF);

#ifdef CODEC_MCLK_ENABLED
  /* CODEC_I2S pins configuration: MCK pin */
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_MCK_PIN; 
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80038f8:	f88d 6004 	strb.w	r6, [sp, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80038fc:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003900:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8003904:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure);   
 8003908:	f7fd fc18 	bl	800113c <GPIO_Init>
  /* Connect pins to I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_MCK_GPIO, CODEC_I2S_MCK_PINSRC, CODEC_I2S_GPIO_AF); 
 800390c:	2206      	movs	r2, #6
 800390e:	4850      	ldr	r0, [pc, #320]	; (8003a50 <EVAL_AUDIO_Init+0x228>)
 8003910:	2107      	movs	r1, #7
 8003912:	f7fd fcb1 	bl	8001278 <GPIO_PinAFConfig>

  /* Configure the Codec related IOs */
  Codec_GPIO_Init();   
  
  /* Reset the Codec Registers */
  Codec_Reset();
 8003916:	f7ff ff35 	bl	8003784 <Codec_Reset>
static void Codec_CtrlInterface_Init(void)
{
  I2C_InitTypeDef I2C_InitStructure;
  
  /* Enable the CODEC_I2C peripheral clock */
  RCC_APB1PeriphClockCmd(CODEC_I2C_CLK, ENABLE);
 800391a:	4629      	mov	r1, r5
 800391c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003920:	f7fe f8ce 	bl	8001ac0 <RCC_APB1PeriphClockCmd>
  
  /* CODEC_I2C peripheral configuration */
  I2C_DeInit(CODEC_I2C);
 8003924:	484c      	ldr	r0, [pc, #304]	; (8003a58 <EVAL_AUDIO_Init+0x230>)
 8003926:	f7fd fcbb 	bl	80012a0 <I2C_DeInit>
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 800392a:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 800392e:	f8ad 3006 	strh.w	r3, [sp, #6]
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8003932:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003936:	f8ad 300a 	strh.w	r3, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 800393a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800393e:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
  /* Enable the I2C peripheral */
  I2C_Cmd(CODEC_I2C, ENABLE);  
 8003942:	4845      	ldr	r0, [pc, #276]	; (8003a58 <EVAL_AUDIO_Init+0x230>)
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
 8003944:	4b45      	ldr	r3, [pc, #276]	; (8003a5c <EVAL_AUDIO_Init+0x234>)
 8003946:	9300      	str	r3, [sp, #0]
  /* Enable the I2C peripheral */
  I2C_Cmd(CODEC_I2C, ENABLE);  
 8003948:	4629      	mov	r1, r5
  
  /* CODEC_I2C peripheral configuration */
  I2C_DeInit(CODEC_I2C);
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
 800394a:	f04f 0833 	mov.w	r8, #51	; 0x33
  /* Enable the CODEC_I2C peripheral clock */
  RCC_APB1PeriphClockCmd(CODEC_I2C_CLK, ENABLE);
  
  /* CODEC_I2C peripheral configuration */
  I2C_DeInit(CODEC_I2C);
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 800394e:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
 8003952:	f8ad 8008 	strh.w	r8, [sp, #8]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
  /* Enable the I2C peripheral */
  I2C_Cmd(CODEC_I2C, ENABLE);  
 8003956:	f7fd fd5b 	bl	8001410 <I2C_Cmd>
  I2C_Init(CODEC_I2C, &I2C_InitStructure);
 800395a:	483f      	ldr	r0, [pc, #252]	; (8003a58 <EVAL_AUDIO_Init+0x230>)
 800395c:	4669      	mov	r1, sp
 800395e:	f7fd fcd5 	bl	800130c <I2C_Init>

  /* Initialize the Control interface of the Audio Codec */
  Codec_CtrlInterface_Init();     
  
  /* Keep Codec powered OFF */
  counter += Codec_WriteRegister(0x02, 0x01);  
 8003962:	4630      	mov	r0, r6
 8003964:	4629      	mov	r1, r5
 8003966:	f7ff fde5 	bl	8003534 <Codec_WriteRegister>
      
  counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
 800396a:	21af      	movs	r1, #175	; 0xaf

  /* Initialize the Control interface of the Audio Codec */
  Codec_CtrlInterface_Init();     
  
  /* Keep Codec powered OFF */
  counter += Codec_WriteRegister(0x02, 0x01);  
 800396c:	4682      	mov	sl, r0
      
  counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
 800396e:	2004      	movs	r0, #4
 8003970:	f7ff fde0 	bl	8003534 <Codec_WriteRegister>
  OutputDev = 0xAF;
 8003974:	4b3a      	ldr	r3, [pc, #232]	; (8003a60 <EVAL_AUDIO_Init+0x238>)
 8003976:	22af      	movs	r2, #175	; 0xaf
  Codec_CtrlInterface_Init();     
  
  /* Keep Codec powered OFF */
  counter += Codec_WriteRegister(0x02, 0x01);  
      
  counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
 8003978:	4482      	add	sl, r0
  OutputDev = 0xAF;
  
  /* Clock configuration: Auto detection */  
  counter += Codec_WriteRegister(0x05, 0x81);
 800397a:	2181      	movs	r1, #129	; 0x81
 800397c:	2005      	movs	r0, #5
  
  /* Keep Codec powered OFF */
  counter += Codec_WriteRegister(0x02, 0x01);  
      
  counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
  OutputDev = 0xAF;
 800397e:	701a      	strb	r2, [r3, #0]
  
  /* Clock configuration: Auto detection */  
  counter += Codec_WriteRegister(0x05, 0x81);
 8003980:	f7ff fdd8 	bl	8003534 <Codec_WriteRegister>
  
  /* Set the Slave Mode and the audio Standard */  
  counter += Codec_WriteRegister(0x06, CODEC_STANDARD);
 8003984:	2104      	movs	r1, #4
      
  counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
  OutputDev = 0xAF;
  
  /* Clock configuration: Auto detection */  
  counter += Codec_WriteRegister(0x05, 0x81);
 8003986:	4482      	add	sl, r0
  
  /* Set the Slave Mode and the audio Standard */  
  counter += Codec_WriteRegister(0x06, CODEC_STANDARD);
 8003988:	2006      	movs	r0, #6
 800398a:	f7ff fdd3 	bl	8003534 <Codec_WriteRegister>
 800398e:	4482      	add	sl, r0
      
  /* Set the Master volume */
  Codec_VolumeCtrl(Volume);
 8003990:	4638      	mov	r0, r7
 8003992:	f7ff fee9 	bl	8003768 <Codec_VolumeCtrl>

  /* Power on the Codec */
  counter += Codec_WriteRegister(0x02, 0x9E);  
 8003996:	4630      	mov	r0, r6
 8003998:	219e      	movs	r1, #158	; 0x9e
 800399a:	f7ff fdcb 	bl	8003534 <Codec_WriteRegister>
      off the I2S peripheral MCLK clock (which is the operating clock for Codec).
      If this delay is not inserted, then the codec will not shut down properly and
      it results in high noise after shut down. */
  
  /* Disable the analog soft ramp */
  counter += Codec_WriteRegister(0x0A, 0x00);
 800399e:	4621      	mov	r1, r4
      
  /* Set the Master volume */
  Codec_VolumeCtrl(Volume);

  /* Power on the Codec */
  counter += Codec_WriteRegister(0x02, 0x9E);  
 80039a0:	eb0a 0600 	add.w	r6, sl, r0
      off the I2S peripheral MCLK clock (which is the operating clock for Codec).
      If this delay is not inserted, then the codec will not shut down properly and
      it results in high noise after shut down. */
  
  /* Disable the analog soft ramp */
  counter += Codec_WriteRegister(0x0A, 0x00);
 80039a4:	200a      	movs	r0, #10
 80039a6:	f7ff fdc5 	bl	8003534 <Codec_WriteRegister>
  /* Disable the digital soft ramp */
  counter += Codec_WriteRegister(0x0E, 0x04);  
 80039aa:	2104      	movs	r1, #4
      off the I2S peripheral MCLK clock (which is the operating clock for Codec).
      If this delay is not inserted, then the codec will not shut down properly and
      it results in high noise after shut down. */
  
  /* Disable the analog soft ramp */
  counter += Codec_WriteRegister(0x0A, 0x00);
 80039ac:	4406      	add	r6, r0
  /* Disable the digital soft ramp */
  counter += Codec_WriteRegister(0x0E, 0x04);  
 80039ae:	200e      	movs	r0, #14
 80039b0:	f7ff fdc0 	bl	8003534 <Codec_WriteRegister>
  /* Disable the limiter attack level */
  counter += Codec_WriteRegister(0x27, 0x00);
 80039b4:	4621      	mov	r1, r4
      it results in high noise after shut down. */
  
  /* Disable the analog soft ramp */
  counter += Codec_WriteRegister(0x0A, 0x00);
  /* Disable the digital soft ramp */
  counter += Codec_WriteRegister(0x0E, 0x04);  
 80039b6:	4406      	add	r6, r0
  /* Disable the limiter attack level */
  counter += Codec_WriteRegister(0x27, 0x00);
 80039b8:	2027      	movs	r0, #39	; 0x27
 80039ba:	f7ff fdbb 	bl	8003534 <Codec_WriteRegister>
  /* Adjust Bass and Treble levels */
  counter += Codec_WriteRegister(0x1F, 0x0F);
 80039be:	210f      	movs	r1, #15
  /* Disable the analog soft ramp */
  counter += Codec_WriteRegister(0x0A, 0x00);
  /* Disable the digital soft ramp */
  counter += Codec_WriteRegister(0x0E, 0x04);  
  /* Disable the limiter attack level */
  counter += Codec_WriteRegister(0x27, 0x00);
 80039c0:	4406      	add	r6, r0
  /* Adjust Bass and Treble levels */
  counter += Codec_WriteRegister(0x1F, 0x0F);
 80039c2:	201f      	movs	r0, #31
 80039c4:	f7ff fdb6 	bl	8003534 <Codec_WriteRegister>
  /* Adjust PCM volume level */
  counter += Codec_WriteRegister(0x1A, 0x0A);
 80039c8:	210a      	movs	r1, #10
  /* Disable the digital soft ramp */
  counter += Codec_WriteRegister(0x0E, 0x04);  
  /* Disable the limiter attack level */
  counter += Codec_WriteRegister(0x27, 0x00);
  /* Adjust Bass and Treble levels */
  counter += Codec_WriteRegister(0x1F, 0x0F);
 80039ca:	4406      	add	r6, r0
  /* Adjust PCM volume level */
  counter += Codec_WriteRegister(0x1A, 0x0A);
 80039cc:	201a      	movs	r0, #26
 80039ce:	f7ff fdb1 	bl	8003534 <Codec_WriteRegister>
  counter += Codec_WriteRegister(0x1B, 0x0A);
 80039d2:	210a      	movs	r1, #10
  /* Disable the limiter attack level */
  counter += Codec_WriteRegister(0x27, 0x00);
  /* Adjust Bass and Treble levels */
  counter += Codec_WriteRegister(0x1F, 0x0F);
  /* Adjust PCM volume level */
  counter += Codec_WriteRegister(0x1A, 0x0A);
 80039d4:	4406      	add	r6, r0
  counter += Codec_WriteRegister(0x1B, 0x0A);
 80039d6:	201b      	movs	r0, #27
 80039d8:	f7ff fdac 	bl	8003534 <Codec_WriteRegister>
static void Codec_AudioInterface_Init(uint32_t AudioFreq)
{
  I2S_InitTypeDef I2S_InitStructure;

  /* Enable the CODEC_I2S peripheral clock */
  RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, ENABLE);
 80039dc:	4629      	mov	r1, r5
  counter += Codec_WriteRegister(0x27, 0x00);
  /* Adjust Bass and Treble levels */
  counter += Codec_WriteRegister(0x1F, 0x0F);
  /* Adjust PCM volume level */
  counter += Codec_WriteRegister(0x1A, 0x0A);
  counter += Codec_WriteRegister(0x1B, 0x0A);
 80039de:	4406      	add	r6, r0
static void Codec_AudioInterface_Init(uint32_t AudioFreq)
{
  I2S_InitTypeDef I2S_InitStructure;

  /* Enable the CODEC_I2S peripheral clock */
  RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, ENABLE);
 80039e0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80039e4:	f7fe f86c 	bl	8001ac0 <RCC_APB1PeriphClockCmd>
  
  /* CODEC_I2S peripheral configuration */
  SPI_I2S_DeInit(CODEC_I2S);
 80039e8:	481e      	ldr	r0, [pc, #120]	; (8003a64 <EVAL_AUDIO_Init+0x23c>)
 80039ea:	f7fe f937 	bl	8001c5c <SPI_I2S_DeInit>
  I2S_InitStructure.I2S_AudioFreq = AudioFreq;
  I2S_InitStructure.I2S_Standard = I2S_STANDARD;
  I2S_InitStructure.I2S_DataFormat = I2S_DataFormat_16b;
  I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
  I2S_InitStructure.I2S_Mode = I2S_Mode_MasterTx;
 80039ee:	f44f 7300 	mov.w	r3, #512	; 0x200
#else
#error "No selection for the MCLK output has been defined !"
#endif /* CODEC_MCLK_ENABLED */
  
  /* Initialize the I2S peripheral with the structure above */
  I2S_Init(CODEC_I2S, &I2S_InitStructure);
 80039f2:	481c      	ldr	r0, [pc, #112]	; (8003a64 <EVAL_AUDIO_Init+0x23c>)
  /* Enable the CODEC_I2S peripheral clock */
  RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, ENABLE);
  
  /* CODEC_I2S peripheral configuration */
  SPI_I2S_DeInit(CODEC_I2S);
  I2S_InitStructure.I2S_AudioFreq = AudioFreq;
 80039f4:	f8cd 9008 	str.w	r9, [sp, #8]
#else
#error "No selection for the MCLK output has been defined !"
#endif /* CODEC_MCLK_ENABLED */
  
  /* Initialize the I2S peripheral with the structure above */
  I2S_Init(CODEC_I2S, &I2S_InitStructure);
 80039f8:	4669      	mov	r1, sp
  RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, ENABLE);
  
  /* CODEC_I2S peripheral configuration */
  SPI_I2S_DeInit(CODEC_I2S);
  I2S_InitStructure.I2S_AudioFreq = AudioFreq;
  I2S_InitStructure.I2S_Standard = I2S_STANDARD;
 80039fa:	f8ad 4002 	strh.w	r4, [sp, #2]
  I2S_InitStructure.I2S_DataFormat = I2S_DataFormat_16b;
 80039fe:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
 8003a02:	f8ad 400c 	strh.w	r4, [sp, #12]
  I2S_InitStructure.I2S_Mode = I2S_Mode_MasterTx;
 8003a06:	f8ad 3000 	strh.w	r3, [sp]
#ifdef CODEC_MCLK_ENABLED
  I2S_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Enable;
 8003a0a:	f8ad 3006 	strh.w	r3, [sp, #6]
#else
#error "No selection for the MCLK output has been defined !"
#endif /* CODEC_MCLK_ENABLED */
  
  /* Initialize the I2S peripheral with the structure above */
  I2S_Init(CODEC_I2S, &I2S_InitStructure);
 8003a0e:	f7fe f9b7 	bl	8001d80 <I2S_Init>
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
{    
  /* Perform low layer Codec initialization */
  if (Codec_Init(OutputDevice, VOLUME_CONVERT(Volume), AudioFreq) != 0)
 8003a12:	b9ae      	cbnz	r6, 8003a40 <EVAL_AUDIO_Init+0x218>

  NVIC_InitStructure.NVIC_IRQChannel = SPI3_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority =0;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
 8003a14:	4668      	mov	r0, sp
{ 
  
#ifdef I2S_INTERRUPT  
  NVIC_InitTypeDef   NVIC_InitStructure;

  NVIC_InitStructure.NVIC_IRQChannel = SPI3_IRQn;
 8003a16:	f88d 8000 	strb.w	r8, [sp]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8003a1a:	f88d 6001 	strb.w	r6, [sp, #1]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority =0;
 8003a1e:	f88d 6002 	strb.w	r6, [sp, #2]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8003a22:	f88d 5003 	strb.w	r5, [sp, #3]
  NVIC_Init(&NVIC_InitStructure);
 8003a26:	f7ff fa4f 	bl	8002ec8 <NVIC_Init>
  
  SPI_I2S_ITConfig(SPI3, SPI_I2S_IT_TXE, ENABLE);
 8003a2a:	480e      	ldr	r0, [pc, #56]	; (8003a64 <EVAL_AUDIO_Init+0x23c>)
 8003a2c:	2171      	movs	r1, #113	; 0x71
 8003a2e:	462a      	mov	r2, r5
 8003a30:	f7fe fae2 	bl	8001ff8 <SPI_I2S_ITConfig>

  I2S_Cmd(SPI3, ENABLE); 
 8003a34:	480b      	ldr	r0, [pc, #44]	; (8003a64 <EVAL_AUDIO_Init+0x23c>)
 8003a36:	4629      	mov	r1, r5
 8003a38:	f7fe fa36 	bl	8001ea8 <I2S_Cmd>
    /* I2S data transfer preparation:
    Prepare the Media to be used for the audio transfer from memory to I2S peripheral */
    Audio_MAL_Init();
    
    /* Return 0 when all operations are OK */
    return 0;
 8003a3c:	4630      	mov	r0, r6
 8003a3e:	e000      	b.n	8003a42 <EVAL_AUDIO_Init+0x21a>
uint32_t EVAL_AUDIO_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
{    
  /* Perform low layer Codec initialization */
  if (Codec_Init(OutputDevice, VOLUME_CONVERT(Volume), AudioFreq) != 0)
  {
    return 1;                
 8003a40:	4628      	mov	r0, r5
    Audio_MAL_Init();
    
    /* Return 0 when all operations are OK */
    return 0;
  }
}
 8003a42:	b004      	add	sp, #16
 8003a44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003a48:	40020c00 	.word	0x40020c00
 8003a4c:	40020400 	.word	0x40020400
 8003a50:	40020800 	.word	0x40020800
 8003a54:	40020000 	.word	0x40020000
 8003a58:	40005400 	.word	0x40005400
 8003a5c:	000186a0 	.word	0x000186a0
 8003a60:	200005c4 	.word	0x200005c4
 8003a64:	40003c00 	.word	0x40003c00

08003a68 <DMA1_Stream7_IRQHandler>:
  * @brief  This function handles main I2S interrupt. 
  * @param  None
  * @retval 0 if correct communication, else wrong communication
  */
void Audio_MAL_I2S_IRQHandler(void)
{ 
 8003a68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t Size = AudioRemSize;
#endif /* AUDIO_MAL_MODE_NORMAL */
  
#ifdef AUDIO_MAL_DMA_IT_TC_EN
  /* Transfer complete interrupt */
  if (DMA_GetFlagStatus(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC) != RESET)
 8003a6c:	4c26      	ldr	r4, [pc, #152]	; (8003b08 <DMA1_Stream7_IRQHandler+0xa0>)
 8003a6e:	4d27      	ldr	r5, [pc, #156]	; (8003b0c <DMA1_Stream7_IRQHandler+0xa4>)
 8003a70:	6820      	ldr	r0, [r4, #0]
 8003a72:	6829      	ldr	r1, [r5, #0]
 8003a74:	f7fc fec2 	bl	80007fc <DMA_GetFlagStatus>
 8003a78:	46a1      	mov	r9, r4
 8003a7a:	46a8      	mov	r8, r5
 8003a7c:	2800      	cmp	r0, #0
 8003a7e:	d040      	beq.n	8003b02 <DMA1_Stream7_IRQHandler+0x9a>
  {         
 #ifdef AUDIO_MAL_MODE_NORMAL
    /* Check if the end of file has been reached */
    if (AudioRemSize > 0)
 8003a80:	4e23      	ldr	r6, [pc, #140]	; (8003b10 <DMA1_Stream7_IRQHandler+0xa8>)
 8003a82:	6837      	ldr	r7, [r6, #0]
 8003a84:	2f00      	cmp	r7, #0
 8003a86:	d02d      	beq.n	8003ae4 <DMA1_Stream7_IRQHandler+0x7c>
    {      
      /* Wait the DMA Stream to be effectively disabled */
      while (DMA_GetCmdStatus(AUDIO_MAL_DMA_STREAM) != DISABLE)
 8003a88:	f8d9 0000 	ldr.w	r0, [r9]
 8003a8c:	4c1e      	ldr	r4, [pc, #120]	; (8003b08 <DMA1_Stream7_IRQHandler+0xa0>)
 8003a8e:	f7fc fead 	bl	80007ec <DMA_GetCmdStatus>
 8003a92:	2800      	cmp	r0, #0
 8003a94:	d1f8      	bne.n	8003a88 <DMA1_Stream7_IRQHandler+0x20>
      
      /* Clear the Interrupt flag */
      DMA_ClearFlag(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC); 
           
      /* Re-Configure the buffer address and size */
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t) CurrentPos;
 8003a96:	4d1f      	ldr	r5, [pc, #124]	; (8003b14 <DMA1_Stream7_IRQHandler+0xac>)
      /* Wait the DMA Stream to be effectively disabled */
      while (DMA_GetCmdStatus(AUDIO_MAL_DMA_STREAM) != DISABLE)
      {}
      
      /* Clear the Interrupt flag */
      DMA_ClearFlag(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC); 
 8003a98:	6820      	ldr	r0, [r4, #0]
 8003a9a:	f8d8 1000 	ldr.w	r1, [r8]
 8003a9e:	f7fc fecb 	bl	8000838 <DMA_ClearFlag>
           
      /* Re-Configure the buffer address and size */
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t) CurrentPos;
 8003aa2:	491d      	ldr	r1, [pc, #116]	; (8003b18 <DMA1_Stream7_IRQHandler+0xb0>)
 8003aa4:	682b      	ldr	r3, [r5, #0]
 8003aa6:	608b      	str	r3, [r1, #8]
      DMA_InitStructure.DMA_BufferSize = (uint32_t) (DMA_MAX(AudioRemSize));
            
      /* Configure the DMA Stream with the new parameters */
      DMA_Init(AUDIO_MAL_DMA_STREAM, &DMA_InitStructure);
 8003aa8:	6820      	ldr	r0, [r4, #0]
      /* Clear the Interrupt flag */
      DMA_ClearFlag(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC); 
           
      /* Re-Configure the buffer address and size */
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t) CurrentPos;
      DMA_InitStructure.DMA_BufferSize = (uint32_t) (DMA_MAX(AudioRemSize));
 8003aaa:	6833      	ldr	r3, [r6, #0]
 8003aac:	f64f 77ff 	movw	r7, #65535	; 0xffff
 8003ab0:	42bb      	cmp	r3, r7
 8003ab2:	bf94      	ite	ls
 8003ab4:	610b      	strls	r3, [r1, #16]
 8003ab6:	610f      	strhi	r7, [r1, #16]
            
      /* Configure the DMA Stream with the new parameters */
      DMA_Init(AUDIO_MAL_DMA_STREAM, &DMA_InitStructure);
 8003ab8:	f7fc fe0a 	bl	80006d0 <DMA_Init>
      
      /* Enable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE);    
 8003abc:	6820      	ldr	r0, [r4, #0]
 8003abe:	2101      	movs	r1, #1
 8003ac0:	f7fc fe50 	bl	8000764 <DMA_Cmd>
      
      /* Update the current pointer position */
      CurrentPos += DMA_MAX(AudioRemSize);        
 8003ac4:	6833      	ldr	r3, [r6, #0]
 8003ac6:	682a      	ldr	r2, [r5, #0]
      
      /* Update the remaining number of data to be played */
      AudioRemSize -= DMA_MAX(AudioRemSize);   
        /* Enable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE); 
 8003ac8:	6820      	ldr	r0, [r4, #0]
      
      /* Enable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE);    
      
      /* Update the current pointer position */
      CurrentPos += DMA_MAX(AudioRemSize);        
 8003aca:	42bb      	cmp	r3, r7
 8003acc:	bf38      	it	cc
 8003ace:	461f      	movcc	r7, r3
 8003ad0:	eb02 0247 	add.w	r2, r2, r7, lsl #1
      
      /* Update the remaining number of data to be played */
      AudioRemSize -= DMA_MAX(AudioRemSize);   
 8003ad4:	1bdf      	subs	r7, r3, r7
      
      /* Enable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE);    
      
      /* Update the current pointer position */
      CurrentPos += DMA_MAX(AudioRemSize);        
 8003ad6:	602a      	str	r2, [r5, #0]
      
      /* Update the remaining number of data to be played */
      AudioRemSize -= DMA_MAX(AudioRemSize);   
 8003ad8:	6037      	str	r7, [r6, #0]
        /* Enable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE); 
 8003ada:	2101      	movs	r1, #1
  * @retval 0 if correct communication, else wrong communication
  */
void Audio_MAL_I2S_IRQHandler(void)
{ 
  Audio_MAL_IRQHandler();
}
 8003adc:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      CurrentPos += DMA_MAX(AudioRemSize);        
      
      /* Update the remaining number of data to be played */
      AudioRemSize -= DMA_MAX(AudioRemSize);   
        /* Enable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE); 
 8003ae0:	f7fc be40 	b.w	8000764 <DMA_Cmd>
    }
    else
    {
      /* Disable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, DISABLE);   
 8003ae4:	6820      	ldr	r0, [r4, #0]
 8003ae6:	4639      	mov	r1, r7
 8003ae8:	f7fc fe3c 	bl	8000764 <DMA_Cmd>
      
      /* Clear the Interrupt flag */
      DMA_ClearFlag(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC);       
 8003aec:	6820      	ldr	r0, [r4, #0]
 8003aee:	6829      	ldr	r1, [r5, #0]
 8003af0:	f7fc fea2 	bl	8000838 <DMA_ClearFlag>
      
      /* Manage the remaining file size and new address offset: This function 
      should be coded by user (its prototype is already declared in stm32f401_discovery_audio_codec.h) */  
      EVAL_AUDIO_TransferComplete_CallBack((uint32_t)CurrentPos, 0);       
 8003af4:	4b07      	ldr	r3, [pc, #28]	; (8003b14 <DMA1_Stream7_IRQHandler+0xac>)
 8003af6:	4639      	mov	r1, r7
 8003af8:	6818      	ldr	r0, [r3, #0]
  * @retval 0 if correct communication, else wrong communication
  */
void Audio_MAL_I2S_IRQHandler(void)
{ 
  Audio_MAL_IRQHandler();
}
 8003afa:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      /* Clear the Interrupt flag */
      DMA_ClearFlag(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC);       
      
      /* Manage the remaining file size and new address offset: This function 
      should be coded by user (its prototype is already declared in stm32f401_discovery_audio_codec.h) */  
      EVAL_AUDIO_TransferComplete_CallBack((uint32_t)CurrentPos, 0);       
 8003afe:	f001 bbb5 	b.w	800526c <EVAL_AUDIO_TransferComplete_CallBack>
 8003b02:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8003b06:	bf00      	nop
 8003b08:	2000003c 	.word	0x2000003c
 8003b0c:	20000040 	.word	0x20000040
 8003b10:	20000028 	.word	0x20000028
 8003b14:	20000bf8 	.word	0x20000bf8
 8003b18:	20000c38 	.word	0x20000c38

08003b1c <SPI3_IRQHandler>:
  * @brief  I2S interrupt management
  * @param  None
  * @retval None
  */
void Audio_I2S_IRQHandler(void)
{
 8003b1c:	b508      	push	{r3, lr}
  /* Check on the I2S TXE flag */  
  if (SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_TXE) != RESET)
 8003b1e:	4807      	ldr	r0, [pc, #28]	; (8003b3c <SPI3_IRQHandler+0x20>)
 8003b20:	2102      	movs	r1, #2
 8003b22:	f7fe fa79 	bl	8002018 <SPI_I2S_GetFlagStatus>
 8003b26:	b138      	cbz	r0, 8003b38 <SPI3_IRQHandler+0x1c>
  { 
    /* Send dummy data on I2S to avoid the underrun condition */
    SPI_I2S_SendData(CODEC_I2S, EVAL_AUDIO_GetSampleCallBack()); 
 8003b28:	f001 fba2 	bl	8005270 <EVAL_AUDIO_GetSampleCallBack>
  }
}
 8003b2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* Check on the I2S TXE flag */  
  if (SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_TXE) != RESET)
  { 
    /* Send dummy data on I2S to avoid the underrun condition */
    SPI_I2S_SendData(CODEC_I2S, EVAL_AUDIO_GetSampleCallBack()); 
 8003b30:	4601      	mov	r1, r0
 8003b32:	4802      	ldr	r0, [pc, #8]	; (8003b3c <SPI3_IRQHandler+0x20>)
 8003b34:	f7fe ba36 	b.w	8001fa4 <SPI_I2S_SendData>
 8003b38:	bd08      	pop	{r3, pc}
 8003b3a:	bf00      	nop
 8003b3c:	40003c00 	.word	0x40003c00

08003b40 <L3GD20_SendByte>:
  *         from the SPI bus.
  * @param  Byte : Byte send.
  * @retval The received byte value
  */
static uint8_t L3GD20_SendByte(uint8_t byte)
{
 8003b40:	b538      	push	{r3, r4, r5, lr}
  /* Loop while DR register in not empty */
  L3GD20Timeout = L3GD20_FLAG_TIMEOUT;
 8003b42:	4c14      	ldr	r4, [pc, #80]	; (8003b94 <L3GD20_SendByte+0x54>)
 8003b44:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  *         from the SPI bus.
  * @param  Byte : Byte send.
  * @retval The received byte value
  */
static uint8_t L3GD20_SendByte(uint8_t byte)
{
 8003b48:	4605      	mov	r5, r0
  /* Loop while DR register in not empty */
  L3GD20Timeout = L3GD20_FLAG_TIMEOUT;
 8003b4a:	6023      	str	r3, [r4, #0]
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_TXE) == RESET)
 8003b4c:	4812      	ldr	r0, [pc, #72]	; (8003b98 <L3GD20_SendByte+0x58>)
 8003b4e:	2102      	movs	r1, #2
 8003b50:	f7fe fa62 	bl	8002018 <SPI_I2S_GetFlagStatus>
 8003b54:	b928      	cbnz	r0, 8003b62 <L3GD20_SendByte+0x22>
  {
    if((L3GD20Timeout--) == 0) return L3GD20_TIMEOUT_UserCallback();
 8003b56:	6823      	ldr	r3, [r4, #0]
 8003b58:	1e5a      	subs	r2, r3, #1
 8003b5a:	6022      	str	r2, [r4, #0]
 8003b5c:	2b00      	cmp	r3, #0
 8003b5e:	d1f5      	bne.n	8003b4c <L3GD20_SendByte+0xc>
 8003b60:	e010      	b.n	8003b84 <L3GD20_SendByte+0x44>
  }
  
  /* Send a Byte through the SPI peripheral */
  SPI_I2S_SendData(L3GD20_SPI, (uint16_t)byte);
 8003b62:	480d      	ldr	r0, [pc, #52]	; (8003b98 <L3GD20_SendByte+0x58>)
 8003b64:	4629      	mov	r1, r5
 8003b66:	f7fe fa1d 	bl	8001fa4 <SPI_I2S_SendData>
  
  /* Wait to receive a Byte */
  L3GD20Timeout = L3GD20_FLAG_TIMEOUT;
 8003b6a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003b6e:	6023      	str	r3, [r4, #0]
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_RXNE) == RESET)
 8003b70:	4809      	ldr	r0, [pc, #36]	; (8003b98 <L3GD20_SendByte+0x58>)
 8003b72:	2101      	movs	r1, #1
 8003b74:	f7fe fa50 	bl	8002018 <SPI_I2S_GetFlagStatus>
 8003b78:	b938      	cbnz	r0, 8003b8a <L3GD20_SendByte+0x4a>
  {
    if((L3GD20Timeout--) == 0) return L3GD20_TIMEOUT_UserCallback();
 8003b7a:	6823      	ldr	r3, [r4, #0]
 8003b7c:	1e5a      	subs	r2, r3, #1
 8003b7e:	6022      	str	r2, [r4, #0]
 8003b80:	2b00      	cmp	r3, #0
 8003b82:	d1f5      	bne.n	8003b70 <L3GD20_SendByte+0x30>
 8003b84:	f7ff fc38 	bl	80033f8 <L3GD20_TIMEOUT_UserCallback>
 8003b88:	e002      	b.n	8003b90 <L3GD20_SendByte+0x50>
  }
  
  /* Return the Byte read from the SPI bus */
  return (uint8_t)SPI_I2S_ReceiveData(L3GD20_SPI);
 8003b8a:	4803      	ldr	r0, [pc, #12]	; (8003b98 <L3GD20_SendByte+0x58>)
 8003b8c:	f7fe fa06 	bl	8001f9c <SPI_I2S_ReceiveData>
 8003b90:	b2c0      	uxtb	r0, r0
}
 8003b92:	bd38      	pop	{r3, r4, r5, pc}
 8003b94:	20000050 	.word	0x20000050
 8003b98:	40013000 	.word	0x40013000

08003b9c <L3GD20_Write>:
{
  /* Configure the MS bit: 
       - When 0, the address will remain unchanged in multiple read/write commands.
       - When 1, the address will be auto incremented in multiple read/write commands.
  */
  if(NumByteToWrite > 0x01)
 8003b9c:	2a01      	cmp	r2, #1
  * @param  WriteAddr : L3GD20's internal address to write to.
  * @param  NumByteToWrite: Number of bytes to write.
  * @retval None
  */
void L3GD20_Write(uint8_t* pBuffer, uint8_t WriteAddr, uint16_t NumByteToWrite)
{
 8003b9e:	b570      	push	{r4, r5, r6, lr}
 8003ba0:	460c      	mov	r4, r1
 8003ba2:	4606      	mov	r6, r0
       - When 0, the address will remain unchanged in multiple read/write commands.
       - When 1, the address will be auto incremented in multiple read/write commands.
  */
  if(NumByteToWrite > 0x01)
  {
    WriteAddr |= (uint8_t)MULTIPLEBYTE_CMD;
 8003ba4:	bf88      	it	hi
 8003ba6:	f041 0440 	orrhi.w	r4, r1, #64	; 0x40
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 8003baa:	480b      	ldr	r0, [pc, #44]	; (8003bd8 <L3GD20_Write+0x3c>)
 8003bac:	2108      	movs	r1, #8
  * @param  WriteAddr : L3GD20's internal address to write to.
  * @param  NumByteToWrite: Number of bytes to write.
  * @retval None
  */
void L3GD20_Write(uint8_t* pBuffer, uint8_t WriteAddr, uint16_t NumByteToWrite)
{
 8003bae:	4615      	mov	r5, r2
  if(NumByteToWrite > 0x01)
  {
    WriteAddr |= (uint8_t)MULTIPLEBYTE_CMD;
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 8003bb0:	f7fd fb54 	bl	800125c <GPIO_ResetBits>
  
  /* Send the Address of the indexed register */
  L3GD20_SendByte(WriteAddr);
 8003bb4:	4620      	mov	r0, r4
 8003bb6:	f7ff ffc3 	bl	8003b40 <L3GD20_SendByte>
  /* Send the data that will be written into the device (MSB First) */
  while(NumByteToWrite >= 0x01)
 8003bba:	2400      	movs	r4, #0
 8003bbc:	b2a3      	uxth	r3, r4
 8003bbe:	429d      	cmp	r5, r3
 8003bc0:	d004      	beq.n	8003bcc <L3GD20_Write+0x30>
  {
    L3GD20_SendByte(*pBuffer);
 8003bc2:	5d30      	ldrb	r0, [r6, r4]
 8003bc4:	f7ff ffbc 	bl	8003b40 <L3GD20_SendByte>
 8003bc8:	3401      	adds	r4, #1
 8003bca:	e7f7      	b.n	8003bbc <L3GD20_Write+0x20>
    NumByteToWrite--;
    pBuffer++;
  }
  
  /* Set chip select High at the end of the transmission */ 
  L3GD20_CS_HIGH();
 8003bcc:	4802      	ldr	r0, [pc, #8]	; (8003bd8 <L3GD20_Write+0x3c>)
 8003bce:	2108      	movs	r1, #8
}
 8003bd0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    NumByteToWrite--;
    pBuffer++;
  }
  
  /* Set chip select High at the end of the transmission */ 
  L3GD20_CS_HIGH();
 8003bd4:	f7fd bb40 	b.w	8001258 <GPIO_SetBits>
 8003bd8:	40021000 	.word	0x40021000

08003bdc <L3GD20_Init>:
  * @param  L3GD20_InitStruct: pointer to a L3GD20_InitTypeDef structure 
  *         that contains the configuration setting for the L3GD20.
  * @retval None
  */
void L3GD20_Init(L3GD20_InitTypeDef *L3GD20_InitStruct)
{  
 8003bdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003be0:	b089      	sub	sp, #36	; 0x24
  uint8_t ctrl1 = 0x00, ctrl4 = 0x00;
 8003be2:	2400      	movs	r4, #0
  * @param  L3GD20_InitStruct: pointer to a L3GD20_InitTypeDef structure 
  *         that contains the configuration setting for the L3GD20.
  * @retval None
  */
void L3GD20_Init(L3GD20_InitTypeDef *L3GD20_InitStruct)
{  
 8003be4:	4606      	mov	r6, r0
{
  GPIO_InitTypeDef GPIO_InitStructure;
  SPI_InitTypeDef  SPI_InitStructure;

  /* Enable the SPI periph */
  RCC_APB2PeriphClockCmd(L3GD20_SPI_CLK, ENABLE);
 8003be6:	2101      	movs	r1, #1
 8003be8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  *         that contains the configuration setting for the L3GD20.
  * @retval None
  */
void L3GD20_Init(L3GD20_InitTypeDef *L3GD20_InitStruct)
{  
  uint8_t ctrl1 = 0x00, ctrl4 = 0x00;
 8003bec:	f88d 4002 	strb.w	r4, [sp, #2]
 8003bf0:	f88d 4003 	strb.w	r4, [sp, #3]
{
  GPIO_InitTypeDef GPIO_InitStructure;
  SPI_InitTypeDef  SPI_InitStructure;

  /* Enable the SPI periph */
  RCC_APB2PeriphClockCmd(L3GD20_SPI_CLK, ENABLE);
 8003bf4:	f7fd ff70 	bl	8001ad8 <RCC_APB2PeriphClockCmd>

  /* Enable SCK, MOSI and MISO GPIO clocks */
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_SCK_GPIO_CLK | L3GD20_SPI_MISO_GPIO_CLK | L3GD20_SPI_MOSI_GPIO_CLK, ENABLE);
 8003bf8:	2001      	movs	r0, #1
 8003bfa:	4601      	mov	r1, r0
 8003bfc:	f7fd ff3c 	bl	8001a78 <RCC_AHB1PeriphClockCmd>

  /* Enable CS  GPIO clock */
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_CS_GPIO_CLK, ENABLE);
 8003c00:	2010      	movs	r0, #16
 8003c02:	2101      	movs	r1, #1
 8003c04:	f7fd ff38 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  
  /* Enable INT1 GPIO clock */
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_INT1_GPIO_CLK, ENABLE);
 8003c08:	2010      	movs	r0, #16
 8003c0a:	2101      	movs	r1, #1
  
  /* Enable INT2 GPIO clock */
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_INT2_GPIO_CLK, ENABLE);

  GPIO_PinAFConfig(L3GD20_SPI_SCK_GPIO_PORT, L3GD20_SPI_SCK_SOURCE, L3GD20_SPI_SCK_AF);
 8003c0c:	4f53      	ldr	r7, [pc, #332]	; (8003d5c <L3GD20_Init+0x180>)
  /* Configure GPIO PIN for Lis Chip select */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_CS_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(L3GD20_SPI_CS_GPIO_PORT, &GPIO_InitStructure);
 8003c0e:	f8df 9150 	ldr.w	r9, [pc, #336]	; 8003d60 <L3GD20_Init+0x184>

  /* Enable CS  GPIO clock */
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_CS_GPIO_CLK, ENABLE);
  
  /* Enable INT1 GPIO clock */
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_INT1_GPIO_CLK, ENABLE);
 8003c12:	f7fd ff31 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  
  /* Enable INT2 GPIO clock */
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_INT2_GPIO_CLK, ENABLE);
 8003c16:	2010      	movs	r0, #16
 8003c18:	2101      	movs	r1, #1
 8003c1a:	f7fd ff2d 	bl	8001a78 <RCC_AHB1PeriphClockCmd>

  GPIO_PinAFConfig(L3GD20_SPI_SCK_GPIO_PORT, L3GD20_SPI_SCK_SOURCE, L3GD20_SPI_SCK_AF);
 8003c1e:	2105      	movs	r1, #5
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN; //GPIO_PuPd_NOPULL;//
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_SCK_PIN;
 8003c20:	f04f 0a20 	mov.w	sl, #32
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_INT1_GPIO_CLK, ENABLE);
  
  /* Enable INT2 GPIO clock */
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_INT2_GPIO_CLK, ENABLE);

  GPIO_PinAFConfig(L3GD20_SPI_SCK_GPIO_PORT, L3GD20_SPI_SCK_SOURCE, L3GD20_SPI_SCK_AF);
 8003c24:	4638      	mov	r0, r7
 8003c26:	460a      	mov	r2, r1
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN; //GPIO_PuPd_NOPULL;//
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_SCK_PIN;
 8003c28:	eb0d 050a 	add.w	r5, sp, sl
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_INT1_GPIO_CLK, ENABLE);
  
  /* Enable INT2 GPIO clock */
  RCC_AHB1PeriphClockCmd(L3GD20_SPI_INT2_GPIO_CLK, ENABLE);

  GPIO_PinAFConfig(L3GD20_SPI_SCK_GPIO_PORT, L3GD20_SPI_SCK_SOURCE, L3GD20_SPI_SCK_AF);
 8003c2c:	f7fd fb24 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(L3GD20_SPI_MISO_GPIO_PORT, L3GD20_SPI_MISO_SOURCE, L3GD20_SPI_MISO_AF);
 8003c30:	4638      	mov	r0, r7
 8003c32:	2106      	movs	r1, #6
 8003c34:	2205      	movs	r2, #5
 8003c36:	f7fd fb1f 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(L3GD20_SPI_MOSI_GPIO_PORT, L3GD20_SPI_MOSI_SOURCE, L3GD20_SPI_MOSI_AF);
 8003c3a:	2205      	movs	r2, #5
 8003c3c:	4638      	mov	r0, r7
 8003c3e:	2107      	movs	r1, #7
 8003c40:	f7fd fb1a 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN; //GPIO_PuPd_NOPULL;//
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_SCK_PIN;
 8003c44:	f845 ad1c 	str.w	sl, [r5, #-28]!

  GPIO_PinAFConfig(L3GD20_SPI_SCK_GPIO_PORT, L3GD20_SPI_SCK_SOURCE, L3GD20_SPI_SCK_AF);
  GPIO_PinAFConfig(L3GD20_SPI_MISO_GPIO_PORT, L3GD20_SPI_MISO_SOURCE, L3GD20_SPI_MISO_AF);
  GPIO_PinAFConfig(L3GD20_SPI_MOSI_GPIO_PORT, L3GD20_SPI_MOSI_SOURCE, L3GD20_SPI_MOSI_AF);

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003c48:	f04f 0802 	mov.w	r8, #2
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN; //GPIO_PuPd_NOPULL;//
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_SCK_PIN;
  GPIO_Init(L3GD20_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 8003c4c:	4638      	mov	r0, r7
 8003c4e:	4629      	mov	r1, r5

  GPIO_PinAFConfig(L3GD20_SPI_SCK_GPIO_PORT, L3GD20_SPI_SCK_SOURCE, L3GD20_SPI_SCK_AF);
  GPIO_PinAFConfig(L3GD20_SPI_MISO_GPIO_PORT, L3GD20_SPI_MISO_SOURCE, L3GD20_SPI_MISO_AF);
  GPIO_PinAFConfig(L3GD20_SPI_MOSI_GPIO_PORT, L3GD20_SPI_MOSI_SOURCE, L3GD20_SPI_MOSI_AF);

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003c50:	f88d 8008 	strb.w	r8, [sp, #8]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003c54:	f88d 400a 	strb.w	r4, [sp, #10]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN; //GPIO_PuPd_NOPULL;//
 8003c58:	f88d 800b 	strb.w	r8, [sp, #11]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003c5c:	f88d 8009 	strb.w	r8, [sp, #9]

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_SCK_PIN;
  GPIO_Init(L3GD20_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 8003c60:	f7fd fa6c 	bl	800113c <GPIO_Init>

  /* SPI  MOSI pin configuration */
  GPIO_InitStructure.GPIO_Pin =  L3GD20_SPI_MOSI_PIN;
 8003c64:	2380      	movs	r3, #128	; 0x80
  GPIO_Init(L3GD20_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
 8003c66:	4638      	mov	r0, r7
 8003c68:	4629      	mov	r1, r5
  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_SCK_PIN;
  GPIO_Init(L3GD20_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);

  /* SPI  MOSI pin configuration */
  GPIO_InitStructure.GPIO_Pin =  L3GD20_SPI_MOSI_PIN;
 8003c6a:	9301      	str	r3, [sp, #4]
  GPIO_Init(L3GD20_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
 8003c6c:	f7fd fa66 	bl	800113c <GPIO_Init>

  /* SPI MISO pin configuration */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_MISO_PIN;
 8003c70:	2340      	movs	r3, #64	; 0x40
  GPIO_Init(L3GD20_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
 8003c72:	4629      	mov	r1, r5
 8003c74:	4638      	mov	r0, r7

  /* SPI configuration -------------------------------------------------------*/
  SPI_I2S_DeInit(L3GD20_SPI);
 8003c76:	f5a7 4750 	sub.w	r7, r7, #53248	; 0xd000
  /* SPI  MOSI pin configuration */
  GPIO_InitStructure.GPIO_Pin =  L3GD20_SPI_MOSI_PIN;
  GPIO_Init(L3GD20_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);

  /* SPI MISO pin configuration */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_MISO_PIN;
 8003c7a:	9301      	str	r3, [sp, #4]
  GPIO_Init(L3GD20_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
 8003c7c:	f7fd fa5e 	bl	800113c <GPIO_Init>

  /* SPI configuration -------------------------------------------------------*/
  SPI_I2S_DeInit(L3GD20_SPI);
 8003c80:	4638      	mov	r0, r7
 8003c82:	f7fd ffeb 	bl	8001c5c <SPI_I2S_DeInit>
  SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
  SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
  SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
  SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 8003c86:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003c8a:	f8ad 3016 	strh.w	r3, [sp, #22]
  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
 8003c8e:	2310      	movs	r3, #16
 8003c90:	f8ad 3018 	strh.w	r3, [sp, #24]
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
  SPI_InitStructure.SPI_CRCPolynomial = 7;
 8003c94:	2307      	movs	r3, #7
 8003c96:	f8ad 301c 	strh.w	r3, [sp, #28]
  SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
  SPI_Init(L3GD20_SPI, &SPI_InitStructure);
 8003c9a:	4638      	mov	r0, r7
  SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
  SPI_InitStructure.SPI_CRCPolynomial = 7;
  SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 8003c9c:	f44f 7382 	mov.w	r3, #260	; 0x104
  SPI_Init(L3GD20_SPI, &SPI_InitStructure);
 8003ca0:	a903      	add	r1, sp, #12
  SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
  SPI_InitStructure.SPI_CRCPolynomial = 7;
  SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 8003ca2:	f8ad 300e 	strh.w	r3, [sp, #14]
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_MISO_PIN;
  GPIO_Init(L3GD20_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);

  /* SPI configuration -------------------------------------------------------*/
  SPI_I2S_DeInit(L3GD20_SPI);
  SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8003ca6:	f8ad 400c 	strh.w	r4, [sp, #12]
  SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 8003caa:	f8ad 4010 	strh.w	r4, [sp, #16]
  SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8003cae:	f8ad 4012 	strh.w	r4, [sp, #18]
  SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 8003cb2:	f8ad 4014 	strh.w	r4, [sp, #20]
  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 8003cb6:	f8ad 401a 	strh.w	r4, [sp, #26]
  SPI_InitStructure.SPI_CRCPolynomial = 7;
  SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
  SPI_Init(L3GD20_SPI, &SPI_InitStructure);
 8003cba:	f7fe f837 	bl	8001d2c <SPI_Init>

  /* Enable SPI1  */
  SPI_Cmd(L3GD20_SPI, ENABLE);
 8003cbe:	4638      	mov	r0, r7
 8003cc0:	2101      	movs	r1, #1
 8003cc2:	f7fe f8e3 	bl	8001e8c <SPI_Cmd>

  /* Configure GPIO PIN for Lis Chip select */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_CS_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8003cc6:	2701      	movs	r7, #1

  /* Enable SPI1  */
  SPI_Cmd(L3GD20_SPI, ENABLE);

  /* Configure GPIO PIN for Lis Chip select */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_CS_PIN;
 8003cc8:	f04f 0b08 	mov.w	fp, #8
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(L3GD20_SPI_CS_GPIO_PORT, &GPIO_InitStructure);
 8003ccc:	4648      	mov	r0, r9
 8003cce:	4629      	mov	r1, r5

  /* Enable SPI1  */
  SPI_Cmd(L3GD20_SPI, ENABLE);

  /* Configure GPIO PIN for Lis Chip select */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_CS_PIN;
 8003cd0:	f8cd b004 	str.w	fp, [sp, #4]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8003cd4:	f88d 7008 	strb.w	r7, [sp, #8]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003cd8:	f88d 400a 	strb.w	r4, [sp, #10]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003cdc:	f88d 8009 	strb.w	r8, [sp, #9]
  GPIO_Init(L3GD20_SPI_CS_GPIO_PORT, &GPIO_InitStructure);
 8003ce0:	f7fd fa2c 	bl	800113c <GPIO_Init>

  /* Deselect : Chip Select high */
  GPIO_SetBits(L3GD20_SPI_CS_GPIO_PORT, L3GD20_SPI_CS_PIN);
 8003ce4:	4648      	mov	r0, r9
 8003ce6:	4659      	mov	r1, fp
 8003ce8:	f7fd fab6 	bl	8001258 <GPIO_SetBits>
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_INT1_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(L3GD20_SPI_INT1_GPIO_PORT, &GPIO_InitStructure);
 8003cec:	4648      	mov	r0, r9
 8003cee:	4629      	mov	r1, r5

  /* Deselect : Chip Select high */
  GPIO_SetBits(L3GD20_SPI_CS_GPIO_PORT, L3GD20_SPI_CS_PIN);
  
  /* Configure GPIO PINs to detect Interrupts */
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_INT1_PIN;
 8003cf0:	9701      	str	r7, [sp, #4]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8003cf2:	f88d 4008 	strb.w	r4, [sp, #8]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003cf6:	f88d 400a 	strb.w	r4, [sp, #10]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003cfa:	f88d 8009 	strb.w	r8, [sp, #9]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 8003cfe:	f88d 400b 	strb.w	r4, [sp, #11]
  GPIO_Init(L3GD20_SPI_INT1_GPIO_PORT, &GPIO_InitStructure);
 8003d02:	f7fd fa1b 	bl	800113c <GPIO_Init>
  
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_INT2_PIN;
  GPIO_Init(L3GD20_SPI_INT2_GPIO_PORT, &GPIO_InitStructure);
 8003d06:	4648      	mov	r0, r9
 8003d08:	4629      	mov	r1, r5
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(L3GD20_SPI_INT1_GPIO_PORT, &GPIO_InitStructure);
  
  GPIO_InitStructure.GPIO_Pin = L3GD20_SPI_INT2_PIN;
 8003d0a:	f8cd 8004 	str.w	r8, [sp, #4]
  GPIO_Init(L3GD20_SPI_INT2_GPIO_PORT, &GPIO_InitStructure);
 8003d0e:	f7fd fa15 	bl	800113c <GPIO_Init>
  
  /* Configure the low level interface ---------------------------------------*/
  L3GD20_LowLevel_Init();
  
  /* Configure MEMS: data rate, power mode, full scale and axes */
  ctrl1 |= (uint8_t) (L3GD20_InitStruct->Power_Mode | L3GD20_InitStruct->Output_DataRate | \
 8003d12:	7832      	ldrb	r2, [r6, #0]
 8003d14:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8003d18:	4313      	orrs	r3, r2
 8003d1a:	7872      	ldrb	r2, [r6, #1]
 8003d1c:	4313      	orrs	r3, r2
 8003d1e:	78b2      	ldrb	r2, [r6, #2]
 8003d20:	4313      	orrs	r3, r2
 8003d22:	78f2      	ldrb	r2, [r6, #3]
 8003d24:	4313      	orrs	r3, r2
 8003d26:	f88d 3002 	strb.w	r3, [sp, #2]
                    L3GD20_InitStruct->Axes_Enable | L3GD20_InitStruct->Band_Width);
  
  ctrl4 |= (uint8_t) (L3GD20_InitStruct->BlockData_Update | L3GD20_InitStruct->Endianness | \
 8003d2a:	7932      	ldrb	r2, [r6, #4]
 8003d2c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8003d30:	4313      	orrs	r3, r2
 8003d32:	7972      	ldrb	r2, [r6, #5]
 8003d34:	4313      	orrs	r3, r2
 8003d36:	79b2      	ldrb	r2, [r6, #6]
                    L3GD20_InitStruct->Full_Scale);
                    
  /* Write value to MEMS CTRL_REG1 regsister */
  L3GD20_Write(&ctrl1, L3GD20_CTRL_REG1_ADDR, 1);
 8003d38:	eb0d 0008 	add.w	r0, sp, r8
  
  /* Configure MEMS: data rate, power mode, full scale and axes */
  ctrl1 |= (uint8_t) (L3GD20_InitStruct->Power_Mode | L3GD20_InitStruct->Output_DataRate | \
                    L3GD20_InitStruct->Axes_Enable | L3GD20_InitStruct->Band_Width);
  
  ctrl4 |= (uint8_t) (L3GD20_InitStruct->BlockData_Update | L3GD20_InitStruct->Endianness | \
 8003d3c:	4313      	orrs	r3, r2
                    L3GD20_InitStruct->Full_Scale);
                    
  /* Write value to MEMS CTRL_REG1 regsister */
  L3GD20_Write(&ctrl1, L3GD20_CTRL_REG1_ADDR, 1);
 8003d3e:	4651      	mov	r1, sl
 8003d40:	463a      	mov	r2, r7
  
  /* Configure MEMS: data rate, power mode, full scale and axes */
  ctrl1 |= (uint8_t) (L3GD20_InitStruct->Power_Mode | L3GD20_InitStruct->Output_DataRate | \
                    L3GD20_InitStruct->Axes_Enable | L3GD20_InitStruct->Band_Width);
  
  ctrl4 |= (uint8_t) (L3GD20_InitStruct->BlockData_Update | L3GD20_InitStruct->Endianness | \
 8003d42:	f88d 3003 	strb.w	r3, [sp, #3]
                    L3GD20_InitStruct->Full_Scale);
                    
  /* Write value to MEMS CTRL_REG1 regsister */
  L3GD20_Write(&ctrl1, L3GD20_CTRL_REG1_ADDR, 1);
 8003d46:	f7ff ff29 	bl	8003b9c <L3GD20_Write>
  
  /* Write value to MEMS CTRL_REG4 regsister */
  L3GD20_Write(&ctrl4, L3GD20_CTRL_REG4_ADDR, 1);
 8003d4a:	f10d 0003 	add.w	r0, sp, #3
 8003d4e:	2123      	movs	r1, #35	; 0x23
 8003d50:	463a      	mov	r2, r7
 8003d52:	f7ff ff23 	bl	8003b9c <L3GD20_Write>
}
 8003d56:	b009      	add	sp, #36	; 0x24
 8003d58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003d5c:	40020000 	.word	0x40020000
 8003d60:	40021000 	.word	0x40021000

08003d64 <L3GD20_Read>:
  * @param  NumByteToRead : number of bytes to read from the L3GD20.
  * @retval None
  */
void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{  
  if(NumByteToRead > 0x01)
 8003d64:	2a01      	cmp	r2, #1
  * @param  ReadAddr : L3GD20's internal address to read from.
  * @param  NumByteToRead : number of bytes to read from the L3GD20.
  * @retval None
  */
void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{  
 8003d66:	b570      	push	{r4, r5, r6, lr}
  if(NumByteToRead > 0x01)
  {
    ReadAddr |= (uint8_t)(READWRITE_CMD | MULTIPLEBYTE_CMD);
 8003d68:	bf8c      	ite	hi
 8003d6a:	f041 04c0 	orrhi.w	r4, r1, #192	; 0xc0
  }
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
 8003d6e:	f041 0480 	orrls.w	r4, r1, #128	; 0x80
  * @param  ReadAddr : L3GD20's internal address to read from.
  * @param  NumByteToRead : number of bytes to read from the L3GD20.
  * @retval None
  */
void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{  
 8003d72:	4606      	mov	r6, r0
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 8003d74:	2108      	movs	r1, #8
 8003d76:	480b      	ldr	r0, [pc, #44]	; (8003da4 <L3GD20_Read+0x40>)
  * @param  ReadAddr : L3GD20's internal address to read from.
  * @param  NumByteToRead : number of bytes to read from the L3GD20.
  * @retval None
  */
void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{  
 8003d78:	4615      	mov	r5, r2
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 8003d7a:	f7fd fa6f 	bl	800125c <GPIO_ResetBits>
  
  /* Send the Address of the indexed register */
  L3GD20_SendByte(ReadAddr);
 8003d7e:	4620      	mov	r0, r4
 8003d80:	f7ff fede 	bl	8003b40 <L3GD20_SendByte>
  
  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
 8003d84:	2400      	movs	r4, #0
 8003d86:	b2a3      	uxth	r3, r4
 8003d88:	429d      	cmp	r5, r3
 8003d8a:	d005      	beq.n	8003d98 <L3GD20_Read+0x34>
  {
    /* Send dummy byte (0x00) to generate the SPI clock to L3GD20 (Slave device) */
    *pBuffer = L3GD20_SendByte(DUMMY_BYTE);
 8003d8c:	2000      	movs	r0, #0
 8003d8e:	f7ff fed7 	bl	8003b40 <L3GD20_SendByte>
 8003d92:	5530      	strb	r0, [r6, r4]
 8003d94:	3401      	adds	r4, #1
 8003d96:	e7f6      	b.n	8003d86 <L3GD20_Read+0x22>
    NumByteToRead--;
    pBuffer++;
  }
  
  /* Set chip select High at the end of the transmission */ 
  L3GD20_CS_HIGH();
 8003d98:	4802      	ldr	r0, [pc, #8]	; (8003da4 <L3GD20_Read+0x40>)
 8003d9a:	2108      	movs	r1, #8
}  
 8003d9c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    NumByteToRead--;
    pBuffer++;
  }
  
  /* Set chip select High at the end of the transmission */ 
  L3GD20_CS_HIGH();
 8003da0:	f7fd ba5a 	b.w	8001258 <GPIO_SetBits>
 8003da4:	40021000 	.word	0x40021000

08003da8 <L3GD20_FilterConfig>:
  * @param  L3GD20_FilterStruct: pointer to a L3GD20_FilterConfigTypeDef structure 
  *         that contains the configuration setting for the L3GD20.        
  * @retval None
  */
void L3GD20_FilterConfig(L3GD20_FilterConfigTypeDef *L3GD20_FilterStruct) 
{
 8003da8:	b513      	push	{r0, r1, r4, lr}
 8003daa:	4604      	mov	r4, r0
  uint8_t tmpreg;
  
  /* Read CTRL_REG2 register */
  L3GD20_Read(&tmpreg, L3GD20_CTRL_REG2_ADDR, 1);
 8003dac:	2121      	movs	r1, #33	; 0x21
 8003dae:	f10d 0007 	add.w	r0, sp, #7
 8003db2:	2201      	movs	r2, #1
 8003db4:	f7ff ffd6 	bl	8003d64 <L3GD20_Read>
  
  tmpreg &= 0xC0;
  
  /* Configure MEMS: mode and cutoff frquency */
  tmpreg |= (uint8_t) (L3GD20_FilterStruct->HighPassFilter_Mode_Selection |\
 8003db8:	7862      	ldrb	r2, [r4, #1]
 8003dba:	7823      	ldrb	r3, [r4, #0]
 8003dbc:	4313      	orrs	r3, r2
  uint8_t tmpreg;
  
  /* Read CTRL_REG2 register */
  L3GD20_Read(&tmpreg, L3GD20_CTRL_REG2_ADDR, 1);
  
  tmpreg &= 0xC0;
 8003dbe:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8003dc2:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
  
  /* Configure MEMS: mode and cutoff frquency */
  tmpreg |= (uint8_t) (L3GD20_FilterStruct->HighPassFilter_Mode_Selection |\
 8003dc6:	4313      	orrs	r3, r2
                      L3GD20_FilterStruct->HighPassFilter_CutOff_Frequency);                             

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_Write(&tmpreg, L3GD20_CTRL_REG2_ADDR, 1);
 8003dc8:	f10d 0007 	add.w	r0, sp, #7
 8003dcc:	2121      	movs	r1, #33	; 0x21
 8003dce:	2201      	movs	r2, #1
  L3GD20_Read(&tmpreg, L3GD20_CTRL_REG2_ADDR, 1);
  
  tmpreg &= 0xC0;
  
  /* Configure MEMS: mode and cutoff frquency */
  tmpreg |= (uint8_t) (L3GD20_FilterStruct->HighPassFilter_Mode_Selection |\
 8003dd0:	f88d 3007 	strb.w	r3, [sp, #7]
                      L3GD20_FilterStruct->HighPassFilter_CutOff_Frequency);                             

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_Write(&tmpreg, L3GD20_CTRL_REG2_ADDR, 1);
 8003dd4:	f7ff fee2 	bl	8003b9c <L3GD20_Write>
}
 8003dd8:	b002      	add	sp, #8
 8003dda:	bd10      	pop	{r4, pc}

08003ddc <L3GD20_FilterCmd>:
  *         @arg: L3GD20_HIGHPASSFILTER_DISABLE 
  *         @arg: L3GD20_HIGHPASSFILTER_ENABLE          
  * @retval None
  */
void L3GD20_FilterCmd(uint8_t HighPassFilterState)
{
 8003ddc:	b513      	push	{r0, r1, r4, lr}
  uint8_t tmpreg;
  
  /* Read CTRL_REG5 register */
  L3GD20_Read(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 8003dde:	2201      	movs	r2, #1
  *         @arg: L3GD20_HIGHPASSFILTER_DISABLE 
  *         @arg: L3GD20_HIGHPASSFILTER_ENABLE          
  * @retval None
  */
void L3GD20_FilterCmd(uint8_t HighPassFilterState)
{
 8003de0:	4604      	mov	r4, r0
  uint8_t tmpreg;
  
  /* Read CTRL_REG5 register */
  L3GD20_Read(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 8003de2:	2124      	movs	r1, #36	; 0x24
 8003de4:	f10d 0007 	add.w	r0, sp, #7
 8003de8:	f7ff ffbc 	bl	8003d64 <L3GD20_Read>
  
  tmpreg &= 0xEF;
 8003dec:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003df0:	f023 0310 	bic.w	r3, r3, #16
  
  tmpreg |= HighPassFilterState;
 8003df4:	431c      	orrs	r4, r3
  
  /* Write value to MEMS CTRL_REG5 regsister */
  L3GD20_Write(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 8003df6:	f10d 0007 	add.w	r0, sp, #7
 8003dfa:	2124      	movs	r1, #36	; 0x24
 8003dfc:	2201      	movs	r2, #1
  /* Read CTRL_REG5 register */
  L3GD20_Read(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
  
  tmpreg &= 0xEF;
  
  tmpreg |= HighPassFilterState;
 8003dfe:	f88d 4007 	strb.w	r4, [sp, #7]
  
  /* Write value to MEMS CTRL_REG5 regsister */
  L3GD20_Write(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 8003e02:	f7ff fecb 	bl	8003b9c <L3GD20_Write>
}
 8003e06:	b002      	add	sp, #8
 8003e08:	bd10      	pop	{r4, pc}
	...

08003e0c <LSM303DLHC_LowLevel_Init>:
* @brief  Initializes the low level interface used to drive the LSM303DLHC
* @param  None
* @retval None
*/
static void LSM303DLHC_LowLevel_Init(void)
{
 8003e0c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  I2C_InitTypeDef  I2C_InitStructure;
  
  /* Enable the I2C periph */
  RCC_APB1PeriphClockCmd(LSM303DLHC_I2C_CLK, ENABLE);
 8003e10:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
* @brief  Initializes the low level interface used to drive the LSM303DLHC
* @param  None
* @retval None
*/
static void LSM303DLHC_LowLevel_Init(void)
{
 8003e14:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  I2C_InitTypeDef  I2C_InitStructure;
  
  /* Enable the I2C periph */
  RCC_APB1PeriphClockCmd(LSM303DLHC_I2C_CLK, ENABLE);
 8003e16:	2101      	movs	r1, #1
 8003e18:	f7fd fe52 	bl	8001ac0 <RCC_APB1PeriphClockCmd>
  
  /* Enable SCK and SDA GPIO clocks */
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_SCK_GPIO_CLK | LSM303DLHC_I2C_SDA_GPIO_CLK , ENABLE);
 8003e1c:	2002      	movs	r0, #2
 8003e1e:	2101      	movs	r1, #1
 8003e20:	f7fd fe2a 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  
  /* Enable INT1 GPIO clock */
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_INT1_GPIO_CLK, ENABLE);
 8003e24:	2010      	movs	r0, #16
 8003e26:	2101      	movs	r1, #1
 8003e28:	f7fd fe26 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_INT2_GPIO_CLK, ENABLE);
  
  /* Enable DRDY clock */
  RCC_AHB1PeriphClockCmd(LSM303DLHC_DRDY_GPIO_CLK, ENABLE);
  
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
 8003e2c:	4f42      	ldr	r7, [pc, #264]	; (8003f38 <LSM303DLHC_LowLevel_Init+0x12c>)
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = LSM303DLHC_MAX_COMMUNICATION_FREQ;
  
  /* Apply LSM303DLHC_I2C configuration after enabling it */
  I2C_Init(LSM303DLHC_I2C, &I2C_InitStructure);
 8003e2e:	f8df 9110 	ldr.w	r9, [pc, #272]	; 8003f40 <LSM303DLHC_LowLevel_Init+0x134>
  
  /* Enable INT1 GPIO clock */
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_INT1_GPIO_CLK, ENABLE);
  
  /* Enable INT2 GPIO clock */
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_INT2_GPIO_CLK, ENABLE);
 8003e32:	2010      	movs	r0, #16
 8003e34:	2101      	movs	r1, #1
 8003e36:	f7fd fe1f 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  
  /* Enable DRDY clock */
  RCC_AHB1PeriphClockCmd(LSM303DLHC_DRDY_GPIO_CLK, ENABLE);
 8003e3a:	2010      	movs	r0, #16
 8003e3c:	2101      	movs	r1, #1
 8003e3e:	f7fd fe1b 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
 8003e42:	4638      	mov	r0, r7
 8003e44:	2106      	movs	r1, #6
 8003e46:	2204      	movs	r2, #4
 8003e48:	f7fd fa16 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  
  /* I2C SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
 8003e4c:	ad08      	add	r5, sp, #32
  
  /* Enable DRDY clock */
  RCC_AHB1PeriphClockCmd(LSM303DLHC_DRDY_GPIO_CLK, ENABLE);
  
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
  GPIO_PinAFConfig(LSM303DLHC_I2C_SDA_GPIO_PORT, LSM303DLHC_I2C_SDA_SOURCE, LSM303DLHC_I2C_SDA_AF);
 8003e4e:	2204      	movs	r2, #4
 8003e50:	4638      	mov	r0, r7
 8003e52:	2109      	movs	r1, #9
 8003e54:	f7fd fa10 	bl	8001278 <GPIO_PinAFConfig>
  
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003e58:	2400      	movs	r4, #0
  RCC_AHB1PeriphClockCmd(LSM303DLHC_DRDY_GPIO_CLK, ENABLE);
  
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
  GPIO_PinAFConfig(LSM303DLHC_I2C_SDA_GPIO_PORT, LSM303DLHC_I2C_SDA_SOURCE, LSM303DLHC_I2C_SDA_AF);
  
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003e5a:	2602      	movs	r6, #2
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  
  /* I2C SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
 8003e5c:	2340      	movs	r3, #64	; 0x40
  GPIO_Init(LSM303DLHC_I2C_SCK_GPIO_PORT, &GPIO_InitStructure);
 8003e5e:	4638      	mov	r0, r7
 8003e60:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  
  /* I2C SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
 8003e62:	f845 3d20 	str.w	r3, [r5, #-32]!
  RCC_AHB1PeriphClockCmd(LSM303DLHC_DRDY_GPIO_CLK, ENABLE);
  
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
  GPIO_PinAFConfig(LSM303DLHC_I2C_SDA_GPIO_PORT, LSM303DLHC_I2C_SDA_SOURCE, LSM303DLHC_I2C_SDA_AF);
  
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003e66:	f88d 6004 	strb.w	r6, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003e6a:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
 8003e6e:	f88d 6007 	strb.w	r6, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003e72:	f88d 6005 	strb.w	r6, [sp, #5]
  
  /* I2C SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
  GPIO_Init(LSM303DLHC_I2C_SCK_GPIO_PORT, &GPIO_InitStructure);
 8003e76:	f7fd f961 	bl	800113c <GPIO_Init>
  
  /* I2C SDA pin configuration */
  GPIO_InitStructure.GPIO_Pin =  LSM303DLHC_I2C_SDA_PIN;
 8003e7a:	f44f 7300 	mov.w	r3, #512	; 0x200
  GPIO_Init(LSM303DLHC_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
 8003e7e:	4638      	mov	r0, r7
 8003e80:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  
  /* Mems DRDY pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_DRDY_PIN;
  GPIO_Init(LSM303DLHC_DRDY_GPIO_PORT, &GPIO_InitStructure);
 8003e82:	f507 6740 	add.w	r7, r7, #3072	; 0xc00
  /* I2C SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
  GPIO_Init(LSM303DLHC_I2C_SCK_GPIO_PORT, &GPIO_InitStructure);
  
  /* I2C SDA pin configuration */
  GPIO_InitStructure.GPIO_Pin =  LSM303DLHC_I2C_SDA_PIN;
 8003e86:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  
  /* Mems DRDY pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_DRDY_PIN;
 8003e88:	f04f 0804 	mov.w	r8, #4
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
  GPIO_Init(LSM303DLHC_I2C_SCK_GPIO_PORT, &GPIO_InitStructure);
  
  /* I2C SDA pin configuration */
  GPIO_InitStructure.GPIO_Pin =  LSM303DLHC_I2C_SDA_PIN;
  GPIO_Init(LSM303DLHC_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
 8003e8c:	f7fd f956 	bl	800113c <GPIO_Init>
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  
  /* Mems DRDY pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_DRDY_PIN;
  GPIO_Init(LSM303DLHC_DRDY_GPIO_PORT, &GPIO_InitStructure);
 8003e90:	4638      	mov	r0, r7
 8003e92:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  
  /* Mems DRDY pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_DRDY_PIN;
 8003e94:	f8cd 8000 	str.w	r8, [sp]
  /* I2C SDA pin configuration */
  GPIO_InitStructure.GPIO_Pin =  LSM303DLHC_I2C_SDA_PIN;
  GPIO_Init(LSM303DLHC_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
  
  /* Mems DRDY */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8003e98:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003e9c:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 8003ea0:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003ea4:	f88d 6005 	strb.w	r6, [sp, #5]
  
  /* Mems DRDY pin configuration */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_DRDY_PIN;
  GPIO_Init(LSM303DLHC_DRDY_GPIO_PORT, &GPIO_InitStructure);
 8003ea8:	f7fd f948 	bl	800113c <GPIO_Init>
  
  /* Connect EXTI Line to Mems DRDY Pin */
  SYSCFG_EXTILineConfig(LSM303DLHC_DRDY_EXTI_PORT_SOURCE, LSM303DLHC_DRDY_EXTI_PIN_SOURCE);
 8003eac:	4631      	mov	r1, r6
 8003eae:	4640      	mov	r0, r8
 8003eb0:	f7fe f8f6 	bl	80020a0 <SYSCFG_EXTILineConfig>
  
  EXTI_InitStructure.EXTI_Line = LSM303DLHC_DRDY_EXTI_LINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 8003eb4:	2308      	movs	r3, #8
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  
  EXTI_Init(&EXTI_InitStructure);
 8003eb6:	eb0d 0003 	add.w	r0, sp, r3
  GPIO_Init(LSM303DLHC_DRDY_GPIO_PORT, &GPIO_InitStructure);
  
  /* Connect EXTI Line to Mems DRDY Pin */
  SYSCFG_EXTILineConfig(LSM303DLHC_DRDY_EXTI_PORT_SOURCE, LSM303DLHC_DRDY_EXTI_PIN_SOURCE);
  
  EXTI_InitStructure.EXTI_Line = LSM303DLHC_DRDY_EXTI_LINE;
 8003eba:	f8cd 8008 	str.w	r8, [sp, #8]
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8003ebe:	f04f 0801 	mov.w	r8, #1
  /* Connect EXTI Line to Mems DRDY Pin */
  SYSCFG_EXTILineConfig(LSM303DLHC_DRDY_EXTI_PORT_SOURCE, LSM303DLHC_DRDY_EXTI_PIN_SOURCE);
  
  EXTI_InitStructure.EXTI_Line = LSM303DLHC_DRDY_EXTI_LINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 8003ec2:	f88d 300d 	strb.w	r3, [sp, #13]
  
  /* Connect EXTI Line to Mems DRDY Pin */
  SYSCFG_EXTILineConfig(LSM303DLHC_DRDY_EXTI_PORT_SOURCE, LSM303DLHC_DRDY_EXTI_PIN_SOURCE);
  
  EXTI_InitStructure.EXTI_Line = LSM303DLHC_DRDY_EXTI_LINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8003ec6:	f88d 400c 	strb.w	r4, [sp, #12]
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8003eca:	f88d 800e 	strb.w	r8, [sp, #14]
  
  EXTI_Init(&EXTI_InitStructure);
 8003ece:	f7fc fd3f 	bl	8000950 <EXTI_Init>
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = LSM303DLHC_MAX_COMMUNICATION_FREQ;
 8003ed2:	a908      	add	r1, sp, #32
  
  EXTI_Init(&EXTI_InitStructure);
  
  /* I2C configuration -------------------------------------------------------*/
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8003ed4:	f64b 73ff 	movw	r3, #49151	; 0xbfff
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = LSM303DLHC_MAX_COMMUNICATION_FREQ;
 8003ed8:	4a18      	ldr	r2, [pc, #96]	; (8003f3c <LSM303DLHC_LowLevel_Init+0x130>)
  
  EXTI_Init(&EXTI_InitStructure);
  
  /* I2C configuration -------------------------------------------------------*/
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8003eda:	f8ad 3016 	strh.w	r3, [sp, #22]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8003ede:	f44f 6380 	mov.w	r3, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = LSM303DLHC_MAX_COMMUNICATION_FREQ;
 8003ee2:	f841 2d10 	str.w	r2, [r1, #-16]!
  
  /* I2C configuration -------------------------------------------------------*/
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8003ee6:	f8ad 301a 	strh.w	r3, [sp, #26]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = LSM303DLHC_MAX_COMMUNICATION_FREQ;
  
  /* Apply LSM303DLHC_I2C configuration after enabling it */
  I2C_Init(LSM303DLHC_I2C, &I2C_InitStructure);
 8003eea:	4648      	mov	r0, r9
  /* I2C configuration -------------------------------------------------------*/
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8003eec:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8003ef0:	f8ad 301c 	strh.w	r3, [sp, #28]
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  
  EXTI_Init(&EXTI_InitStructure);
  
  /* I2C configuration -------------------------------------------------------*/
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8003ef4:	f8ad 4014 	strh.w	r4, [sp, #20]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 8003ef8:	f8ad 4018 	strh.w	r4, [sp, #24]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = LSM303DLHC_MAX_COMMUNICATION_FREQ;
  
  /* Apply LSM303DLHC_I2C configuration after enabling it */
  I2C_Init(LSM303DLHC_I2C, &I2C_InitStructure);
 8003efc:	f7fd fa06 	bl	800130c <I2C_Init>
  
  /* LSM303DLHC_I2C Peripheral Enable */
  I2C_Cmd(LSM303DLHC_I2C, ENABLE);
 8003f00:	4648      	mov	r0, r9
 8003f02:	4641      	mov	r1, r8
 8003f04:	f7fd fa84 	bl	8001410 <I2C_Cmd>
  
  /* Configure GPIO PINs to detect Interrupts */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_INT1_PIN;
 8003f08:	2310      	movs	r3, #16
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(LSM303DLHC_I2C_INT1_GPIO_PORT, &GPIO_InitStructure);
 8003f0a:	4638      	mov	r0, r7
 8003f0c:	4669      	mov	r1, sp
  
  /* LSM303DLHC_I2C Peripheral Enable */
  I2C_Cmd(LSM303DLHC_I2C, ENABLE);
  
  /* Configure GPIO PINs to detect Interrupts */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_INT1_PIN;
 8003f0e:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8003f10:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003f14:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003f18:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 8003f1c:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_Init(LSM303DLHC_I2C_INT1_GPIO_PORT, &GPIO_InitStructure);
 8003f20:	f7fd f90c 	bl	800113c <GPIO_Init>
  
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_INT2_PIN;
 8003f24:	2320      	movs	r3, #32
  GPIO_Init(LSM303DLHC_I2C_INT2_GPIO_PORT, &GPIO_InitStructure);
 8003f26:	4638      	mov	r0, r7
 8003f28:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(LSM303DLHC_I2C_INT1_GPIO_PORT, &GPIO_InitStructure);
  
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_INT2_PIN;
 8003f2a:	9300      	str	r3, [sp, #0]
  GPIO_Init(LSM303DLHC_I2C_INT2_GPIO_PORT, &GPIO_InitStructure);
 8003f2c:	f7fd f906 	bl	800113c <GPIO_Init>
}  
 8003f30:	b009      	add	sp, #36	; 0x24
 8003f32:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003f36:	bf00      	nop
 8003f38:	40020400 	.word	0x40020400
 8003f3c:	000186a0 	.word	0x000186a0
 8003f40:	40005400 	.word	0x40005400

08003f44 <LSM303DLHC_I2C_Config>:
  * @brief  Configure the I2C Peripheral used to communicate with LSM303DLHC.
  * @param  None.
  * @retval None.
  */
void LSM303DLHC_I2C_Config(void)
{ 
 8003f44:	b570      	push	{r4, r5, r6, lr}
  I2C_InitTypeDef I2C_InitStructure;
  GPIO_InitTypeDef GPIO_InitStructure;
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_SCK_GPIO_CLK, ENABLE);
 8003f46:	2002      	movs	r0, #2
  * @brief  Configure the I2C Peripheral used to communicate with LSM303DLHC.
  * @param  None.
  * @retval None.
  */
void LSM303DLHC_I2C_Config(void)
{ 
 8003f48:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStructure;
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_SCK_GPIO_CLK, ENABLE);
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_SDA_GPIO_CLK, ENABLE);

  /* Connect PB6 and PB7 to LSM303DLHC_I2C*/
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
 8003f4a:	4c29      	ldr	r4, [pc, #164]	; (8003ff0 <LSM303DLHC_I2C_Config+0xac>)
  */
void LSM303DLHC_I2C_Config(void)
{ 
  I2C_InitTypeDef I2C_InitStructure;
  GPIO_InitTypeDef GPIO_InitStructure;
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_SCK_GPIO_CLK, ENABLE);
 8003f4c:	2101      	movs	r1, #1
 8003f4e:	f7fd fd93 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(LSM303DLHC_I2C_SDA_GPIO_CLK, ENABLE);
 8003f52:	2002      	movs	r0, #2
 8003f54:	2101      	movs	r1, #1
 8003f56:	f7fd fd8f 	bl	8001a78 <RCC_AHB1PeriphClockCmd>

  /* Connect PB6 and PB7 to LSM303DLHC_I2C*/
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
 8003f5a:	4620      	mov	r0, r4
 8003f5c:	2106      	movs	r1, #6
 8003f5e:	2204      	movs	r2, #4
 8003f60:	f7fd f98a 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(LSM303DLHC_I2C_SDA_GPIO_PORT, LSM303DLHC_I2C_SDA_SOURCE, LSM303DLHC_I2C_SCK_AF);
 8003f64:	2204      	movs	r2, #4
 8003f66:	4620      	mov	r0, r4
 8003f68:	2109      	movs	r1, #9
 8003f6a:	f7fd f985 	bl	8001278 <GPIO_PinAFConfig>
  
  /* Configure SCL */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
 8003f6e:	2340      	movs	r3, #64	; 0x40
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8003f70:	2601      	movs	r6, #1
  /* Connect PB6 and PB7 to LSM303DLHC_I2C*/
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
  GPIO_PinAFConfig(LSM303DLHC_I2C_SDA_GPIO_PORT, LSM303DLHC_I2C_SDA_SOURCE, LSM303DLHC_I2C_SCK_AF);
  
  /* Configure SCL */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
 8003f72:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8003f74:	2500      	movs	r5, #0
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
  GPIO_PinAFConfig(LSM303DLHC_I2C_SDA_GPIO_PORT, LSM303DLHC_I2C_SDA_SOURCE, LSM303DLHC_I2C_SCK_AF);
  
  /* Configure SCL */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003f76:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(LSM303DLHC_I2C_SCK_GPIO_PORT, &GPIO_InitStructure);
 8003f78:	4620      	mov	r0, r4
 8003f7a:	4669      	mov	r1, sp
  GPIO_PinAFConfig(LSM303DLHC_I2C_SCK_GPIO_PORT, LSM303DLHC_I2C_SCK_SOURCE, LSM303DLHC_I2C_SCK_AF);
  GPIO_PinAFConfig(LSM303DLHC_I2C_SDA_GPIO_PORT, LSM303DLHC_I2C_SDA_SOURCE, LSM303DLHC_I2C_SCK_AF);
  
  /* Configure SCL */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8003f7c:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003f80:	f88d 3005 	strb.w	r3, [sp, #5]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8003f84:	f88d 5007 	strb.w	r5, [sp, #7]
  GPIO_PinAFConfig(LSM303DLHC_I2C_SDA_GPIO_PORT, LSM303DLHC_I2C_SDA_SOURCE, LSM303DLHC_I2C_SCK_AF);
  
  /* Configure SCL */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SCK_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8003f88:	f88d 6006 	strb.w	r6, [sp, #6]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(LSM303DLHC_I2C_SCK_GPIO_PORT, &GPIO_InitStructure);
 8003f8c:	f7fd f8d6 	bl	800113c <GPIO_Init>
  
  /* Configure SDA */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SDA_PIN;
 8003f90:	f44f 7300 	mov.w	r3, #512	; 0x200
  GPIO_Init(LSM303DLHC_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
 8003f94:	4620      	mov	r0, r4
 8003f96:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(LSM303DLHC_I2C_SCK_GPIO_PORT, &GPIO_InitStructure);
  
  /* Configure SDA */
  GPIO_InitStructure.GPIO_Pin = LSM303DLHC_I2C_SDA_PIN;
 8003f98:	9300      	str	r3, [sp, #0]
  GPIO_Init(LSM303DLHC_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
 8003f9a:	f7fd f8cf 	bl	800113c <GPIO_Init>

    /* LSM303DLHC_I2C Periph clock enable */
  RCC_APB1PeriphClockCmd(LSM303DLHC_I2C_CLK, ENABLE);
 8003f9e:	4631      	mov	r1, r6
 8003fa0:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003fa4:	f7fd fd8c 	bl	8001ac0 <RCC_APB1PeriphClockCmd>
  
  /* Configure LSM303DLHC_I2C for communication */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8003fa8:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 8003fac:	f8ad 300e 	strh.w	r3, [sp, #14]
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
 8003fb0:	2333      	movs	r3, #51	; 0x33
 8003fb2:	f8ad 3010 	strh.w	r3, [sp, #16]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8003fb6:	f44f 6380 	mov.w	r3, #1024	; 0x400

    /* LSM303DLHC_I2C Periph clock enable */
  RCC_APB1PeriphClockCmd(LSM303DLHC_I2C_CLK, ENABLE);
  
  /* Configure LSM303DLHC_I2C for communication */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8003fba:	f8ad 500c 	strh.w	r5, [sp, #12]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8003fbe:	f8ad 3012 	strh.w	r3, [sp, #18]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = LSM303DLHC_MAX_COMMUNICATION_FREQ;
 8003fc2:	ad06      	add	r5, sp, #24
  /* Configure LSM303DLHC_I2C for communication */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8003fc4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_ClockSpeed = LSM303DLHC_MAX_COMMUNICATION_FREQ;

  I2C_DeInit(LSM303DLHC_I2C);
 8003fc8:	f5a4 34d8 	sub.w	r4, r4, #110592	; 0x1b000
  /* Configure LSM303DLHC_I2C for communication */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8003fcc:	f8ad 3014 	strh.w	r3, [sp, #20]
  I2C_InitStructure.I2C_ClockSpeed = LSM303DLHC_MAX_COMMUNICATION_FREQ;
 8003fd0:	4b08      	ldr	r3, [pc, #32]	; (8003ff4 <LSM303DLHC_I2C_Config+0xb0>)
 8003fd2:	f845 3d10 	str.w	r3, [r5, #-16]!

  I2C_DeInit(LSM303DLHC_I2C);
 8003fd6:	4620      	mov	r0, r4
 8003fd8:	f7fd f962 	bl	80012a0 <I2C_DeInit>
  I2C_Cmd(LSM303DLHC_I2C, ENABLE);
 8003fdc:	4620      	mov	r0, r4
 8003fde:	4631      	mov	r1, r6
 8003fe0:	f7fd fa16 	bl	8001410 <I2C_Cmd>
  I2C_Init(LSM303DLHC_I2C, &I2C_InitStructure);
 8003fe4:	4620      	mov	r0, r4
 8003fe6:	4629      	mov	r1, r5
 8003fe8:	f7fd f990 	bl	800130c <I2C_Init>
  
}
 8003fec:	b006      	add	sp, #24
 8003fee:	bd70      	pop	{r4, r5, r6, pc}
 8003ff0:	40020400 	.word	0x40020400
 8003ff4:	000186a0 	.word	0x000186a0

08003ff8 <LSM303DLHC_Read>:
  * @retval LSM303DLHC register value
  */
uint16_t LSM303DLHC_Read(uint8_t DeviceAddr, uint8_t RegisterAddr,
                              uint16_t NumByteToRead,
                              uint8_t* pBuffer)
{
 8003ff8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003ffa:	461e      	mov	r6, r3
  __IO uint32_t LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 8003ffc:	f44f 4320 	mov.w	r3, #40960	; 0xa000
  * @retval LSM303DLHC register value
  */
uint16_t LSM303DLHC_Read(uint8_t DeviceAddr, uint8_t RegisterAddr,
                              uint16_t NumByteToRead,
                              uint8_t* pBuffer)
{
 8004000:	4605      	mov	r5, r0
 8004002:	460f      	mov	r7, r1
 8004004:	4614      	mov	r4, r2
  __IO uint32_t LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 8004006:	9300      	str	r3, [sp, #0]
  __IO uint32_t temp;
  
  LSM303DLHC_I2C_Config();
 8004008:	f7ff ff9c 	bl	8003f44 <LSM303DLHC_I2C_Config>
  
restart:
  
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 800400c:	f44f 4320 	mov.w	r3, #40960	; 0xa000
/* Send START condition */
  I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
 8004010:	4897      	ldr	r0, [pc, #604]	; (8004270 <LSM303DLHC_Read+0x278>)
  
  LSM303DLHC_I2C_Config();
  
restart:
  
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 8004012:	9300      	str	r3, [sp, #0]
/* Send START condition */
  I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
 8004014:	2101      	movs	r1, #1
 8004016:	f7fd fa21 	bl	800145c <I2C_GenerateSTART>
  /* Test on EV5 and clear it */
  while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 800401a:	4895      	ldr	r0, [pc, #596]	; (8004270 <LSM303DLHC_Read+0x278>)
 800401c:	4995      	ldr	r1, [pc, #596]	; (8004274 <LSM303DLHC_Read+0x27c>)
 800401e:	f7fd fb39 	bl	8001694 <I2C_CheckEvent>
 8004022:	b930      	cbnz	r0, 8004032 <LSM303DLHC_Read+0x3a>
  {
    if (LSM303DLHC_Timeout-- == 0)
 8004024:	9b00      	ldr	r3, [sp, #0]
 8004026:	1e5a      	subs	r2, r3, #1
 8004028:	9200      	str	r2, [sp, #0]
 800402a:	2b00      	cmp	r3, #0
 800402c:	d1f5      	bne.n	800401a <LSM303DLHC_Read+0x22>
      return ERROR;
 800402e:	2000      	movs	r0, #0
 8004030:	e11b      	b.n	800426a <LSM303DLHC_Read+0x272>
  }
     
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 8004032:	f44f 4320 	mov.w	r3, #40960	; 0xa000
  /* Send slave address for read */
  I2C_Send7bitAddress(LSM303DLHC_I2C, DeviceAddr, I2C_Direction_Transmitter);
 8004036:	488e      	ldr	r0, [pc, #568]	; (8004270 <LSM303DLHC_Read+0x278>)
  {
    if (LSM303DLHC_Timeout-- == 0)
      return ERROR;
  }
     
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 8004038:	9300      	str	r3, [sp, #0]
  /* Send slave address for read */
  I2C_Send7bitAddress(LSM303DLHC_I2C, DeviceAddr, I2C_Direction_Transmitter);
 800403a:	4629      	mov	r1, r5
 800403c:	2200      	movs	r2, #0
 800403e:	f7fd fa29 	bl	8001494 <I2C_Send7bitAddress>
  
  while (!I2C_CheckEvent(LSM303DLHC_I2C,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 8004042:	488b      	ldr	r0, [pc, #556]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004044:	498c      	ldr	r1, [pc, #560]	; (8004278 <LSM303DLHC_Read+0x280>)
 8004046:	f7fd fb25 	bl	8001694 <I2C_CheckEvent>
 800404a:	b948      	cbnz	r0, 8004060 <LSM303DLHC_Read+0x68>
  {
    if (LSM303DLHC_Timeout-- == 0)
 800404c:	9b00      	ldr	r3, [sp, #0]
 800404e:	1e5a      	subs	r2, r3, #1
 8004050:	9200      	str	r2, [sp, #0]
 8004052:	2b00      	cmp	r3, #0
 8004054:	d1f5      	bne.n	8004042 <LSM303DLHC_Read+0x4a>
    {
      I2C_ClearFlag(LSM303DLHC_I2C,I2C_FLAG_BUSY|I2C_FLAG_AF);
 8004056:	4886      	ldr	r0, [pc, #536]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004058:	4988      	ldr	r1, [pc, #544]	; (800427c <LSM303DLHC_Read+0x284>)
 800405a:	f7fd fb4b 	bl	80016f4 <I2C_ClearFlag>
      goto restart;
 800405e:	e7d5      	b.n	800400c <LSM303DLHC_Read+0x14>
    } 
  }
  /* Clear EV6 by setting again the PE bit */
  I2C_Cmd(LSM303DLHC_I2C, ENABLE);
 8004060:	4883      	ldr	r0, [pc, #524]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004062:	2101      	movs	r1, #1
 8004064:	f7fd f9d4 	bl	8001410 <I2C_Cmd>

  I2C_SendData(LSM303DLHC_I2C, RegisterAddr);
 8004068:	4881      	ldr	r0, [pc, #516]	; (8004270 <LSM303DLHC_Read+0x278>)
 800406a:	4639      	mov	r1, r7
 800406c:	f7fd faaa 	bl	80015c4 <I2C_SendData>

  /* Test on EV8 and clear it */
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 8004070:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 8004074:	9300      	str	r3, [sp, #0]
  while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 8004076:	487e      	ldr	r0, [pc, #504]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004078:	4981      	ldr	r1, [pc, #516]	; (8004280 <LSM303DLHC_Read+0x288>)
 800407a:	f7fd fb0b 	bl	8001694 <I2C_CheckEvent>
 800407e:	b928      	cbnz	r0, 800408c <LSM303DLHC_Read+0x94>
  {
    if (LSM303DLHC_Timeout-- == 0)
 8004080:	9b00      	ldr	r3, [sp, #0]
 8004082:	1e5a      	subs	r2, r3, #1
 8004084:	9200      	str	r2, [sp, #0]
 8004086:	2b00      	cmp	r3, #0
 8004088:	d1f5      	bne.n	8004076 <LSM303DLHC_Read+0x7e>
 800408a:	e7d0      	b.n	800402e <LSM303DLHC_Read+0x36>
     return ERROR;
  }
  
  if (NumByteToRead == 0x01)
 800408c:	2c01      	cmp	r4, #1
 800408e:	d141      	bne.n	8004114 <LSM303DLHC_Read+0x11c>
  {
    restart3:  
    /* Send START condition */
    I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
 8004090:	4877      	ldr	r0, [pc, #476]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004092:	2101      	movs	r1, #1
 8004094:	f7fd f9e2 	bl	800145c <I2C_GenerateSTART>
    while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_MODE_SELECT));
 8004098:	4875      	ldr	r0, [pc, #468]	; (8004270 <LSM303DLHC_Read+0x278>)
 800409a:	4976      	ldr	r1, [pc, #472]	; (8004274 <LSM303DLHC_Read+0x27c>)
 800409c:	f7fd fafa 	bl	8001694 <I2C_CheckEvent>
 80040a0:	2800      	cmp	r0, #0
 80040a2:	d0f9      	beq.n	8004098 <LSM303DLHC_Read+0xa0>
    /* Send Slave address for read */
    I2C_Send7bitAddress(LSM303DLHC_I2C, DeviceAddr, I2C_Direction_Receiver);
 80040a4:	4872      	ldr	r0, [pc, #456]	; (8004270 <LSM303DLHC_Read+0x278>)
 80040a6:	4629      	mov	r1, r5
 80040a8:	2201      	movs	r2, #1
 80040aa:	f7fd f9f3 	bl	8001494 <I2C_Send7bitAddress>
    /* Wait until ADDR is set */
    LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80040ae:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 80040b2:	9300      	str	r3, [sp, #0]
    while (!I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_FLAG_ADDR))   
 80040b4:	486e      	ldr	r0, [pc, #440]	; (8004270 <LSM303DLHC_Read+0x278>)
 80040b6:	4973      	ldr	r1, [pc, #460]	; (8004284 <LSM303DLHC_Read+0x28c>)
 80040b8:	4c6d      	ldr	r4, [pc, #436]	; (8004270 <LSM303DLHC_Read+0x278>)
 80040ba:	f7fd faff 	bl	80016bc <I2C_GetFlagStatus>
 80040be:	b948      	cbnz	r0, 80040d4 <LSM303DLHC_Read+0xdc>
    {
      if (LSM303DLHC_Timeout-- == 0) 
 80040c0:	9b00      	ldr	r3, [sp, #0]
 80040c2:	1e5a      	subs	r2, r3, #1
 80040c4:	9200      	str	r2, [sp, #0]
 80040c6:	2b00      	cmp	r3, #0
 80040c8:	d1f4      	bne.n	80040b4 <LSM303DLHC_Read+0xbc>
      {
        I2C_ClearFlag(LSM303DLHC_I2C,I2C_FLAG_BUSY|I2C_FLAG_AF);
 80040ca:	4620      	mov	r0, r4
 80040cc:	496b      	ldr	r1, [pc, #428]	; (800427c <LSM303DLHC_Read+0x284>)
 80040ce:	f7fd fb11 	bl	80016f4 <I2C_ClearFlag>
        goto restart3;
 80040d2:	e7dd      	b.n	8004090 <LSM303DLHC_Read+0x98>
      }
    }
    /* Clear ACK */
    I2C_AcknowledgeConfig(LSM303DLHC_I2C, DISABLE);
 80040d4:	4620      	mov	r0, r4
 80040d6:	2100      	movs	r1, #0
 80040d8:	f7fd f9e6 	bl	80014a8 <I2C_AcknowledgeConfig>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80040dc:	b672      	cpsid	i
    __disable_irq();
    /* Clear ADDR flag */
    temp = LSM303DLHC_I2C->SR2;
 80040de:	8b23      	ldrh	r3, [r4, #24]
    /* Program the STOP */
    I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);
 80040e0:	4863      	ldr	r0, [pc, #396]	; (8004270 <LSM303DLHC_Read+0x278>)
    }
    /* Clear ACK */
    I2C_AcknowledgeConfig(LSM303DLHC_I2C, DISABLE);
    __disable_irq();
    /* Clear ADDR flag */
    temp = LSM303DLHC_I2C->SR2;
 80040e2:	b29b      	uxth	r3, r3
    /* Program the STOP */
    I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);
 80040e4:	2101      	movs	r1, #1
    }
    /* Clear ACK */
    I2C_AcknowledgeConfig(LSM303DLHC_I2C, DISABLE);
    __disable_irq();
    /* Clear ADDR flag */
    temp = LSM303DLHC_I2C->SR2;
 80040e6:	9301      	str	r3, [sp, #4]
    /* Program the STOP */
    I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);
 80040e8:	f7fd f9c6 	bl	8001478 <I2C_GenerateSTOP>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80040ec:	b662      	cpsie	i
    __enable_irq();
    while ((I2C_GetLastEvent(LSM303DLHC_I2C) & 0x0040) != 0x000040); /* Poll on RxNE */
 80040ee:	4860      	ldr	r0, [pc, #384]	; (8004270 <LSM303DLHC_Read+0x278>)
 80040f0:	4c5f      	ldr	r4, [pc, #380]	; (8004270 <LSM303DLHC_Read+0x278>)
 80040f2:	f7fd fadb 	bl	80016ac <I2C_GetLastEvent>
 80040f6:	f010 0f40 	tst.w	r0, #64	; 0x40
 80040fa:	d0f8      	beq.n	80040ee <LSM303DLHC_Read+0xf6>
    /* Read the data */
    *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 80040fc:	4620      	mov	r0, r4
 80040fe:	f7fd fa63 	bl	80015c8 <I2C_ReceiveData>
 8004102:	7030      	strb	r0, [r6, #0]
    /* Make sure that the STOP bit is cleared by Hardware before CR1 write access */
    while ((LSM303DLHC_I2C->CR1&0x200) == 0x200);
 8004104:	8823      	ldrh	r3, [r4, #0]
 8004106:	059d      	lsls	r5, r3, #22
 8004108:	d4fc      	bmi.n	8004104 <LSM303DLHC_Read+0x10c>
    /* Enable Acknowledgement to be ready for another reception */
    I2C_AcknowledgeConfig(LSM303DLHC_I2C, ENABLE);
 800410a:	4859      	ldr	r0, [pc, #356]	; (8004270 <LSM303DLHC_Read+0x278>)
 800410c:	2101      	movs	r1, #1
 800410e:	f7fd f9cb 	bl	80014a8 <I2C_AcknowledgeConfig>
 8004112:	e044      	b.n	800419e <LSM303DLHC_Read+0x1a6>

    return SUCCESS;
  }
  else
    if(NumByteToRead == 0x02)
 8004114:	2c02      	cmp	r4, #2
 8004116:	d167      	bne.n	80041e8 <LSM303DLHC_Read+0x1f0>
    {
      restart4:     
      /* Send START condition */
      I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
 8004118:	4855      	ldr	r0, [pc, #340]	; (8004270 <LSM303DLHC_Read+0x278>)
 800411a:	2101      	movs	r1, #1
 800411c:	f7fd f99e 	bl	800145c <I2C_GenerateSTART>
      while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_MODE_SELECT));
 8004120:	4c53      	ldr	r4, [pc, #332]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004122:	4954      	ldr	r1, [pc, #336]	; (8004274 <LSM303DLHC_Read+0x27c>)
 8004124:	4620      	mov	r0, r4
 8004126:	f7fd fab5 	bl	8001694 <I2C_CheckEvent>
 800412a:	2800      	cmp	r0, #0
 800412c:	d0f8      	beq.n	8004120 <LSM303DLHC_Read+0x128>
      /* Send EEPROM address for read */
      I2C_Send7bitAddress(LSM303DLHC_I2C, DeviceAddr, I2C_Direction_Receiver);
 800412e:	4620      	mov	r0, r4
 8004130:	4629      	mov	r1, r5
 8004132:	2201      	movs	r2, #1
 8004134:	f7fd f9ae 	bl	8001494 <I2C_Send7bitAddress>
      LSM303DLHC_I2C->CR1 = 0xC01; /* ACK=1; POS =1 */
 8004138:	f640 4301 	movw	r3, #3073	; 0xc01
 800413c:	8023      	strh	r3, [r4, #0]
      LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 800413e:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 8004142:	9300      	str	r3, [sp, #0]
      while (!I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_FLAG_ADDR))
 8004144:	484a      	ldr	r0, [pc, #296]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004146:	494f      	ldr	r1, [pc, #316]	; (8004284 <LSM303DLHC_Read+0x28c>)
 8004148:	f7fd fab8 	bl	80016bc <I2C_GetFlagStatus>
 800414c:	4b48      	ldr	r3, [pc, #288]	; (8004270 <LSM303DLHC_Read+0x278>)
 800414e:	b948      	cbnz	r0, 8004164 <LSM303DLHC_Read+0x16c>
      {
        if (LSM303DLHC_Timeout-- == 0) 
 8004150:	9a00      	ldr	r2, [sp, #0]
 8004152:	1e51      	subs	r1, r2, #1
 8004154:	9100      	str	r1, [sp, #0]
 8004156:	2a00      	cmp	r2, #0
 8004158:	d1f4      	bne.n	8004144 <LSM303DLHC_Read+0x14c>
        {
          I2C_ClearFlag(LSM303DLHC_I2C,I2C_FLAG_BUSY|I2C_FLAG_AF);
 800415a:	4618      	mov	r0, r3
 800415c:	4947      	ldr	r1, [pc, #284]	; (800427c <LSM303DLHC_Read+0x284>)
 800415e:	f7fd fac9 	bl	80016f4 <I2C_ClearFlag>
          goto restart4;     
 8004162:	e7d9      	b.n	8004118 <LSM303DLHC_Read+0x120>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004164:	b672      	cpsid	i
        }         
      }
      __disable_irq();
      /* Clear ADDR */
      temp = LSM303DLHC_I2C->SR2;
 8004166:	8b1b      	ldrh	r3, [r3, #24]
      /* Disable ACK */
      I2C_AcknowledgeConfig(LSM303DLHC_I2C, DISABLE);
 8004168:	4841      	ldr	r0, [pc, #260]	; (8004270 <LSM303DLHC_Read+0x278>)
          goto restart4;     
        }         
      }
      __disable_irq();
      /* Clear ADDR */
      temp = LSM303DLHC_I2C->SR2;
 800416a:	b29b      	uxth	r3, r3
      /* Disable ACK */
      I2C_AcknowledgeConfig(LSM303DLHC_I2C, DISABLE);
 800416c:	2100      	movs	r1, #0
          goto restart4;     
        }         
      }
      __disable_irq();
      /* Clear ADDR */
      temp = LSM303DLHC_I2C->SR2;
 800416e:	9301      	str	r3, [sp, #4]
      /* Disable ACK */
      I2C_AcknowledgeConfig(LSM303DLHC_I2C, DISABLE);
 8004170:	f7fd f99a 	bl	80014a8 <I2C_AcknowledgeConfig>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004174:	b662      	cpsie	i
      __enable_irq();
      while ((I2C_GetLastEvent(LSM303DLHC_I2C) & 0x0004) != 0x00004); /* Poll on BTF */
 8004176:	483e      	ldr	r0, [pc, #248]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004178:	f7fd fa98 	bl	80016ac <I2C_GetLastEvent>
 800417c:	0744      	lsls	r4, r0, #29
 800417e:	d5fa      	bpl.n	8004176 <LSM303DLHC_Read+0x17e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004180:	b672      	cpsid	i
       __disable_irq();
      /* Program the STOP */
      I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);
 8004182:	4c3b      	ldr	r4, [pc, #236]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004184:	2101      	movs	r1, #1
 8004186:	4620      	mov	r0, r4
 8004188:	f7fd f976 	bl	8001478 <I2C_GenerateSTOP>
      /* Read first data */
      *pBuffer = LSM303DLHC_I2C->DR;
 800418c:	8a23      	ldrh	r3, [r4, #16]
 800418e:	7033      	strb	r3, [r6, #0]
      pBuffer++;
      /* Read second data */
      *pBuffer = LSM303DLHC_I2C->DR;
 8004190:	8a23      	ldrh	r3, [r4, #16]
 8004192:	7073      	strb	r3, [r6, #1]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004194:	b662      	cpsie	i
      __enable_irq();
      LSM303DLHC_I2C->CR1 = 0x0401; /* POS = 0, ACK = 1, PE = 1 */
 8004196:	4b36      	ldr	r3, [pc, #216]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004198:	f240 4201 	movw	r2, #1025	; 0x401
 800419c:	801a      	strh	r2, [r3, #0]
      
      return SUCCESS;
 800419e:	2001      	movs	r0, #1
 80041a0:	e063      	b.n	800426a <LSM303DLHC_Read+0x272>
    /* Send START condition */
    I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
    /* Test on EV5 and clear it */
    while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
    {
      if (LSM303DLHC_Timeout-- == 0) return ERROR;
 80041a2:	9b00      	ldr	r3, [sp, #0]
 80041a4:	1e5a      	subs	r2, r3, #1
 80041a6:	9200      	str	r2, [sp, #0]
 80041a8:	2b00      	cmp	r3, #0
 80041aa:	f43f af40 	beq.w	800402e <LSM303DLHC_Read+0x36>
restart2:
    LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
    /* Send START condition */
    I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
    /* Test on EV5 and clear it */
    while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 80041ae:	4830      	ldr	r0, [pc, #192]	; (8004270 <LSM303DLHC_Read+0x278>)
 80041b0:	4930      	ldr	r1, [pc, #192]	; (8004274 <LSM303DLHC_Read+0x27c>)
 80041b2:	f7fd fa6f 	bl	8001694 <I2C_CheckEvent>
 80041b6:	2800      	cmp	r0, #0
 80041b8:	d0f3      	beq.n	80041a2 <LSM303DLHC_Read+0x1aa>
    {
      if (LSM303DLHC_Timeout-- == 0) return ERROR;
    }
    LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80041ba:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    /* Send slave address for read */
    I2C_Send7bitAddress(LSM303DLHC_I2C,  DeviceAddr, I2C_Direction_Receiver);
 80041be:	482c      	ldr	r0, [pc, #176]	; (8004270 <LSM303DLHC_Read+0x278>)
    /* Test on EV5 and clear it */
    while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
    {
      if (LSM303DLHC_Timeout-- == 0) return ERROR;
    }
    LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80041c0:	9300      	str	r3, [sp, #0]
    /* Send slave address for read */
    I2C_Send7bitAddress(LSM303DLHC_I2C,  DeviceAddr, I2C_Direction_Receiver);
 80041c2:	4629      	mov	r1, r5
 80041c4:	2201      	movs	r2, #1
 80041c6:	f7fd f965 	bl	8001494 <I2C_Send7bitAddress>
    while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
 80041ca:	4829      	ldr	r0, [pc, #164]	; (8004270 <LSM303DLHC_Read+0x278>)
 80041cc:	492e      	ldr	r1, [pc, #184]	; (8004288 <LSM303DLHC_Read+0x290>)
 80041ce:	f7fd fa61 	bl	8001694 <I2C_CheckEvent>
 80041d2:	2800      	cmp	r0, #0
 80041d4:	d143      	bne.n	800425e <LSM303DLHC_Read+0x266>
    {
      
      if (LSM303DLHC_Timeout-- == 0) 
 80041d6:	9b00      	ldr	r3, [sp, #0]
 80041d8:	1e5a      	subs	r2, r3, #1
 80041da:	9200      	str	r2, [sp, #0]
 80041dc:	2b00      	cmp	r3, #0
 80041de:	d1f4      	bne.n	80041ca <LSM303DLHC_Read+0x1d2>
      {
        I2C_ClearFlag(LSM303DLHC_I2C,I2C_FLAG_BUSY|I2C_FLAG_AF);
 80041e0:	4823      	ldr	r0, [pc, #140]	; (8004270 <LSM303DLHC_Read+0x278>)
 80041e2:	4926      	ldr	r1, [pc, #152]	; (800427c <LSM303DLHC_Read+0x284>)
 80041e4:	f7fd fa86 	bl	80016f4 <I2C_ClearFlag>
      return SUCCESS;
    }
  else
  {
restart2:
    LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80041e8:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    /* Send START condition */
    I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
 80041ec:	4820      	ldr	r0, [pc, #128]	; (8004270 <LSM303DLHC_Read+0x278>)
      return SUCCESS;
    }
  else
  {
restart2:
    LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80041ee:	9300      	str	r3, [sp, #0]
    /* Send START condition */
    I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
 80041f0:	2101      	movs	r1, #1
 80041f2:	f7fd f933 	bl	800145c <I2C_GenerateSTART>
    /* Test on EV5 and clear it */
    while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 80041f6:	e7da      	b.n	80041ae <LSM303DLHC_Read+0x1b6>
    while (NumByteToRead)
    {
  
      if (NumByteToRead != 3) /* Receive bytes from first byte until byte N-3 */
      {
        while ((I2C_GetLastEvent(LSM303DLHC_I2C) & 0x00004) != 0x000004); /* Poll on BTF */
 80041f8:	481d      	ldr	r0, [pc, #116]	; (8004270 <LSM303DLHC_Read+0x278>)
 80041fa:	f7fd fa57 	bl	80016ac <I2C_GetLastEvent>
 80041fe:	0740      	lsls	r0, r0, #29
 8004200:	d5fa      	bpl.n	80041f8 <LSM303DLHC_Read+0x200>
        /* Read data */
        *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 8004202:	481b      	ldr	r0, [pc, #108]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004204:	f7fd f9e0 	bl	80015c8 <I2C_ReceiveData>
        pBuffer++;
        /* Decrement the read bytes counter */
        NumByteToRead--;
 8004208:	3c01      	subs	r4, #1
 800420a:	b2a4      	uxth	r4, r4
      }
  
      if (NumByteToRead == 3)  /* it remains to read three data: data N-2, data N-1, Data N */
 800420c:	2c03      	cmp	r4, #3
  
      if (NumByteToRead != 3) /* Receive bytes from first byte until byte N-3 */
      {
        while ((I2C_GetLastEvent(LSM303DLHC_I2C) & 0x00004) != 0x000004); /* Poll on BTF */
        /* Read data */
        *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 800420e:	f805 0b01 	strb.w	r0, [r5], #1
        pBuffer++;
        /* Decrement the read bytes counter */
        NumByteToRead--;
      }
  
      if (NumByteToRead == 3)  /* it remains to read three data: data N-2, data N-1, Data N */
 8004212:	d003      	beq.n	800421c <LSM303DLHC_Read+0x224>
 8004214:	4a16      	ldr	r2, [pc, #88]	; (8004270 <LSM303DLHC_Read+0x278>)
        goto restart2;
      }
    }
  
    /* While there is data to be read; here the safe procedure is implemented */
    while (NumByteToRead)
 8004216:	b324      	cbz	r4, 8004262 <LSM303DLHC_Read+0x26a>
    {
  
      if (NumByteToRead != 3) /* Receive bytes from first byte until byte N-3 */
 8004218:	2c03      	cmp	r4, #3
 800421a:	d1ed      	bne.n	80041f8 <LSM303DLHC_Read+0x200>
  
      if (NumByteToRead == 3)  /* it remains to read three data: data N-2, data N-1, Data N */
      {
  
        /* Data N-2 in DR and data N -1 in shift register */
        while ((I2C_GetLastEvent(LSM303DLHC_I2C) & 0x000004) != 0x0000004); /* Poll on BTF */
 800421c:	4814      	ldr	r0, [pc, #80]	; (8004270 <LSM303DLHC_Read+0x278>)
 800421e:	f7fd fa45 	bl	80016ac <I2C_GetLastEvent>
 8004222:	0741      	lsls	r1, r0, #29
 8004224:	d5fa      	bpl.n	800421c <LSM303DLHC_Read+0x224>
        /* Clear ACK */
        I2C_AcknowledgeConfig(LSM303DLHC_I2C, DISABLE);
 8004226:	4812      	ldr	r0, [pc, #72]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004228:	2100      	movs	r1, #0
 800422a:	f7fd f93d 	bl	80014a8 <I2C_AcknowledgeConfig>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800422e:	b672      	cpsid	i
        __disable_irq();
        /* Read Data N-2 */
        *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 8004230:	480f      	ldr	r0, [pc, #60]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004232:	f7fd f9c9 	bl	80015c8 <I2C_ReceiveData>
        pBuffer++;
        /* Program the STOP */
        I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);
 8004236:	2101      	movs	r1, #1
        while ((I2C_GetLastEvent(LSM303DLHC_I2C) & 0x000004) != 0x0000004); /* Poll on BTF */
        /* Clear ACK */
        I2C_AcknowledgeConfig(LSM303DLHC_I2C, DISABLE);
        __disable_irq();
        /* Read Data N-2 */
        *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 8004238:	7028      	strb	r0, [r5, #0]
        pBuffer++;
        /* Program the STOP */
        I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);
 800423a:	480d      	ldr	r0, [pc, #52]	; (8004270 <LSM303DLHC_Read+0x278>)
 800423c:	f7fd f91c 	bl	8001478 <I2C_GenerateSTOP>
        /* Read DataN-1 */
        *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 8004240:	480b      	ldr	r0, [pc, #44]	; (8004270 <LSM303DLHC_Read+0x278>)
 8004242:	f7fd f9c1 	bl	80015c8 <I2C_ReceiveData>
 8004246:	7068      	strb	r0, [r5, #1]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004248:	b662      	cpsie	i
        __enable_irq();
        pBuffer++;
 800424a:	1cae      	adds	r6, r5, #2
        while ((I2C_GetLastEvent(LSM303DLHC_I2C) & 0x00000040) != 0x0000040); /* Poll on RxNE */
 800424c:	4c08      	ldr	r4, [pc, #32]	; (8004270 <LSM303DLHC_Read+0x278>)
 800424e:	4620      	mov	r0, r4
 8004250:	f7fd fa2c 	bl	80016ac <I2C_GetLastEvent>
 8004254:	0642      	lsls	r2, r0, #25
 8004256:	d5f9      	bpl.n	800424c <LSM303DLHC_Read+0x254>
        /* Read DataN */
        *pBuffer = LSM303DLHC_I2C->DR;
 8004258:	8a23      	ldrh	r3, [r4, #16]
 800425a:	70ab      	strb	r3, [r5, #2]
        /* Reset the number of bytes to be read by master */
        NumByteToRead = 0;
 800425c:	2400      	movs	r4, #0
 800425e:	4635      	mov	r5, r6
 8004260:	e7d8      	b.n	8004214 <LSM303DLHC_Read+0x21c>
      }
    }
    /* Make sure that the STOP bit is cleared by Hardware before CR1 write access */
    while ((LSM303DLHC_I2C->CR1&0x200) == 0x200);
 8004262:	8813      	ldrh	r3, [r2, #0]
 8004264:	059b      	lsls	r3, r3, #22
 8004266:	d4fc      	bmi.n	8004262 <LSM303DLHC_Read+0x26a>
 8004268:	e74f      	b.n	800410a <LSM303DLHC_Read+0x112>
    /* Enable Acknowledgement to be ready for another reception */
    I2C_AcknowledgeConfig(LSM303DLHC_I2C, ENABLE);
  
    return SUCCESS;
  }
}
 800426a:	b003      	add	sp, #12
 800426c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800426e:	bf00      	nop
 8004270:	40005400 	.word	0x40005400
 8004274:	00030001 	.word	0x00030001
 8004278:	00070082 	.word	0x00070082
 800427c:	10020400 	.word	0x10020400
 8004280:	00070084 	.word	0x00070084
 8004284:	10000002 	.word	0x10000002
 8004288:	00030002 	.word	0x00030002

0800428c <LSM303DLHC_Write>:
  * @retval LSM303DLHC Status
 */
uint16_t LSM303DLHC_Write(uint8_t DeviceAddr, uint8_t RegisterAddr,
                               uint16_t NumByteToWrite,
                               uint8_t* pBuffer)
{
 800428c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004290:	4681      	mov	r9, r0
 8004292:	4688      	mov	r8, r1
 8004294:	4617      	mov	r7, r2
 8004296:	461d      	mov	r5, r3

  LSM303DLHC_I2C_Config();
 8004298:	f7ff fe54 	bl	8003f44 <LSM303DLHC_I2C_Config>
  
  restart1:
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 800429c:	4e3d      	ldr	r6, [pc, #244]	; (8004394 <LSM303DLHC_Write+0x108>)
  /* Send START condition */
  I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
 800429e:	483e      	ldr	r0, [pc, #248]	; (8004398 <LSM303DLHC_Write+0x10c>)
{

  LSM303DLHC_I2C_Config();
  
  restart1:
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80042a0:	f44f 4320 	mov.w	r3, #40960	; 0xa000
  /* Send START condition */
  I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
 80042a4:	2101      	movs	r1, #1
{

  LSM303DLHC_I2C_Config();
  
  restart1:
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80042a6:	6033      	str	r3, [r6, #0]
  /* Send START condition */
  I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
 80042a8:	f7fd f8d8 	bl	800145c <I2C_GenerateSTART>
 80042ac:	4634      	mov	r4, r6
  /* Test on EV5 and clear it */
  while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 80042ae:	483a      	ldr	r0, [pc, #232]	; (8004398 <LSM303DLHC_Write+0x10c>)
 80042b0:	493a      	ldr	r1, [pc, #232]	; (800439c <LSM303DLHC_Write+0x110>)
 80042b2:	f7fd f9ef 	bl	8001694 <I2C_CheckEvent>
 80042b6:	b938      	cbnz	r0, 80042c8 <LSM303DLHC_Write+0x3c>
  {
    if (LSM303DLHC_Timeout-- == 0) return ERROR;
 80042b8:	6823      	ldr	r3, [r4, #0]
 80042ba:	1e5a      	subs	r2, r3, #1
 80042bc:	6022      	str	r2, [r4, #0]
 80042be:	2b00      	cmp	r3, #0
 80042c0:	d1f5      	bne.n	80042ae <LSM303DLHC_Write+0x22>
 80042c2:	2000      	movs	r0, #0
 80042c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  }
  /* Send slave address for write */
  I2C_Send7bitAddress(LSM303DLHC_I2C, DeviceAddr, I2C_Direction_Transmitter);
 80042c8:	4833      	ldr	r0, [pc, #204]	; (8004398 <LSM303DLHC_Write+0x10c>)
 80042ca:	4649      	mov	r1, r9
 80042cc:	2200      	movs	r2, #0
 80042ce:	f7fd f8e1 	bl	8001494 <I2C_Send7bitAddress>

  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80042d2:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 80042d6:	6033      	str	r3, [r6, #0]
  /* Test on EV6 and clear it */
  while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 80042d8:	482f      	ldr	r0, [pc, #188]	; (8004398 <LSM303DLHC_Write+0x10c>)
 80042da:	4931      	ldr	r1, [pc, #196]	; (80043a0 <LSM303DLHC_Write+0x114>)
 80042dc:	f7fd f9da 	bl	8001694 <I2C_CheckEvent>
 80042e0:	b948      	cbnz	r0, 80042f6 <LSM303DLHC_Write+0x6a>
  {
    
    if (LSM303DLHC_Timeout-- == 0) 
 80042e2:	6823      	ldr	r3, [r4, #0]
 80042e4:	1e5a      	subs	r2, r3, #1
 80042e6:	6022      	str	r2, [r4, #0]
 80042e8:	2b00      	cmp	r3, #0
 80042ea:	d1f5      	bne.n	80042d8 <LSM303DLHC_Write+0x4c>
    {
      I2C_ClearFlag(LSM303DLHC_I2C,I2C_FLAG_BUSY|I2C_FLAG_AF);
 80042ec:	482a      	ldr	r0, [pc, #168]	; (8004398 <LSM303DLHC_Write+0x10c>)
 80042ee:	492d      	ldr	r1, [pc, #180]	; (80043a4 <LSM303DLHC_Write+0x118>)
 80042f0:	f7fd fa00 	bl	80016f4 <I2C_ClearFlag>
      goto restart1;
 80042f4:	e7d2      	b.n	800429c <LSM303DLHC_Write+0x10>
    }
  }

  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80042f6:	f44f 4320 	mov.w	r3, #40960	; 0xa000

  /* Transmit the first address for r/w operations */
  I2C_SendData(LSM303DLHC_I2C, RegisterAddr);
 80042fa:	4827      	ldr	r0, [pc, #156]	; (8004398 <LSM303DLHC_Write+0x10c>)
      I2C_ClearFlag(LSM303DLHC_I2C,I2C_FLAG_BUSY|I2C_FLAG_AF);
      goto restart1;
    }
  }

  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 80042fc:	6023      	str	r3, [r4, #0]

  /* Transmit the first address for r/w operations */
  I2C_SendData(LSM303DLHC_I2C, RegisterAddr);
 80042fe:	4641      	mov	r1, r8
 8004300:	f7fd f960 	bl	80015c4 <I2C_SendData>

  /* Test on EV8 and clear it */
  while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 8004304:	4824      	ldr	r0, [pc, #144]	; (8004398 <LSM303DLHC_Write+0x10c>)
 8004306:	4928      	ldr	r1, [pc, #160]	; (80043a8 <LSM303DLHC_Write+0x11c>)
 8004308:	f7fd f9c4 	bl	8001694 <I2C_CheckEvent>
 800430c:	b928      	cbnz	r0, 800431a <LSM303DLHC_Write+0x8e>
  {
    if (LSM303DLHC_Timeout-- == 0)
 800430e:	6823      	ldr	r3, [r4, #0]
 8004310:	1e5a      	subs	r2, r3, #1
 8004312:	6022      	str	r2, [r4, #0]
 8004314:	2b00      	cmp	r3, #0
 8004316:	d1f5      	bne.n	8004304 <LSM303DLHC_Write+0x78>
 8004318:	e7d3      	b.n	80042c2 <LSM303DLHC_Write+0x36>
      return ERROR;
  }
  if (NumByteToWrite == 0x01)
 800431a:	2f01      	cmp	r7, #1
 800431c:	d111      	bne.n	8004342 <LSM303DLHC_Write+0xb6>
  {
    LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 800431e:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 8004322:	6023      	str	r3, [r4, #0]
    /* Prepare the register value to be sent */
    I2C_SendData(LSM303DLHC_I2C, *pBuffer);
 8004324:	481c      	ldr	r0, [pc, #112]	; (8004398 <LSM303DLHC_Write+0x10c>)
 8004326:	7829      	ldrb	r1, [r5, #0]
 8004328:	f7fd f94c 	bl	80015c4 <I2C_SendData>

    /* Test on EV8 and clear it */
    while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 800432c:	481a      	ldr	r0, [pc, #104]	; (8004398 <LSM303DLHC_Write+0x10c>)
 800432e:	491e      	ldr	r1, [pc, #120]	; (80043a8 <LSM303DLHC_Write+0x11c>)
 8004330:	f7fd f9b0 	bl	8001694 <I2C_CheckEvent>
 8004334:	b9b0      	cbnz	r0, 8004364 <LSM303DLHC_Write+0xd8>
    {
      if (LSM303DLHC_Timeout-- == 0)
 8004336:	6823      	ldr	r3, [r4, #0]
 8004338:	1e5a      	subs	r2, r3, #1
 800433a:	6022      	str	r2, [r4, #0]
 800433c:	2b00      	cmp	r3, #0
 800433e:	d1f5      	bne.n	800432c <LSM303DLHC_Write+0xa0>
 8004340:	e7bf      	b.n	80042c2 <LSM303DLHC_Write+0x36>

    /* End the configuration sequence */
    I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);
    return SUCCESS;
  }
  I2C_SendData(LSM303DLHC_I2C, *pBuffer);
 8004342:	4815      	ldr	r0, [pc, #84]	; (8004398 <LSM303DLHC_Write+0x10c>)
 8004344:	7829      	ldrb	r1, [r5, #0]
 8004346:	f7fd f93d 	bl	80015c4 <I2C_SendData>
  pBuffer++;
  NumByteToWrite--;
 800434a:	3f01      	subs	r7, #1
 800434c:	fa15 f787 	uxtah	r7, r5, r7
  /* While there is data to be written */
  while (NumByteToWrite--)
 8004350:	42bd      	cmp	r5, r7
 8004352:	d10e      	bne.n	8004372 <LSM303DLHC_Write+0xe6>
    I2C_SendData(LSM303DLHC_I2C, *pBuffer);
    /* Point to the next byte to be written */
    pBuffer++;

  }
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
 8004354:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 8004358:	6023      	str	r3, [r4, #0]
  /* Test on EV8_2 and clear it, BTF = TxE = 1, DR and shift registers are
   empty */
  while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 800435a:	480f      	ldr	r0, [pc, #60]	; (8004398 <LSM303DLHC_Write+0x10c>)
 800435c:	4912      	ldr	r1, [pc, #72]	; (80043a8 <LSM303DLHC_Write+0x11c>)
 800435e:	f7fd f999 	bl	8001694 <I2C_CheckEvent>
 8004362:	b188      	cbz	r0, 8004388 <LSM303DLHC_Write+0xfc>
      if (LSM303DLHC_Timeout-- == 0)
        return ERROR;
    }

    /* End the configuration sequence */
    I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);
 8004364:	480c      	ldr	r0, [pc, #48]	; (8004398 <LSM303DLHC_Write+0x10c>)
 8004366:	2101      	movs	r1, #1
 8004368:	f7fd f886 	bl	8001478 <I2C_GenerateSTOP>
    return SUCCESS;
 800436c:	2001      	movs	r0, #1
 800436e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  pBuffer++;
  NumByteToWrite--;
  /* While there is data to be written */
  while (NumByteToWrite--)
  {
    while ((I2C_GetLastEvent(LSM303DLHC_I2C) & 0x04) != 0x04);  /* Poll on BTF */
 8004372:	4809      	ldr	r0, [pc, #36]	; (8004398 <LSM303DLHC_Write+0x10c>)
 8004374:	f7fd f99a 	bl	80016ac <I2C_GetLastEvent>
 8004378:	0743      	lsls	r3, r0, #29
 800437a:	d5fa      	bpl.n	8004372 <LSM303DLHC_Write+0xe6>
    /* Send the current byte */
    I2C_SendData(LSM303DLHC_I2C, *pBuffer);
 800437c:	4806      	ldr	r0, [pc, #24]	; (8004398 <LSM303DLHC_Write+0x10c>)
 800437e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8004382:	f7fd f91f 	bl	80015c4 <I2C_SendData>
 8004386:	e7e3      	b.n	8004350 <LSM303DLHC_Write+0xc4>
  LSM303DLHC_Timeout = LSM303DLHC_LONG_TIMEOUT;
  /* Test on EV8_2 and clear it, BTF = TxE = 1, DR and shift registers are
   empty */
  while (!I2C_CheckEvent(LSM303DLHC_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
  {
    if (LSM303DLHC_Timeout-- == 0) return ERROR;
 8004388:	6823      	ldr	r3, [r4, #0]
 800438a:	1e5a      	subs	r2, r3, #1
 800438c:	6022      	str	r2, [r4, #0]
 800438e:	2b00      	cmp	r3, #0
 8004390:	d1e3      	bne.n	800435a <LSM303DLHC_Write+0xce>
 8004392:	e796      	b.n	80042c2 <LSM303DLHC_Write+0x36>
 8004394:	20000054 	.word	0x20000054
 8004398:	40005400 	.word	0x40005400
 800439c:	00030001 	.word	0x00030001
 80043a0:	00070082 	.word	0x00070082
 80043a4:	10020400 	.word	0x10020400
 80043a8:	00070084 	.word	0x00070084

080043ac <LSM303DLHC_AccInit>:
  * @param  LSM303DLHC_InitStruct: pointer to a LSM303DLHC_InitTypeDef structure 
  *         that contains the configuration setting for the LSM303DLHC.
  * @retval None
  */
void LSM303DLHC_AccInit(LSM303DLHCAcc_InitTypeDef *LSM303DLHC_InitStruct)
{  
 80043ac:	b513      	push	{r0, r1, r4, lr}
 80043ae:	4604      	mov	r4, r0
  uint8_t ctrl1 = 0x00, ctrl4 = 0x00;
 80043b0:	2300      	movs	r3, #0
 80043b2:	f88d 3006 	strb.w	r3, [sp, #6]
 80043b6:	f88d 3007 	strb.w	r3, [sp, #7]
  
  /* Configure the low level interface ---------------------------------------*/
  LSM303DLHC_LowLevel_Init();
 80043ba:	f7ff fd27 	bl	8003e0c <LSM303DLHC_LowLevel_Init>
  
  /* Configure MEMS: data rate, power mode, full scale and axes */
  ctrl1 |= (uint8_t) (LSM303DLHC_InitStruct->Power_Mode | LSM303DLHC_InitStruct->AccOutput_DataRate | \
 80043be:	7822      	ldrb	r2, [r4, #0]
 80043c0:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80043c4:	4313      	orrs	r3, r2
 80043c6:	7862      	ldrb	r2, [r4, #1]
 80043c8:	4313      	orrs	r3, r2
 80043ca:	78a2      	ldrb	r2, [r4, #2]
 80043cc:	4313      	orrs	r3, r2
 80043ce:	f88d 3006 	strb.w	r3, [sp, #6]
                    LSM303DLHC_InitStruct->Axes_Enable);
  
  ctrl4 |= (uint8_t) (LSM303DLHC_InitStruct->BlockData_Update | LSM303DLHC_InitStruct->Endianness | \
 80043d2:	7922      	ldrb	r2, [r4, #4]
 80043d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80043d8:	4313      	orrs	r3, r2
 80043da:	7962      	ldrb	r2, [r4, #5]
 80043dc:	4313      	orrs	r3, r2
 80043de:	79a2      	ldrb	r2, [r4, #6]
 80043e0:	4313      	orrs	r3, r2
 80043e2:	78e2      	ldrb	r2, [r4, #3]
 80043e4:	4313      	orrs	r3, r2
 80043e6:	f88d 3007 	strb.w	r3, [sp, #7]
                    LSM303DLHC_InitStruct->AccFull_Scale|LSM303DLHC_InitStruct->High_Resolution);
                    
  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, 1, &ctrl1);
 80043ea:	2120      	movs	r1, #32
 80043ec:	f10d 0306 	add.w	r3, sp, #6
 80043f0:	2201      	movs	r2, #1
 80043f2:	2032      	movs	r0, #50	; 0x32
 80043f4:	f7ff ff4a 	bl	800428c <LSM303DLHC_Write>
  
  /* Write value to ACC MEMS CTRL_REG4 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, 1, &ctrl4);
 80043f8:	2123      	movs	r1, #35	; 0x23
 80043fa:	2201      	movs	r2, #1
 80043fc:	f10d 0307 	add.w	r3, sp, #7
 8004400:	2032      	movs	r0, #50	; 0x32
 8004402:	f7ff ff43 	bl	800428c <LSM303DLHC_Write>
}
 8004406:	b002      	add	sp, #8
 8004408:	bd10      	pop	{r4, pc}

0800440a <LSM303DLHC_AccFilterConfig>:
  * @param  LSM303DLHC_FilterStruct: pointer to a LSM303DLHC_FilterConfigTypeDef structure 
  *         that contains the configuration setting for the LSM303DLHC.        
  * @retval None
  */
void LSM303DLHC_AccFilterConfig(LSM303DLHCAcc_FilterConfigTypeDef *LSM303DLHC_FilterStruct) 
{
 800440a:	b513      	push	{r0, r1, r4, lr}
 800440c:	4604      	mov	r4, r0
  uint8_t tmpreg;
  
  /* Read CTRL_REG2 register */
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG2_A, 1, &tmpreg);
 800440e:	f10d 0307 	add.w	r3, sp, #7
 8004412:	2121      	movs	r1, #33	; 0x21
 8004414:	2201      	movs	r2, #1
 8004416:	2032      	movs	r0, #50	; 0x32
 8004418:	f7ff fdee 	bl	8003ff8 <LSM303DLHC_Read>
  
  tmpreg &= 0x0C;
  
  /* Configure MEMS: mode, cutoff frquency, Filter status, Click, AOI1 and AOI2 */
  tmpreg |= (uint8_t) (LSM303DLHC_FilterStruct->HighPassFilter_Mode_Selection |\
 800441c:	7862      	ldrb	r2, [r4, #1]
 800441e:	7823      	ldrb	r3, [r4, #0]
 8004420:	4313      	orrs	r3, r2
 8004422:	78a2      	ldrb	r2, [r4, #2]
 8004424:	4313      	orrs	r3, r2
 8004426:	78e2      	ldrb	r2, [r4, #3]
 8004428:	4313      	orrs	r3, r2
  uint8_t tmpreg;
  
  /* Read CTRL_REG2 register */
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG2_A, 1, &tmpreg);
  
  tmpreg &= 0x0C;
 800442a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800442e:	f002 020c 	and.w	r2, r2, #12
  
  /* Configure MEMS: mode, cutoff frquency, Filter status, Click, AOI1 and AOI2 */
  tmpreg |= (uint8_t) (LSM303DLHC_FilterStruct->HighPassFilter_Mode_Selection |\
 8004432:	4313      	orrs	r3, r2
 8004434:	f88d 3007 	strb.w	r3, [sp, #7]
                      LSM303DLHC_FilterStruct->HighPassFilter_CutOff_Frequency|\
                      LSM303DLHC_FilterStruct->HighPassFilter_AOI1|\
                      LSM303DLHC_FilterStruct->HighPassFilter_AOI2);                             
  
  /* Write value to ACC MEMS CTRL_REG2 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG2_A, 1, &tmpreg);
 8004438:	2121      	movs	r1, #33	; 0x21
 800443a:	2201      	movs	r2, #1
 800443c:	f10d 0307 	add.w	r3, sp, #7
 8004440:	2032      	movs	r0, #50	; 0x32
 8004442:	f7ff ff23 	bl	800428c <LSM303DLHC_Write>
}
 8004446:	b002      	add	sp, #8
 8004448:	bd10      	pop	{r4, pc}

0800444a <NMI_Handler>:
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 800444a:	4770      	bx	lr

0800444c <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800444c:	e7fe      	b.n	800444c <HardFault_Handler>

0800444e <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 800444e:	e7fe      	b.n	800444e <MemManage_Handler>

08004450 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8004450:	e7fe      	b.n	8004450 <BusFault_Handler>

08004452 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8004452:	e7fe      	b.n	8004452 <UsageFault_Handler>

08004454 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 8004454:	4770      	bx	lr

08004456 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8004456:	4770      	bx	lr

08004458 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8004458:	4770      	bx	lr
	...

0800445c <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 800445c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t *buf;
  uint8_t temp1, temp2 = 0x00;
	TimingDelay_Decrement();
 800445e:	f7fe ffad 	bl	80033bc <TimingDelay_Decrement>
  
  if (DemoEnterCondition == 0x00)
 8004462:	4b61      	ldr	r3, [pc, #388]	; (80045e8 <SysTick_Handler+0x18c>)
 8004464:	781b      	ldrb	r3, [r3, #0]
 8004466:	b91b      	cbnz	r3, 8004470 <SysTick_Handler+0x14>
        TIM_SetAutoreload(TIM4,  TIM_ARR/TempAcceleration);
      }
      Counter = 0x00;
    }  
  }
}
 8004468:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  uint8_t temp1, temp2 = 0x00;
	TimingDelay_Decrement();
  
  if (DemoEnterCondition == 0x00)
  {
    TimingDelay_Decrement();
 800446c:	f7fe bfa6 	b.w	80033bc <TimingDelay_Decrement>
*/
static uint8_t *USBD_HID_GetPos (void)
{
  static uint8_t HID_Buffer[4] = {0};
  
  HID_Buffer[1] = 0;
 8004470:	4b5e      	ldr	r3, [pc, #376]	; (80045ec <SysTick_Handler+0x190>)
  HID_Buffer[2] = 0;
  /* LEFT Direction */
  if(((int8_t)Buffer_Y[0]) < -2)
 8004472:	4d5f      	ldr	r5, [pc, #380]	; (80045f0 <SysTick_Handler+0x194>)
*/
static uint8_t *USBD_HID_GetPos (void)
{
  static uint8_t HID_Buffer[4] = {0};
  
  HID_Buffer[1] = 0;
 8004474:	2200      	movs	r2, #0
 8004476:	705a      	strb	r2, [r3, #1]
  HID_Buffer[2] = 0;
 8004478:	709a      	strb	r2, [r3, #2]
  /* LEFT Direction */
  if(((int8_t)Buffer_Y[0]) < -2)
 800447a:	f995 2000 	ldrsb.w	r2, [r5]
 800447e:	1c90      	adds	r0, r2, #2
 8004480:	da01      	bge.n	8004486 <SysTick_Handler+0x2a>
  {
    HID_Buffer[1] += CURSOR_STEP;
 8004482:	2207      	movs	r2, #7
 8004484:	e002      	b.n	800448c <SysTick_Handler+0x30>
  }
  /* RIGHT Direction */ 
  if(((int8_t)Buffer_Y[0]) > 2)
 8004486:	2a02      	cmp	r2, #2
 8004488:	dd01      	ble.n	800448e <SysTick_Handler+0x32>
  {
   HID_Buffer[1] -= CURSOR_STEP;
 800448a:	22f9      	movs	r2, #249	; 0xf9
 800448c:	705a      	strb	r2, [r3, #1]
  } 
  /* UP Direction */
  if(((int8_t)Buffer_X[0]) < -2)
 800448e:	4e59      	ldr	r6, [pc, #356]	; (80045f4 <SysTick_Handler+0x198>)
 8004490:	f996 2000 	ldrsb.w	r2, [r6]
 8004494:	1c91      	adds	r1, r2, #2
 8004496:	da01      	bge.n	800449c <SysTick_Handler+0x40>
  {
    HID_Buffer[2] += CURSOR_STEP;
 8004498:	2207      	movs	r2, #7
 800449a:	e002      	b.n	80044a2 <SysTick_Handler+0x46>
  }
  /* DOWN Direction */ 
  if(((int8_t)Buffer_X[0]) > 2)
 800449c:	2a02      	cmp	r2, #2
 800449e:	dd01      	ble.n	80044a4 <SysTick_Handler+0x48>
  {
    HID_Buffer[2] -= CURSOR_STEP;
 80044a0:	22f9      	movs	r2, #249	; 0xf9
 80044a2:	709a      	strb	r2, [r3, #2]
    TimingDelay_Decrement();
  }
  else
  {
    buf = USBD_HID_GetPos();
    if((buf[1] != 0) ||(buf[2] != 0))
 80044a4:	785b      	ldrb	r3, [r3, #1]
 80044a6:	b913      	cbnz	r3, 80044ae <SysTick_Handler+0x52>
 80044a8:	4b50      	ldr	r3, [pc, #320]	; (80045ec <SysTick_Handler+0x190>)
 80044aa:	789b      	ldrb	r3, [r3, #2]
 80044ac:	b123      	cbz	r3, 80044b8 <SysTick_Handler+0x5c>
    {
      USBD_HID_SendReport (&USB_OTG_dev, 
 80044ae:	4852      	ldr	r0, [pc, #328]	; (80045f8 <SysTick_Handler+0x19c>)
 80044b0:	494e      	ldr	r1, [pc, #312]	; (80045ec <SysTick_Handler+0x190>)
 80044b2:	2204      	movs	r2, #4
 80044b4:	f000 ff88 	bl	80053c8 <USBD_HID_SendReport>
                           buf,
                           4);
    } 
    Counter ++;
 80044b8:	4b50      	ldr	r3, [pc, #320]	; (80045fc <SysTick_Handler+0x1a0>)
 80044ba:	781a      	ldrb	r2, [r3, #0]
 80044bc:	3201      	adds	r2, #1
 80044be:	b2d2      	uxtb	r2, r2
    if (Counter == 10)
 80044c0:	2a0a      	cmp	r2, #10
    {
      USBD_HID_SendReport (&USB_OTG_dev, 
                           buf,
                           4);
    } 
    Counter ++;
 80044c2:	701a      	strb	r2, [r3, #0]
 80044c4:	461f      	mov	r7, r3
    if (Counter == 10)
 80044c6:	f040 808e 	bne.w	80045e6 <SysTick_Handler+0x18a>
    {
      Buffer_X[0] = 0;
 80044ca:	2400      	movs	r4, #0
      Buffer_Y[0] = 0;
      /* Disable All TIM4 Capture Compare Channels */
      TIM_CCxCmd(TIM4, TIM_Channel_1, DISABLE);
 80044cc:	4621      	mov	r1, r4
 80044ce:	4622      	mov	r2, r4
 80044d0:	484b      	ldr	r0, [pc, #300]	; (8004600 <SysTick_Handler+0x1a4>)
                           4);
    } 
    Counter ++;
    if (Counter == 10)
    {
      Buffer_X[0] = 0;
 80044d2:	7034      	strb	r4, [r6, #0]
      Buffer_Y[0] = 0;
 80044d4:	702c      	strb	r4, [r5, #0]
      /* Disable All TIM4 Capture Compare Channels */
      TIM_CCxCmd(TIM4, TIM_Channel_1, DISABLE);
 80044d6:	f7fe f9b5 	bl	8002844 <TIM_CCxCmd>
      TIM_CCxCmd(TIM4, TIM_Channel_2, DISABLE);
 80044da:	4622      	mov	r2, r4
 80044dc:	4848      	ldr	r0, [pc, #288]	; (8004600 <SysTick_Handler+0x1a4>)
 80044de:	2104      	movs	r1, #4
 80044e0:	f7fe f9b0 	bl	8002844 <TIM_CCxCmd>
      TIM_CCxCmd(TIM4, TIM_Channel_3, DISABLE);
 80044e4:	4622      	mov	r2, r4
 80044e6:	4846      	ldr	r0, [pc, #280]	; (8004600 <SysTick_Handler+0x1a4>)
 80044e8:	2108      	movs	r1, #8
 80044ea:	f7fe f9ab 	bl	8002844 <TIM_CCxCmd>
      TIM_CCxCmd(TIM4, TIM_Channel_4, DISABLE);
 80044ee:	4622      	mov	r2, r4
 80044f0:	4843      	ldr	r0, [pc, #268]	; (8004600 <SysTick_Handler+0x1a4>)
      Buffer_Y[0] -= Y_Offset;
      
      /* Update autoreload and capture compare registers value*/
      temp1 = ABS((int8_t)(Buffer_X[0]));
      temp2 = ABS((int8_t)(Buffer_Y[0]));       
      TempAcceleration = MAX(temp1, temp2);
 80044f2:	4c44      	ldr	r4, [pc, #272]	; (8004604 <SysTick_Handler+0x1a8>)
      Buffer_Y[0] = 0;
      /* Disable All TIM4 Capture Compare Channels */
      TIM_CCxCmd(TIM4, TIM_Channel_1, DISABLE);
      TIM_CCxCmd(TIM4, TIM_Channel_2, DISABLE);
      TIM_CCxCmd(TIM4, TIM_Channel_3, DISABLE);
      TIM_CCxCmd(TIM4, TIM_Channel_4, DISABLE);
 80044f4:	210c      	movs	r1, #12
 80044f6:	f7fe f9a5 	bl	8002844 <TIM_CCxCmd>
      
      LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_H_A, 6, Buffer_X);
 80044fa:	2129      	movs	r1, #41	; 0x29
 80044fc:	2206      	movs	r2, #6
 80044fe:	4b3d      	ldr	r3, [pc, #244]	; (80045f4 <SysTick_Handler+0x198>)
 8004500:	2032      	movs	r0, #50	; 0x32
 8004502:	f7ff fd79 	bl	8003ff8 <LSM303DLHC_Read>
      /* Remove the offsets values from data */
      Buffer_X[0] -= X_Offset;
 8004506:	4b40      	ldr	r3, [pc, #256]	; (8004608 <SysTick_Handler+0x1ac>)
 8004508:	7832      	ldrb	r2, [r6, #0]
 800450a:	781b      	ldrb	r3, [r3, #0]
 800450c:	1ad3      	subs	r3, r2, r3
 800450e:	7033      	strb	r3, [r6, #0]
      
      LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_Y_H_A, 6, Buffer_Y);
 8004510:	212b      	movs	r1, #43	; 0x2b
 8004512:	2206      	movs	r2, #6
 8004514:	4b36      	ldr	r3, [pc, #216]	; (80045f0 <SysTick_Handler+0x194>)
 8004516:	2032      	movs	r0, #50	; 0x32
 8004518:	f7ff fd6e 	bl	8003ff8 <LSM303DLHC_Read>
      /* Remove the offsets values from data */
      Buffer_Y[0] -= Y_Offset;
 800451c:	4b3b      	ldr	r3, [pc, #236]	; (800460c <SysTick_Handler+0x1b0>)
 800451e:	782a      	ldrb	r2, [r5, #0]
 8004520:	781b      	ldrb	r3, [r3, #0]
 8004522:	1ad2      	subs	r2, r2, r3
 8004524:	b2d2      	uxtb	r2, r2
      
      /* Update autoreload and capture compare registers value*/
      temp1 = ABS((int8_t)(Buffer_X[0]));
      temp2 = ABS((int8_t)(Buffer_Y[0]));       
 8004526:	b253      	sxtb	r3, r2
      /* Remove the offsets values from data */
      Buffer_X[0] -= X_Offset;
      
      LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_Y_H_A, 6, Buffer_Y);
      /* Remove the offsets values from data */
      Buffer_Y[0] -= Y_Offset;
 8004528:	702a      	strb	r2, [r5, #0]
      
      /* Update autoreload and capture compare registers value*/
      temp1 = ABS((int8_t)(Buffer_X[0]));
 800452a:	f996 2000 	ldrsb.w	r2, [r6]
      temp2 = ABS((int8_t)(Buffer_Y[0]));       
 800452e:	2b00      	cmp	r3, #0
 8004530:	bfb8      	it	lt
 8004532:	425b      	neglt	r3, r3
      LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_Y_H_A, 6, Buffer_Y);
      /* Remove the offsets values from data */
      Buffer_Y[0] -= Y_Offset;
      
      /* Update autoreload and capture compare registers value*/
      temp1 = ABS((int8_t)(Buffer_X[0]));
 8004534:	ea82 71e2 	eor.w	r1, r2, r2, asr #31
 8004538:	eba1 71e2 	sub.w	r1, r1, r2, asr #31
      temp2 = ABS((int8_t)(Buffer_Y[0]));       
      TempAcceleration = MAX(temp1, temp2);
 800453c:	b2db      	uxtb	r3, r3
 800453e:	b2c9      	uxtb	r1, r1
 8004540:	428b      	cmp	r3, r1
 8004542:	bf38      	it	cc
 8004544:	460b      	movcc	r3, r1
 8004546:	7023      	strb	r3, [r4, #0]

      if(TempAcceleration != 0)
 8004548:	7823      	ldrb	r3, [r4, #0]
 800454a:	2b00      	cmp	r3, #0
 800454c:	d049      	beq.n	80045e2 <SysTick_Handler+0x186>
      { 
        if ((int8_t)Buffer_X[0] < -2)
 800454e:	3202      	adds	r2, #2
 8004550:	da0c      	bge.n	800456c <SysTick_Handler+0x110>
        {
          /* Enable TIM4 Capture Compare Channel 4 */
          TIM_CCxCmd(TIM4, TIM_Channel_4, ENABLE);
 8004552:	482b      	ldr	r0, [pc, #172]	; (8004600 <SysTick_Handler+0x1a4>)
 8004554:	210c      	movs	r1, #12
 8004556:	2201      	movs	r2, #1
 8004558:	f7fe f974 	bl	8002844 <TIM_CCxCmd>
          /* Sets the TIM4 Capture Compare4 Register value */
          TIM_SetCompare4(TIM4, TIM_CCR/TempAcceleration);
 800455c:	7823      	ldrb	r3, [r4, #0]
 800455e:	4828      	ldr	r0, [pc, #160]	; (8004600 <SysTick_Handler+0x1a4>)
 8004560:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8004564:	fb91 f1f3 	sdiv	r1, r1, r3
 8004568:	f7fe f89c 	bl	80026a4 <TIM_SetCompare4>
        }
        if ((int8_t)Buffer_X[0] > 2)
 800456c:	f996 3000 	ldrsb.w	r3, [r6]
 8004570:	2b02      	cmp	r3, #2
 8004572:	dd0c      	ble.n	800458e <SysTick_Handler+0x132>
        {
          /* Enable TIM4 Capture Compare Channel 2 */
          TIM_CCxCmd(TIM4, TIM_Channel_2, ENABLE);
 8004574:	4822      	ldr	r0, [pc, #136]	; (8004600 <SysTick_Handler+0x1a4>)
 8004576:	2104      	movs	r1, #4
 8004578:	2201      	movs	r2, #1
 800457a:	f7fe f963 	bl	8002844 <TIM_CCxCmd>
          /* Sets the TIM4 Capture Compare2 Register value */
          TIM_SetCompare2(TIM4, TIM_CCR/TempAcceleration);
 800457e:	7823      	ldrb	r3, [r4, #0]
 8004580:	481f      	ldr	r0, [pc, #124]	; (8004600 <SysTick_Handler+0x1a4>)
 8004582:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8004586:	fb91 f1f3 	sdiv	r1, r1, r3
 800458a:	f7fe f887 	bl	800269c <TIM_SetCompare2>
        }
        if ((int8_t)Buffer_Y[0] > 2)
 800458e:	f995 3000 	ldrsb.w	r3, [r5]
 8004592:	2b02      	cmp	r3, #2
 8004594:	dd0c      	ble.n	80045b0 <SysTick_Handler+0x154>
        { 
          /* Enable TIM4 Capture Compare Channel 1 */
          TIM_CCxCmd(TIM4, TIM_Channel_1, ENABLE);
 8004596:	481a      	ldr	r0, [pc, #104]	; (8004600 <SysTick_Handler+0x1a4>)
 8004598:	2100      	movs	r1, #0
 800459a:	2201      	movs	r2, #1
 800459c:	f7fe f952 	bl	8002844 <TIM_CCxCmd>
          /* Sets the TIM4 Capture Compare1 Register value */
          TIM_SetCompare1(TIM4, TIM_CCR/TempAcceleration);
 80045a0:	7823      	ldrb	r3, [r4, #0]
 80045a2:	4817      	ldr	r0, [pc, #92]	; (8004600 <SysTick_Handler+0x1a4>)
 80045a4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80045a8:	fb91 f1f3 	sdiv	r1, r1, r3
 80045ac:	f7fe f874 	bl	8002698 <TIM_SetCompare1>
        }      
        if ((int8_t)Buffer_Y[0] < -2)
 80045b0:	f995 3000 	ldrsb.w	r3, [r5]
 80045b4:	3302      	adds	r3, #2
 80045b6:	da0c      	bge.n	80045d2 <SysTick_Handler+0x176>
        { 
          /* Enable TIM4 Capture Compare Channel 3 */
          TIM_CCxCmd(TIM4, TIM_Channel_3, ENABLE);
 80045b8:	4811      	ldr	r0, [pc, #68]	; (8004600 <SysTick_Handler+0x1a4>)
 80045ba:	2108      	movs	r1, #8
 80045bc:	2201      	movs	r2, #1
 80045be:	f7fe f941 	bl	8002844 <TIM_CCxCmd>
          /* Sets the TIM4 Capture Compare3 Register value */
          TIM_SetCompare3(TIM4, TIM_CCR/TempAcceleration);
 80045c2:	7823      	ldrb	r3, [r4, #0]
 80045c4:	480e      	ldr	r0, [pc, #56]	; (8004600 <SysTick_Handler+0x1a4>)
 80045c6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80045ca:	fb91 f1f3 	sdiv	r1, r1, r3
 80045ce:	f7fe f867 	bl	80026a0 <TIM_SetCompare3>
        }
        /* Time base configuration */
        TIM_SetAutoreload(TIM4,  TIM_ARR/TempAcceleration);
 80045d2:	7823      	ldrb	r3, [r4, #0]
 80045d4:	480a      	ldr	r0, [pc, #40]	; (8004600 <SysTick_Handler+0x1a4>)
 80045d6:	f240 71cf 	movw	r1, #1999	; 0x7cf
 80045da:	fb91 f1f3 	sdiv	r1, r1, r3
 80045de:	f7fd fecd 	bl	800237c <TIM_SetAutoreload>
      }
      Counter = 0x00;
 80045e2:	2300      	movs	r3, #0
 80045e4:	703b      	strb	r3, [r7, #0]
 80045e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80045e8:	200005be 	.word	0x200005be
 80045ec:	200005c6 	.word	0x200005c6
 80045f0:	200005f4 	.word	0x200005f4
 80045f4:	20000bf0 	.word	0x20000bf0
 80045f8:	200005fc 	.word	0x200005fc
 80045fc:	200005ca 	.word	0x200005ca
 8004600:	40000800 	.word	0x40000800
 8004604:	200005c5 	.word	0x200005c5
 8004608:	200005fb 	.word	0x200005fb
 800460c:	200005fa 	.word	0x200005fa

08004610 <EXTI0_IRQHandler>:
  * @param  None
  * @retval None
  */
void EXTI0_IRQHandler(void)
{
  UserButtonPressed = 0x01;
 8004610:	4b02      	ldr	r3, [pc, #8]	; (800461c <EXTI0_IRQHandler+0xc>)
 8004612:	2001      	movs	r0, #1
 8004614:	7018      	strb	r0, [r3, #0]
  
  /* Clear the EXTI line pending bit */
  EXTI_ClearITPendingBit(USER_BUTTON_EXTI_LINE);
 8004616:	f7fc ba05 	b.w	8000a24 <EXTI_ClearITPendingBit>
 800461a:	bf00      	nop
 800461c:	200005bf 	.word	0x200005bf

08004620 <OTG_FS_WKUP_IRQHandler>:
  * @brief  This function handles EXTI15_10_IRQ Handler.
  * @param  None
  * @retval None
  */
void OTG_FS_WKUP_IRQHandler(void)
{
 8004620:	b510      	push	{r4, lr}
  if(USB_OTG_dev.cfg.low_power)
 8004622:	4c09      	ldr	r4, [pc, #36]	; (8004648 <OTG_FS_WKUP_IRQHandler+0x28>)
 8004624:	7aa3      	ldrb	r3, [r4, #10]
 8004626:	b14b      	cbz	r3, 800463c <OTG_FS_WKUP_IRQHandler+0x1c>
  {
	/* Reset SLEEPDEEP and SLEEPONEXIT bits */
	SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8004628:	4b08      	ldr	r3, [pc, #32]	; (800464c <OTG_FS_WKUP_IRQHandler+0x2c>)
 800462a:	691a      	ldr	r2, [r3, #16]
 800462c:	f022 0206 	bic.w	r2, r2, #6
 8004630:	611a      	str	r2, [r3, #16]

	/* After wake-up from sleep mode, reconfigure the system clock */
	SystemInit();
 8004632:	f000 f813 	bl	800465c <SystemInit>
    USB_OTG_UngateClock(&USB_OTG_dev);
 8004636:	4620      	mov	r0, r4
 8004638:	f001 fdfc 	bl	8006234 <USB_OTG_UngateClock>
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 800463c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
}
 8004640:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	/* After wake-up from sleep mode, reconfigure the system clock */
	SystemInit();
    USB_OTG_UngateClock(&USB_OTG_dev);
  }
  EXTI_ClearITPendingBit(EXTI_Line18);
 8004644:	f7fc b9ee 	b.w	8000a24 <EXTI_ClearITPendingBit>
 8004648:	200005fc 	.word	0x200005fc
 800464c:	e000ed00 	.word	0xe000ed00

08004650 <OTG_FS_IRQHandler>:
  * @param  None
  * @retval None
  */
void OTG_FS_IRQHandler(void)
{
  USBD_OTG_ISR_Handler (&USB_OTG_dev);
 8004650:	4801      	ldr	r0, [pc, #4]	; (8004658 <OTG_FS_IRQHandler+0x8>)
 8004652:	f001 bf2f 	b.w	80064b4 <USBD_OTG_ISR_Handler>
 8004656:	bf00      	nop
 8004658:	200005fc 	.word	0x200005fc

0800465c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800465c:	4b3d      	ldr	r3, [pc, #244]	; (8004754 <SystemInit+0xf8>)
 800465e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8004662:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8004666:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800466a:	4b3b      	ldr	r3, [pc, #236]	; (8004758 <SystemInit+0xfc>)
 800466c:	681a      	ldr	r2, [r3, #0]
 800466e:	f042 0201 	orr.w	r2, r2, #1
 8004672:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8004674:	2200      	movs	r2, #0
 8004676:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8004678:	6819      	ldr	r1, [r3, #0]
 800467a:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 800467e:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8004682:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8004684:	4935      	ldr	r1, [pc, #212]	; (800475c <SystemInit+0x100>)
 8004686:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8004688:	6819      	ldr	r1, [r3, #0]
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800468a:	b082      	sub	sp, #8

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800468c:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8004690:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8004692:	60da      	str	r2, [r3, #12]
static void SetSysClock(void)
{
/******************************************************************************/
/*            PLL  used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8004694:	9200      	str	r2, [sp, #0]
 8004696:	9201      	str	r2, [sp, #4]
                   (RCC_PLLCFGR_PLLSRC_HSI) | (PLL_Q << 24);
   
#else  /* PLL_SOURCE_HSE_BYPASS or PLL_SOURCE_HSE */
    
    /* Enable HSE */
    RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8004698:	681a      	ldr	r2, [r3, #0]
 800469a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800469e:	601a      	str	r2, [r3, #0]
  #endif  /* PLL_SOURCE_HSE_BYPASS */
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80046a0:	4b2d      	ldr	r3, [pc, #180]	; (8004758 <SystemInit+0xfc>)
 80046a2:	681a      	ldr	r2, [r3, #0]
 80046a4:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 80046a8:	9201      	str	r2, [sp, #4]
    StartUpCounter++;
 80046aa:	9a00      	ldr	r2, [sp, #0]
 80046ac:	3201      	adds	r2, #1
 80046ae:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80046b0:	9a01      	ldr	r2, [sp, #4]
 80046b2:	b91a      	cbnz	r2, 80046bc <SystemInit+0x60>
 80046b4:	9a00      	ldr	r2, [sp, #0]
 80046b6:	f5b2 4fa0 	cmp.w	r2, #20480	; 0x5000
 80046ba:	d1f1      	bne.n	80046a0 <SystemInit+0x44>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80046bc:	681b      	ldr	r3, [r3, #0]
 80046be:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 80046c2:	bf18      	it	ne
 80046c4:	2301      	movne	r3, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80046c6:	9301      	str	r3, [sp, #4]
  }

  if (HSEStatus == (uint32_t)0x01)
 80046c8:	9b01      	ldr	r3, [sp, #4]
 80046ca:	2b01      	cmp	r3, #1
 80046cc:	4b22      	ldr	r3, [pc, #136]	; (8004758 <SystemInit+0xfc>)
  {

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 80046ce:	bf04      	itt	eq
 80046d0:	4a23      	ldreq	r2, [pc, #140]	; (8004760 <SystemInit+0x104>)
 80046d2:	605a      	streq	r2, [r3, #4]
         configuration. User can add here some code to deal with this error */
  }
#endif  /* PLL_SOURCE_HSI */
  
     /* Select regulator voltage output Scale 2 mode, System frequency up to 84 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 80046d4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80046d6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80046da:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR &= (uint32_t)~(PWR_CR_VOS);
 80046dc:	4a21      	ldr	r2, [pc, #132]	; (8004764 <SystemInit+0x108>)
 80046de:	6811      	ldr	r1, [r2, #0]
 80046e0:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
 80046e4:	6011      	str	r1, [r2, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 80046e6:	689a      	ldr	r2, [r3, #8]
 80046e8:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 1*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;
 80046ea:	689a      	ldr	r2, [r3, #8]
 80046ec:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;  
 80046ee:	689a      	ldr	r2, [r3, #8]
 80046f0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80046f4:	609a      	str	r2, [r3, #8]
 
  /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 80046f6:	681a      	ldr	r2, [r3, #0]
 80046f8:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80046fc:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 80046fe:	4b16      	ldr	r3, [pc, #88]	; (8004758 <SystemInit+0xfc>)
 8004700:	681a      	ldr	r2, [r3, #0]
 8004702:	0192      	lsls	r2, r2, #6
 8004704:	d5fb      	bpl.n	80046fe <SystemInit+0xa2>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_PRFTEN |FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_2WS;
 8004706:	4a18      	ldr	r2, [pc, #96]	; (8004768 <SystemInit+0x10c>)
 8004708:	f240 7102 	movw	r1, #1794	; 0x702
 800470c:	6011      	str	r1, [r2, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 800470e:	689a      	ldr	r2, [r3, #8]
 8004710:	f022 0203 	bic.w	r2, r2, #3
 8004714:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 8004716:	689a      	ldr	r2, [r3, #8]
 8004718:	f042 0202 	orr.w	r2, r2, #2
 800471c:	609a      	str	r2, [r3, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 800471e:	4b0e      	ldr	r3, [pc, #56]	; (8004758 <SystemInit+0xfc>)
 8004720:	689a      	ldr	r2, [r3, #8]
 8004722:	f002 020c 	and.w	r2, r2, #12
 8004726:	2a08      	cmp	r2, #8
 8004728:	d1f9      	bne.n	800471e <SystemInit+0xc2>

/******************************************************************************/
/*                          I2S clock configuration                           */
/******************************************************************************/
  /* PLLI2S clock used as I2S clock source */
  RCC->CFGR &= ~RCC_CFGR_I2SSRC;
 800472a:	689a      	ldr	r2, [r3, #8]
 800472c:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8004730:	609a      	str	r2, [r3, #8]

  /* Configure PLLI2S */
  RCC->PLLI2SCFGR = (PLLI2S_N << 6) | (PLLI2S_R << 28);
 8004732:	4a0e      	ldr	r2, [pc, #56]	; (800476c <SystemInit+0x110>)
 8004734:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Enable PLLI2S */
  RCC->CR |= ((uint32_t)RCC_CR_PLLI2SON);
 8004738:	681a      	ldr	r2, [r3, #0]
 800473a:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800473e:	601a      	str	r2, [r3, #0]

  /* Wait till PLLI2S is ready */
  while((RCC->CR & RCC_CR_PLLI2SRDY) == 0)
 8004740:	4b05      	ldr	r3, [pc, #20]	; (8004758 <SystemInit+0xfc>)
 8004742:	681b      	ldr	r3, [r3, #0]
 8004744:	011b      	lsls	r3, r3, #4
 8004746:	d5fb      	bpl.n	8004740 <SystemInit+0xe4>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8004748:	4b02      	ldr	r3, [pc, #8]	; (8004754 <SystemInit+0xf8>)
 800474a:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800474e:	609a      	str	r2, [r3, #8]
#endif
}
 8004750:	b002      	add	sp, #8
 8004752:	4770      	bx	lr
 8004754:	e000ed00 	.word	0xe000ed00
 8004758:	40023800 	.word	0x40023800
 800475c:	24003010 	.word	0x24003010
 8004760:	07415408 	.word	0x07415408
 8004764:	40007000 	.word	0x40007000
 8004768:	40023c00 	.word	0x40023c00
 800476c:	30004080 	.word	0x30004080

08004770 <USB_OTG_BSP_Init>:
* @param  None
* @retval None
*/

void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
{
 8004770:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#endif
  
 
 #ifdef USE_USB_OTG_FS 

  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);  
 8004772:	2001      	movs	r0, #1
  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 8004774:	4d29      	ldr	r5, [pc, #164]	; (800481c <USB_OTG_BSP_Init+0xac>)
#endif
  
 
 #ifdef USE_USB_OTG_FS 

  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);  
 8004776:	4601      	mov	r1, r0
 8004778:	f7fd f97e 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  
  /* Configure SOF VBUS ID DM DP Pins */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  | 
 800477c:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
      GPIO_Pin_11 | 
        GPIO_Pin_12;
  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004780:	2600      	movs	r6, #0
 #ifdef USE_USB_OTG_FS 

  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);  
  
  /* Configure SOF VBUS ID DM DP Pins */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  | 
 8004782:	9300      	str	r3, [sp, #0]
    GPIO_Pin_9  | 
      GPIO_Pin_11 | 
        GPIO_Pin_12;
  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8004784:	2703      	movs	r7, #3
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8004786:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 8004788:	4628      	mov	r0, r5
 800478a:	4669      	mov	r1, sp
    GPIO_Pin_9  | 
      GPIO_Pin_11 | 
        GPIO_Pin_12;
  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800478c:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  | 
    GPIO_Pin_9  | 
      GPIO_Pin_11 | 
        GPIO_Pin_12;
  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8004790:	f88d 7005 	strb.w	r7, [sp, #5]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004794:	f88d 6006 	strb.w	r6, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8004798:	f88d 6007 	strb.w	r6, [sp, #7]
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 800479c:	f7fc fcce 	bl	800113c <GPIO_Init>
  
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_OTG1_FS) ;
 80047a0:	4628      	mov	r0, r5
 80047a2:	2108      	movs	r1, #8
 80047a4:	220a      	movs	r2, #10
 80047a6:	f7fc fd67 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ; 
 80047aa:	4628      	mov	r0, r5
 80047ac:	2109      	movs	r1, #9
 80047ae:	220a      	movs	r2, #10
 80047b0:	f7fc fd62 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ; 
 80047b4:	4628      	mov	r0, r5
 80047b6:	210b      	movs	r1, #11
 80047b8:	220a      	movs	r2, #10
 80047ba:	f7fc fd5d 	bl	8001278 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
 80047be:	4628      	mov	r0, r5
 80047c0:	220a      	movs	r2, #10
 80047c2:	210c      	movs	r1, #12
 80047c4:	f7fc fd58 	bl	8001278 <GPIO_PinAFConfig>
  
  /* this for ID line debug */
  
  
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 80047c8:	2401      	movs	r4, #1
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
  
  /* this for ID line debug */
  
  
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 80047ca:	f44f 6380 	mov.w	r3, #1024	; 0x400
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 80047ce:	4628      	mov	r0, r5
 80047d0:	4669      	mov	r1, sp
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
  
  /* this for ID line debug */
  
  
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 80047d2:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 80047d4:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;  
 80047d8:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80047dc:	f88d 7005 	strb.w	r7, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 80047e0:	f7fc fcac 	bl	800113c <GPIO_Init>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;   
 80047e4:	210a      	movs	r1, #10
 80047e6:	460a      	mov	r2, r1
 80047e8:	4628      	mov	r0, r5
 80047ea:	f7fc fd45 	bl	8001278 <GPIO_PinAFConfig>

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 80047ee:	4621      	mov	r1, r4
 80047f0:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80047f4:	f7fd f970 	bl	8001ad8 <RCC_APB2PeriphClockCmd>
  RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ; 
 80047f8:	4621      	mov	r1, r4
 80047fa:	2080      	movs	r0, #128	; 0x80
 80047fc:	f7fd f948 	bl	8001a90 <RCC_AHB2PeriphClockCmd>
  
 #endif //USB_OTG_HS

  
  /* enable the PWR clock */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);   
 8004800:	4621      	mov	r1, r4
 8004802:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8004806:	f7fd f997 	bl	8001b38 <RCC_APB1PeriphResetCmd>
  
  /* Configure the Key button in EXTI mode */
  STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_EXTI);
 800480a:	4630      	mov	r0, r6
 800480c:	4621      	mov	r1, r4
 800480e:	f7fe fe49 	bl	80034a4 <STM_EVAL_PBInit>
  NVIC_Init(&NVIC_InitStructure);

  EXTI_ClearITPendingBit(EXTI_Line20);    
#endif   

  EXTI_ClearITPendingBit(USER_BUTTON_EXTI_LINE);  
 8004812:	4620      	mov	r0, r4
 8004814:	f7fc f906 	bl	8000a24 <EXTI_ClearITPendingBit>
}
 8004818:	b003      	add	sp, #12
 800481a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800481c:	40020000 	.word	0x40020000

08004820 <USB_OTG_BSP_EnableInterrupt>:
*         Enabele USB Global interrupt
* @param  None
* @retval None
*/
void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
{
 8004820:	b507      	push	{r0, r1, r2, lr}
  NVIC_InitTypeDef NVIC_InitStructure; 
  
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 8004822:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 8004826:	f7fe fb45 	bl	8002eb4 <NVIC_PriorityGroupConfig>
#ifdef USE_USB_OTG_HS   
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;  
 800482a:	2343      	movs	r3, #67	; 0x43
 800482c:	f88d 3004 	strb.w	r3, [sp, #4]
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
 8004830:	2203      	movs	r2, #3
#ifdef USE_USB_OTG_HS   
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;  
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 8004832:	2301      	movs	r3, #1
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);  
 8004834:	a801      	add	r0, sp, #4
#ifdef USE_USB_OTG_HS   
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;  
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 8004836:	f88d 3005 	strb.w	r3, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
 800483a:	f88d 2006 	strb.w	r2, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800483e:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC_Init(&NVIC_InitStructure);  
 8004842:	f7fe fb41 	bl	8002ec8 <NVIC_Init>
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);   
#endif
}
 8004846:	b003      	add	sp, #12
 8004848:	f85d fb04 	ldr.w	pc, [sp], #4

0800484c <USB_OTG_BSP_uDelay>:
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
  const uint32_t utime = (120 * usec / 7);
 800484c:	2378      	movs	r3, #120	; 0x78
 800484e:	4358      	muls	r0, r3
 8004850:	2207      	movs	r2, #7
 8004852:	fbb0 f0f2 	udiv	r0, r0, r2
* @param  usec : Value of delay required in micro sec
* @retval None
*/
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  uint32_t count = 0;
 8004856:	2300      	movs	r3, #0
  const uint32_t utime = (120 * usec / 7);
  do
  {
    if ( ++count > utime )
 8004858:	3301      	adds	r3, #1
 800485a:	4283      	cmp	r3, r0
 800485c:	d9fc      	bls.n	8004858 <USB_OTG_BSP_uDelay+0xc>
    {
      return ;
    }
  }
  while (1);
}
 800485e:	4770      	bx	lr

08004860 <USB_OTG_BSP_mDelay>:
* @param  msec : Value of delay required in milli sec
* @retval None
*/
void USB_OTG_BSP_mDelay (const uint32_t msec)
{
  USB_OTG_BSP_uDelay(msec * 1000);   
 8004860:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8004864:	4358      	muls	r0, r3
 8004866:	f7ff bff1 	b.w	800484c <USB_OTG_BSP_uDelay>
	...

0800486c <USBD_USR_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_DeviceDescriptor( uint8_t speed , uint16_t *length)
{
  *length = sizeof(USBD_DeviceDesc);
 800486c:	2312      	movs	r3, #18
 800486e:	800b      	strh	r3, [r1, #0]
  return USBD_DeviceDesc;
}
 8004870:	4800      	ldr	r0, [pc, #0]	; (8004874 <USBD_USR_DeviceDescriptor+0x8>)
 8004872:	4770      	bx	lr
 8004874:	2000007c 	.word	0x2000007c

08004878 <USBD_USR_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_LangIDStrDescriptor( uint8_t speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 8004878:	2304      	movs	r3, #4
 800487a:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 800487c:	4800      	ldr	r0, [pc, #0]	; (8004880 <USBD_USR_LangIDStrDescriptor+0x8>)
 800487e:	4770      	bx	lr
 8004880:	20000078 	.word	0x20000078

08004884 <USBD_USR_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ManufacturerStrDescriptor( uint8_t speed , uint16_t *length)
{
 8004884:	b510      	push	{r4, lr}
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8004886:	4c04      	ldr	r4, [pc, #16]	; (8004898 <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8004888:	4804      	ldr	r0, [pc, #16]	; (800489c <USBD_USR_ManufacturerStrDescriptor+0x18>)
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ManufacturerStrDescriptor( uint8_t speed , uint16_t *length)
{
 800488a:	460a      	mov	r2, r1
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 800488c:	4621      	mov	r1, r4
 800488e:	f001 f8eb 	bl	8005a68 <USBD_GetString>
  return USBD_StrDesc;
}
 8004892:	4620      	mov	r0, r4
 8004894:	bd10      	pop	{r4, pc}
 8004896:	bf00      	nop
 8004898:	20000cd0 	.word	0x20000cd0
 800489c:	08006a54 	.word	0x08006a54

080048a0 <USBD_USR_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ProductStrDescriptor( uint8_t speed , uint16_t *length)
{
 80048a0:	b508      	push	{r3, lr}
 80048a2:	460a      	mov	r2, r1
 
  
  if(speed == 0)
 80048a4:	b908      	cbnz	r0, 80048aa <USBD_USR_ProductStrDescriptor+0xa>
  {   
    USBD_GetString (USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 80048a6:	4804      	ldr	r0, [pc, #16]	; (80048b8 <USBD_USR_ProductStrDescriptor+0x18>)
 80048a8:	e000      	b.n	80048ac <USBD_USR_ProductStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString (USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);    
 80048aa:	4804      	ldr	r0, [pc, #16]	; (80048bc <USBD_USR_ProductStrDescriptor+0x1c>)
 80048ac:	4904      	ldr	r1, [pc, #16]	; (80048c0 <USBD_USR_ProductStrDescriptor+0x20>)
 80048ae:	f001 f8db 	bl	8005a68 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 80048b2:	4803      	ldr	r0, [pc, #12]	; (80048c0 <USBD_USR_ProductStrDescriptor+0x20>)
 80048b4:	bd08      	pop	{r3, pc}
 80048b6:	bf00      	nop
 80048b8:	08006a67 	.word	0x08006a67
 80048bc:	08006a7b 	.word	0x08006a7b
 80048c0:	20000cd0 	.word	0x20000cd0

080048c4 <USBD_USR_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_SerialStrDescriptor( uint8_t speed , uint16_t *length)
{
 80048c4:	b508      	push	{r3, lr}
 80048c6:	460a      	mov	r2, r1
  if(speed  == USB_OTG_SPEED_HIGH)
 80048c8:	b908      	cbnz	r0, 80048ce <USBD_USR_SerialStrDescriptor+0xa>
  {    
    USBD_GetString (USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
 80048ca:	4804      	ldr	r0, [pc, #16]	; (80048dc <USBD_USR_SerialStrDescriptor+0x18>)
 80048cc:	e000      	b.n	80048d0 <USBD_USR_SerialStrDescriptor+0xc>
  }
  else
  {
    USBD_GetString (USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);    
 80048ce:	4804      	ldr	r0, [pc, #16]	; (80048e0 <USBD_USR_SerialStrDescriptor+0x1c>)
 80048d0:	4904      	ldr	r1, [pc, #16]	; (80048e4 <USBD_USR_SerialStrDescriptor+0x20>)
 80048d2:	f001 f8c9 	bl	8005a68 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 80048d6:	4803      	ldr	r0, [pc, #12]	; (80048e4 <USBD_USR_SerialStrDescriptor+0x20>)
 80048d8:	bd08      	pop	{r3, pc}
 80048da:	bf00      	nop
 80048dc:	08006a8f 	.word	0x08006a8f
 80048e0:	08006a9c 	.word	0x08006a9c
 80048e4:	20000cd0 	.word	0x20000cd0

080048e8 <USBD_USR_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ConfigStrDescriptor( uint8_t speed , uint16_t *length)
{
 80048e8:	b510      	push	{r4, lr}
  if(speed  == USB_OTG_SPEED_HIGH)
  {  
    USBD_GetString (USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
 80048ea:	4c04      	ldr	r4, [pc, #16]	; (80048fc <USBD_USR_ConfigStrDescriptor+0x14>)
 80048ec:	4804      	ldr	r0, [pc, #16]	; (8004900 <USBD_USR_ConfigStrDescriptor+0x18>)
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_ConfigStrDescriptor( uint8_t speed , uint16_t *length)
{
 80048ee:	460a      	mov	r2, r1
  if(speed  == USB_OTG_SPEED_HIGH)
  {  
    USBD_GetString (USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
 80048f0:	4621      	mov	r1, r4
 80048f2:	f001 f8b9 	bl	8005a68 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length); 
  }
  return USBD_StrDesc;  
}
 80048f6:	4620      	mov	r0, r4
 80048f8:	bd10      	pop	{r4, pc}
 80048fa:	bf00      	nop
 80048fc:	20000cd0 	.word	0x20000cd0
 8004900:	08006aa9 	.word	0x08006aa9

08004904 <USBD_USR_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_InterfaceStrDescriptor( uint8_t speed , uint16_t *length)
{
 8004904:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString (USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
 8004906:	4c04      	ldr	r4, [pc, #16]	; (8004918 <USBD_USR_InterfaceStrDescriptor+0x14>)
 8004908:	4804      	ldr	r0, [pc, #16]	; (800491c <USBD_USR_InterfaceStrDescriptor+0x18>)
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_USR_InterfaceStrDescriptor( uint8_t speed , uint16_t *length)
{
 800490a:	460a      	mov	r2, r1
  if(speed == 0)
  {
    USBD_GetString (USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
 800490c:	4621      	mov	r1, r4
 800490e:	f001 f8ab 	bl	8005a68 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
  }
  return USBD_StrDesc;  
}
 8004912:	4620      	mov	r0, r4
 8004914:	bd10      	pop	{r4, pc}
 8004916:	bf00      	nop
 8004918:	20000cd0 	.word	0x20000cd0
 800491c:	08006ab4 	.word	0x08006ab4

08004920 <USBD_USR_DeviceReset>:
*         Displays the message on LCD on device Reset Event
* @param  speed : device speed
* @retval None
*/
void USBD_USR_DeviceReset(uint8_t speed )
{
 8004920:	4770      	bx	lr

08004922 <USBD_USR_DeviceConfigured>:
*         Displays the message on LCD on device configuration Event
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConfigured (void)
{
 8004922:	4770      	bx	lr

08004924 <USBD_USR_DeviceConnected>:
*         Displays the message on LCD on device connection Event
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceConnected (void)
{
 8004924:	4770      	bx	lr

08004926 <USBD_USR_DeviceDisconnected>:
*         Displays the message on LCD on device disconnection Event
* @param  None
* @retval Staus
*/
void USBD_USR_DeviceDisconnected (void)
{
 8004926:	4770      	bx	lr

08004928 <USBD_USR_DeviceSuspended>:
*         Displays the message on LCD on device suspend Event
* @param  None
* @retval None
*/
void USBD_USR_DeviceSuspended(void)
{
 8004928:	4770      	bx	lr

0800492a <USBD_USR_DeviceResumed>:
*         Displays the message on LCD on device resume Event
* @param  None
* @retval None
*/
void USBD_USR_DeviceResumed(void)
{
 800492a:	4770      	bx	lr

0800492c <USBD_USR_Init>:
*/
void USBD_USR_Init(void)
{   
  /* Setup SysTick Timer for 40 msec interrupts 
  This interrupt is used to probe the joystick */
  if (SysTick_Config(SystemCoreClock / 24))
 800492c:	4b0a      	ldr	r3, [pc, #40]	; (8004958 <USBD_USR_Init+0x2c>)
 800492e:	681a      	ldr	r2, [r3, #0]
 8004930:	2318      	movs	r3, #24
 8004932:	fbb2 f2f3 	udiv	r2, r2, r3
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 8004936:	3a01      	subs	r2, #1
 8004938:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
 800493c:	d20a      	bcs.n	8004954 <USBD_USR_Init+0x28>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 800493e:	4b07      	ldr	r3, [pc, #28]	; (800495c <USBD_USR_Init+0x30>)
 8004940:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8004942:	4a07      	ldr	r2, [pc, #28]	; (8004960 <USBD_USR_Init+0x34>)
 8004944:	21f0      	movs	r1, #240	; 0xf0
 8004946:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 800494a:	2200      	movs	r2, #0
 800494c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800494e:	2207      	movs	r2, #7
 8004950:	601a      	str	r2, [r3, #0]
 8004952:	4770      	bx	lr
 8004954:	e7fe      	b.n	8004954 <USBD_USR_Init+0x28>
 8004956:	bf00      	nop
 8004958:	20000058 	.word	0x20000058
 800495c:	e000e010 	.word	0xe000e010
 8004960:	e000ed00 	.word	0xe000ed00

08004964 <L3GD20_MEMS_Test>:
  *   MEMS peripheral.
  * @param None
  * @retval None
  */
void L3GD20_MEMS_Test(void)
{
 8004964:	b530      	push	{r4, r5, lr}
 8004966:	b085      	sub	sp, #20
  uint8_t temp, memsteststatus = 0x00;
  uint8_t ptemp[1] = {0xA5};
 8004968:	23a5      	movs	r3, #165	; 0xa5
 800496a:	f88d 3000 	strb.w	r3, [sp]
  /* MEMS configuration ------------------------------------------------------*/
  L3GD20_InitTypeDef L3GD20_InitStructure;
  L3GD20_FilterConfigTypeDef L3GD20_FilterStructure;
  
  /* Configure Mems L3GD20 */
  L3GD20_InitStructure.Power_Mode = L3GD20_MODE_ACTIVE;
 800496e:	2308      	movs	r3, #8
 8004970:	f88d 3008 	strb.w	r3, [sp, #8]
  L3GD20_InitStructure.Output_DataRate = L3GD20_OUTPUT_DATARATE_1;
  L3GD20_InitStructure.Axes_Enable = L3GD20_AXES_ENABLE;
 8004974:	2307      	movs	r3, #7
  L3GD20_InitTypeDef L3GD20_InitStructure;
  L3GD20_FilterConfigTypeDef L3GD20_FilterStructure;
  
  /* Configure Mems L3GD20 */
  L3GD20_InitStructure.Power_Mode = L3GD20_MODE_ACTIVE;
  L3GD20_InitStructure.Output_DataRate = L3GD20_OUTPUT_DATARATE_1;
 8004976:	2400      	movs	r4, #0
  L3GD20_InitStructure.Axes_Enable = L3GD20_AXES_ENABLE;
 8004978:	f88d 300a 	strb.w	r3, [sp, #10]
  L3GD20_InitStructure.Band_Width = L3GD20_BANDWIDTH_4;
  L3GD20_InitStructure.BlockData_Update = L3GD20_BlockDataUpdate_Continous;
  L3GD20_InitStructure.Endianness = L3GD20_BLE_LSB;
  L3GD20_InitStructure.Full_Scale = L3GD20_FULLSCALE_500; 
 800497c:	2510      	movs	r5, #16
  
  /* Configure Mems L3GD20 */
  L3GD20_InitStructure.Power_Mode = L3GD20_MODE_ACTIVE;
  L3GD20_InitStructure.Output_DataRate = L3GD20_OUTPUT_DATARATE_1;
  L3GD20_InitStructure.Axes_Enable = L3GD20_AXES_ENABLE;
  L3GD20_InitStructure.Band_Width = L3GD20_BANDWIDTH_4;
 800497e:	2330      	movs	r3, #48	; 0x30
  L3GD20_InitStructure.BlockData_Update = L3GD20_BlockDataUpdate_Continous;
  L3GD20_InitStructure.Endianness = L3GD20_BLE_LSB;
  L3GD20_InitStructure.Full_Scale = L3GD20_FULLSCALE_500; 
  L3GD20_Init(&L3GD20_InitStructure);
 8004980:	a802      	add	r0, sp, #8
  
  /* Configure Mems L3GD20 */
  L3GD20_InitStructure.Power_Mode = L3GD20_MODE_ACTIVE;
  L3GD20_InitStructure.Output_DataRate = L3GD20_OUTPUT_DATARATE_1;
  L3GD20_InitStructure.Axes_Enable = L3GD20_AXES_ENABLE;
  L3GD20_InitStructure.Band_Width = L3GD20_BANDWIDTH_4;
 8004982:	f88d 300b 	strb.w	r3, [sp, #11]
  L3GD20_InitTypeDef L3GD20_InitStructure;
  L3GD20_FilterConfigTypeDef L3GD20_FilterStructure;
  
  /* Configure Mems L3GD20 */
  L3GD20_InitStructure.Power_Mode = L3GD20_MODE_ACTIVE;
  L3GD20_InitStructure.Output_DataRate = L3GD20_OUTPUT_DATARATE_1;
 8004986:	f88d 4009 	strb.w	r4, [sp, #9]
  L3GD20_InitStructure.Axes_Enable = L3GD20_AXES_ENABLE;
  L3GD20_InitStructure.Band_Width = L3GD20_BANDWIDTH_4;
  L3GD20_InitStructure.BlockData_Update = L3GD20_BlockDataUpdate_Continous;
 800498a:	f88d 400c 	strb.w	r4, [sp, #12]
  L3GD20_InitStructure.Endianness = L3GD20_BLE_LSB;
 800498e:	f88d 400d 	strb.w	r4, [sp, #13]
  L3GD20_InitStructure.Full_Scale = L3GD20_FULLSCALE_500; 
 8004992:	f88d 500e 	strb.w	r5, [sp, #14]
  L3GD20_Init(&L3GD20_InitStructure);
 8004996:	f7ff f921 	bl	8003bdc <L3GD20_Init>
  
  L3GD20_FilterStructure.HighPassFilter_Mode_Selection =L3GD20_HPM_NORMAL_MODE_RES;
  L3GD20_FilterStructure.HighPassFilter_CutOff_Frequency = L3GD20_HPFCF_0;
  L3GD20_FilterConfig(&L3GD20_FilterStructure) ;
 800499a:	a801      	add	r0, sp, #4
  L3GD20_InitStructure.BlockData_Update = L3GD20_BlockDataUpdate_Continous;
  L3GD20_InitStructure.Endianness = L3GD20_BLE_LSB;
  L3GD20_InitStructure.Full_Scale = L3GD20_FULLSCALE_500; 
  L3GD20_Init(&L3GD20_InitStructure);
  
  L3GD20_FilterStructure.HighPassFilter_Mode_Selection =L3GD20_HPM_NORMAL_MODE_RES;
 800499c:	f88d 4004 	strb.w	r4, [sp, #4]
  L3GD20_FilterStructure.HighPassFilter_CutOff_Frequency = L3GD20_HPFCF_0;
 80049a0:	f88d 4005 	strb.w	r4, [sp, #5]
  L3GD20_FilterConfig(&L3GD20_FilterStructure) ;
 80049a4:	f7ff fa00 	bl	8003da8 <L3GD20_FilterConfig>
  
  L3GD20_FilterCmd(L3GD20_HIGHPASSFILTER_ENABLE);
 80049a8:	4628      	mov	r0, r5
 80049aa:	f7ff fa17 	bl	8003ddc <L3GD20_FilterCmd>
  
  
  L3GD20_Write(ptemp, L3GD20_CTRL_REG1_ADDR, 1);
 80049ae:	4668      	mov	r0, sp
 80049b0:	2120      	movs	r1, #32
 80049b2:	2201      	movs	r2, #1
 80049b4:	f7ff f8f2 	bl	8003b9c <L3GD20_Write>
  
  L3GD20_Read(&temp, L3GD20_CTRL_REG1_ADDR, 1);
 80049b8:	2120      	movs	r1, #32
 80049ba:	2201      	movs	r2, #1
 80049bc:	f10d 0003 	add.w	r0, sp, #3
 80049c0:	f7ff f9d0 	bl	8003d64 <L3GD20_Read>
  
  /* Required delay for the MEMS Accelerometre: Turn-on time = 3/Output data Rate 
  = 3/100 = 30ms */
  Delay(30);
 80049c4:	201e      	movs	r0, #30
 80049c6:	f7fe fadd 	bl	8002f84 <Delay>
  
  /* Read WHO_AM_I register */
  L3GD20_Read(&temp, L3GD20_WHO_AM_I_ADDR, 1);
 80049ca:	f10d 0003 	add.w	r0, sp, #3
 80049ce:	210f      	movs	r1, #15
 80049d0:	2201      	movs	r2, #1
 80049d2:	f7ff f9c7 	bl	8003d64 <L3GD20_Read>
  
  /* Check device identification register, this register should contains 
  the device identifier that for LSM303DLHC is set to 0x3B */
  if (temp != I_AM_L3GD20)
 80049d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80049da:	2bd4      	cmp	r3, #212	; 0xd4
 80049dc:	d004      	beq.n	80049e8 <L3GD20_MEMS_Test+0x84>
  {
    Fail_Handler();
 80049de:	f7fe fcf7 	bl	80033d0 <Fail_Handler>
    STM_EVAL_LEDOff(LED4);
  }
  /* MEMS test status: Timeout occurs */
  else
  {
    Fail_Handler();
 80049e2:	f7fe fcf5 	bl	80033d0 <Fail_Handler>
 80049e6:	e00f      	b.n	8004a08 <L3GD20_MEMS_Test+0xa4>
    
  /* MEMS test status: PASS */ 
  if(memsteststatus != 0x00)
  {
    /* Turn Green LED ON: signaling MEMS Test PASS */
    STM_EVAL_LEDOn(LED4);
 80049e8:	4620      	mov	r0, r4
 80049ea:	f7fe fd35 	bl	8003458 <STM_EVAL_LEDOn>
    
    /* Waiting User Button is pressed */
    while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_RESET)
 80049ee:	2000      	movs	r0, #0
 80049f0:	f7fe fd96 	bl	8003520 <STM_EVAL_PBGetState>
 80049f4:	2800      	cmp	r0, #0
 80049f6:	d0fa      	beq.n	80049ee <L3GD20_MEMS_Test+0x8a>
    {}
    
    /* Waiting User Button is Released */
    while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_SET)
 80049f8:	2000      	movs	r0, #0
 80049fa:	f7fe fd91 	bl	8003520 <STM_EVAL_PBGetState>
 80049fe:	2801      	cmp	r0, #1
 8004a00:	d0fa      	beq.n	80049f8 <L3GD20_MEMS_Test+0x94>
    {}
    
    /* Turn Green LED OFF: signaling the end of MEMS Test and switching to 
    the next Sub Test */
    STM_EVAL_LEDOff(LED4);
 8004a02:	2000      	movs	r0, #0
 8004a04:	f7fe fd34 	bl	8003470 <STM_EVAL_LEDOff>
  /* MEMS test status: Timeout occurs */
  else
  {
    Fail_Handler();
  }
}
 8004a08:	b005      	add	sp, #20
 8004a0a:	bd30      	pop	{r4, r5, pc}

08004a0c <USB_Test>:
  *   Audio and USB peripheral.
  * @param None
  * @retval None
  */
void USB_Test(void)
{
 8004a0c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  /******************************** USB Test **********************************/
  
  /*----------------- Part1: without cables connected ------------------------*/ 
  
  /* GPIOA, GPIOC and GPIOD clock enable */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC | \
 8004a10:	200d      	movs	r0, #13
 8004a12:	2101      	movs	r1, #1
 8004a14:	f7fd f830 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
                         RCC_AHB1Periph_GPIOD, ENABLE);
  
  /* GPIOD Configuration: Pins 5 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004a18:	2400      	movs	r4, #0
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC | \
                         RCC_AHB1Periph_GPIOD, ENABLE);
  
  /* GPIOD Configuration: Pins 5 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004a1a:	2501      	movs	r5, #1
  /* GPIOA, GPIOC and GPIOD clock enable */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC | \
                         RCC_AHB1Periph_GPIOD, ENABLE);
  
  /* GPIOD Configuration: Pins 5 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 8004a1c:	2720      	movs	r7, #32
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004a1e:	2602      	movs	r6, #2
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 8004a20:	48b2      	ldr	r0, [pc, #712]	; (8004cec <USB_Test+0x2e0>)
  /* GPIOA, GPIOC and GPIOD clock enable */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC | \
                         RCC_AHB1Periph_GPIOD, ENABLE);
  
  /* GPIOD Configuration: Pins 5 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 8004a22:	9700      	str	r7, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 8004a24:	4669      	mov	r1, sp
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC | \
                         RCC_AHB1Periph_GPIOD, ENABLE);
  
  /* GPIOD Configuration: Pins 5 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004a26:	f88d 5004 	strb.w	r5, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004a2a:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8004a2e:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004a32:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_Init(GPIOD, &GPIO_InitStructure);
 8004a36:	f7fc fb81 	bl	800113c <GPIO_Init>
  
  /* Turn LED8 ON using PD5 */
  GPIO_ResetBits(GPIOD, GPIO_Pin_5);
 8004a3a:	4639      	mov	r1, r7
 8004a3c:	48ab      	ldr	r0, [pc, #684]	; (8004cec <USB_Test+0x2e0>)
 8004a3e:	f7fc fc0d 	bl	800125c <GPIO_ResetBits>
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8004a42:	48ab      	ldr	r0, [pc, #684]	; (8004cf0 <USB_Test+0x2e4>)
  
  /* Turn LED8 ON using PD5 */
  GPIO_ResetBits(GPIOD, GPIO_Pin_5);
  
  /* GPIOC Configuration: Pin 0 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
 8004a44:	9500      	str	r5, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8004a46:	4669      	mov	r1, sp
  
  /* GPIOA Configuration: Pin 9 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004a48:	f44f 7700 	mov.w	r7, #512	; 0x200
  /* Turn LED8 ON using PD5 */
  GPIO_ResetBits(GPIOD, GPIO_Pin_5);
  
  /* GPIOC Configuration: Pin 0 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004a4c:	f88d 5004 	strb.w	r5, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004a50:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8004a54:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004a58:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8004a5c:	f7fc fb6e 	bl	800113c <GPIO_Init>
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004a60:	48a4      	ldr	r0, [pc, #656]	; (8004cf4 <USB_Test+0x2e8>)
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004a62:	9700      	str	r7, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004a64:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004a66:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004a6a:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8004a6e:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004a72:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004a76:	f7fc fb61 	bl	800113c <GPIO_Init>
  
  /* Turn LED7 ON using PC0 (5v) */
  GPIO_ResetBits(GPIOC, GPIO_Pin_0); 
 8004a7a:	4629      	mov	r1, r5
 8004a7c:	489c      	ldr	r0, [pc, #624]	; (8004cf0 <USB_Test+0x2e4>)
 8004a7e:	f7fc fbed 	bl	800125c <GPIO_ResetBits>
  
  /* Waiting delay 10ms */
  Delay(1);
 8004a82:	4628      	mov	r0, r5
 8004a84:	f7fe fa7e 	bl	8002f84 <Delay>
  
  if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == Bit_RESET)
 8004a88:	489a      	ldr	r0, [pc, #616]	; (8004cf4 <USB_Test+0x2e8>)
 8004a8a:	4639      	mov	r1, r7
 8004a8c:	f7fc fbd0 	bl	8001230 <GPIO_ReadInputDataBit>
 8004a90:	b908      	cbnz	r0, 8004a96 <USB_Test+0x8a>
  {
    Fail_Handler();
 8004a92:	f7fe fc9d 	bl	80033d0 <Fail_Handler>
  /* GPIOA Configuration: Pins 10 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004a96:	2302      	movs	r3, #2
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004a98:	4669      	mov	r1, sp
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 10 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 8004a9a:	f44f 6580 	mov.w	r5, #1024	; 0x400
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004a9e:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004aa2:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004aa6:	4893      	ldr	r0, [pc, #588]	; (8004cf4 <USB_Test+0x2e8>)
  /* GPIOA Configuration: Pins 10 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004aa8:	f88d 3005 	strb.w	r3, [sp, #5]
  
  /* GPIOA Configuration: Pins 10 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004aac:	2401      	movs	r4, #1
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 10 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 8004aae:	9500      	str	r5, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004ab0:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004ab4:	f7fc fb42 	bl	800113c <GPIO_Init>
  
  /* Waiting delay 10ms */
  Delay(1);
 8004ab8:	4620      	mov	r0, r4
 8004aba:	f7fe fa63 	bl	8002f84 <Delay>
  
  /* Check the ID level without cable connected */
  if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) == Bit_RESET)
 8004abe:	488d      	ldr	r0, [pc, #564]	; (8004cf4 <USB_Test+0x2e8>)
 8004ac0:	4629      	mov	r1, r5
 8004ac2:	f7fc fbb5 	bl	8001230 <GPIO_ReadInputDataBit>
 8004ac6:	b908      	cbnz	r0, 8004acc <USB_Test+0xc0>
  {
    Fail_Handler();
 8004ac8:	f7fe fc82 	bl	80033d0 <Fail_Handler>
  }
  
  /* Turn LED7 OFF using PC0 */
  GPIO_SetBits(GPIOC, GPIO_Pin_0);  
 8004acc:	4888      	ldr	r0, [pc, #544]	; (8004cf0 <USB_Test+0x2e4>)
 8004ace:	2101      	movs	r1, #1
 8004ad0:	f7fc fbc2 	bl	8001258 <GPIO_SetBits>
  
  /* GPIOA Configuration: Pins 11, 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004ad4:	2401      	movs	r4, #1
  
  /* Turn LED7 OFF using PC0 */
  GPIO_SetBits(GPIOC, GPIO_Pin_0);  
  
  /* GPIOA Configuration: Pins 11, 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
 8004ad6:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004ada:	2500      	movs	r5, #0
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004adc:	2702      	movs	r7, #2
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004ade:	4885      	ldr	r0, [pc, #532]	; (8004cf4 <USB_Test+0x2e8>)
  
  /* Turn LED7 OFF using PC0 */
  GPIO_SetBits(GPIOC, GPIO_Pin_0);  
  
  /* GPIOA Configuration: Pins 11, 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
 8004ae0:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004ae2:	4669      	mov	r1, sp
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004ae4:	f44f 7600 	mov.w	r6, #512	; 0x200
  /* Turn LED7 OFF using PC0 */
  GPIO_SetBits(GPIOC, GPIO_Pin_0);  
  
  /* GPIOA Configuration: Pins 11, 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004ae8:	f88d 5004 	strb.w	r5, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004aec:	f88d 5006 	strb.w	r5, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004af0:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004af4:	f88d 7005 	strb.w	r7, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004af8:	f7fc fb20 	bl	800113c <GPIO_Init>
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004afc:	487d      	ldr	r0, [pc, #500]	; (8004cf4 <USB_Test+0x2e8>)
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004afe:	9600      	str	r6, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004b00:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004b02:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004b06:	f88d 5006 	strb.w	r5, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004b0a:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004b0e:	f88d 7005 	strb.w	r7, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004b12:	f7fc fb13 	bl	800113c <GPIO_Init>
  GPIO_ResetBits(GPIOA, GPIO_Pin_9);
 8004b16:	4631      	mov	r1, r6
 8004b18:	4876      	ldr	r0, [pc, #472]	; (8004cf4 <USB_Test+0x2e8>)
 8004b1a:	f7fc fb9f 	bl	800125c <GPIO_ResetBits>
  
  /* Waiting delay 10ms */
  Delay(1);
 8004b1e:	4620      	mov	r0, r4
 8004b20:	f7fe fa30 	bl	8002f84 <Delay>
  
  /* Check PA11 and PA12 level without cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) == Bit_RESET) || \
 8004b24:	4873      	ldr	r0, [pc, #460]	; (8004cf4 <USB_Test+0x2e8>)
 8004b26:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8004b2a:	f7fc fb81 	bl	8001230 <GPIO_ReadInputDataBit>
 8004b2e:	b910      	cbnz	r0, 8004b36 <USB_Test+0x12a>
      (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12) == Bit_RESET))
  {
    Fail_Handler();
 8004b30:	f7fe fc4e 	bl	80033d0 <Fail_Handler>
 8004b34:	e006      	b.n	8004b44 <USB_Test+0x138>
  /* Waiting delay 10ms */
  Delay(1);
  
  /* Check PA11 and PA12 level without cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) == Bit_RESET) || \
      (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12) == Bit_RESET))
 8004b36:	486f      	ldr	r0, [pc, #444]	; (8004cf4 <USB_Test+0x2e8>)
 8004b38:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004b3c:	f7fc fb78 	bl	8001230 <GPIO_ReadInputDataBit>
  
  /* Waiting delay 10ms */
  Delay(1);
  
  /* Check PA11 and PA12 level without cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) == Bit_RESET) || \
 8004b40:	2800      	cmp	r0, #0
 8004b42:	d0f5      	beq.n	8004b30 <USB_Test+0x124>
  
  /* GPIOA Configuration: Pins 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004b44:	2501      	movs	r5, #1
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004b46:	2400      	movs	r4, #0
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8004b48:	f44f 5780 	mov.w	r7, #4096	; 0x1000
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004b4c:	f04f 0802 	mov.w	r8, #2
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004b50:	4868      	ldr	r0, [pc, #416]	; (8004cf4 <USB_Test+0x2e8>)
  
  /* GPIOA Configuration: Pins 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004b52:	f88d 5007 	strb.w	r5, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004b56:	4669      	mov	r1, sp
  
  /* GPIOA Configuration: Pin 11 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 8004b58:	f44f 6600 	mov.w	r6, #2048	; 0x800
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8004b5c:	9700      	str	r7, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004b5e:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004b62:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004b66:	f88d 8005 	strb.w	r8, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004b6a:	f7fc fae7 	bl	800113c <GPIO_Init>
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004b6e:	4861      	ldr	r0, [pc, #388]	; (8004cf4 <USB_Test+0x2e8>)
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 11 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004b70:	f88d 5004 	strb.w	r5, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004b74:	4669      	mov	r1, sp
  
  /* GPIOA Configuration: Pin 11 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004b76:	f88d 5007 	strb.w	r5, [sp, #7]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 11 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 8004b7a:	9600      	str	r6, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004b7c:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004b80:	f88d 8005 	strb.w	r8, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004b84:	f7fc fada 	bl	800113c <GPIO_Init>
  GPIO_ResetBits(GPIOA, GPIO_Pin_11);
 8004b88:	4631      	mov	r1, r6
 8004b8a:	485a      	ldr	r0, [pc, #360]	; (8004cf4 <USB_Test+0x2e8>)
 8004b8c:	f7fc fb66 	bl	800125c <GPIO_ResetBits>
  
  /* Waiting delay 10ms */
  Delay(1);
 8004b90:	4628      	mov	r0, r5
 8004b92:	f7fe f9f7 	bl	8002f84 <Delay>
  
  /* Check PA12 level without cable connected */
  if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12) == Bit_RESET)
 8004b96:	4857      	ldr	r0, [pc, #348]	; (8004cf4 <USB_Test+0x2e8>)
 8004b98:	4639      	mov	r1, r7
 8004b9a:	f7fc fb49 	bl	8001230 <GPIO_ReadInputDataBit>
 8004b9e:	4625      	mov	r5, r4
 8004ba0:	b908      	cbnz	r0, 8004ba6 <USB_Test+0x19a>
  {
    Fail_Handler();
 8004ba2:	f7fe fc15 	bl	80033d0 <Fail_Handler>
  
  /* GPIOA Configuration: Pins 11 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004ba6:	2401      	movs	r4, #1
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004ba8:	2702      	movs	r7, #2
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004baa:	4852      	ldr	r0, [pc, #328]	; (8004cf4 <USB_Test+0x2e8>)
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 11 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 8004bac:	9600      	str	r6, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004bae:	4669      	mov	r1, sp
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 11 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004bb0:	f88d 5004 	strb.w	r5, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004bb4:	f88d 5006 	strb.w	r5, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 12 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8004bb8:	f44f 5680 	mov.w	r6, #4096	; 0x1000
  
  /* GPIOA Configuration: Pins 11 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004bbc:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004bc0:	f88d 7005 	strb.w	r7, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004bc4:	f7fc faba 	bl	800113c <GPIO_Init>
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004bc8:	484a      	ldr	r0, [pc, #296]	; (8004cf4 <USB_Test+0x2e8>)
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 12 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004bca:	f88d 5006 	strb.w	r5, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004bce:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 12 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8004bd0:	9600      	str	r6, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004bd2:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004bd6:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004bda:	f88d 7005 	strb.w	r7, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004bde:	f7fc faad 	bl	800113c <GPIO_Init>
  GPIO_ResetBits(GPIOA, GPIO_Pin_12);
 8004be2:	4631      	mov	r1, r6
 8004be4:	4843      	ldr	r0, [pc, #268]	; (8004cf4 <USB_Test+0x2e8>)
 8004be6:	f7fc fb39 	bl	800125c <GPIO_ResetBits>
  
  /* Waiting delay 10ms */
  Delay(1);
 8004bea:	4620      	mov	r0, r4
 8004bec:	f7fe f9ca 	bl	8002f84 <Delay>
  
  /* Check PA12 level without cable connected */
  if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) == Bit_RESET)
 8004bf0:	4840      	ldr	r0, [pc, #256]	; (8004cf4 <USB_Test+0x2e8>)
 8004bf2:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8004bf6:	f7fc fb1b 	bl	8001230 <GPIO_ReadInputDataBit>
 8004bfa:	4625      	mov	r5, r4
 8004bfc:	b908      	cbnz	r0, 8004c02 <USB_Test+0x1f6>
  {
    Fail_Handler();
 8004bfe:	f7fe fbe7 	bl	80033d0 <Fail_Handler>
  }
  
  /* GPIOA Configuration: Pins 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004c02:	2400      	movs	r4, #0
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004c04:	f44f 7700 	mov.w	r7, #512	; 0x200
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004c08:	2602      	movs	r6, #2
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004c0a:	483a      	ldr	r0, [pc, #232]	; (8004cf4 <USB_Test+0x2e8>)
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004c0c:	9700      	str	r7, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004c0e:	4669      	mov	r1, sp
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004c10:	f88d 5004 	strb.w	r5, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004c14:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8004c18:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004c1c:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004c20:	f7fc fa8c 	bl	800113c <GPIO_Init>
  
  /* Turn LED7 ON using PA9 */
  GPIO_SetBits(GPIOA, GPIO_Pin_9);
 8004c24:	4639      	mov	r1, r7
 8004c26:	4833      	ldr	r0, [pc, #204]	; (8004cf4 <USB_Test+0x2e8>)
 8004c28:	f7fc fb16 	bl	8001258 <GPIO_SetBits>
  
  /* Turn Green LED ON: signaling Audio USB Test part1 PASS */
  STM_EVAL_LEDOn(LED4);
 8004c2c:	4620      	mov	r0, r4
 8004c2e:	f7fe fc13 	bl	8003458 <STM_EVAL_LEDOn>

  /* GPIOA Configuration: Pins 9, 10, 11 and 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12;
 8004c32:	f44f 53f0 	mov.w	r3, #7680	; 0x1e00
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004c36:	482f      	ldr	r0, [pc, #188]	; (8004cf4 <USB_Test+0x2e8>)
  
  /* Turn Green LED ON: signaling Audio USB Test part1 PASS */
  STM_EVAL_LEDOn(LED4);

  /* GPIOA Configuration: Pins 9, 10, 11 and 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12;
 8004c38:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004c3a:	4669      	mov	r1, sp
  /* Turn Green LED ON: signaling Audio USB Test part1 PASS */
  STM_EVAL_LEDOn(LED4);

  /* GPIOA Configuration: Pins 9, 10, 11 and 12 in input pull-up */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004c3c:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004c40:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004c44:	f88d 5007 	strb.w	r5, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004c48:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004c4c:	f7fc fa76 	bl	800113c <GPIO_Init>

  
  /* Waiting User Button is pressed */
  while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_RESET)
 8004c50:	2000      	movs	r0, #0
 8004c52:	f7fe fc65 	bl	8003520 <STM_EVAL_PBGetState>
 8004c56:	2800      	cmp	r0, #0
 8004c58:	d0fa      	beq.n	8004c50 <USB_Test+0x244>
  {}
  
  /* Waiting User Button is Released */
  while (STM_EVAL_PBGetState(BUTTON_USER) != Bit_RESET)
 8004c5a:	2000      	movs	r0, #0
 8004c5c:	f7fe fc60 	bl	8003520 <STM_EVAL_PBGetState>
 8004c60:	2800      	cmp	r0, #0
 8004c62:	d1fa      	bne.n	8004c5a <USB_Test+0x24e>
  {}
  
  /* Turn Green LED OFF: signaling the end of Audio USB Test part1 and switching to 
  the part2 */
  STM_EVAL_LEDOff(LED4);
 8004c64:	f7fe fc04 	bl	8003470 <STM_EVAL_LEDOff>
  
  /* Turn LED7 OFF using PA9 */
  GPIO_ResetBits(GPIOA, GPIO_Pin_9);
 8004c68:	4822      	ldr	r0, [pc, #136]	; (8004cf4 <USB_Test+0x2e8>)
 8004c6a:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004c6e:	f7fc faf5 	bl	800125c <GPIO_ResetBits>
  
  /* Turn LED8 OFF using PD5 */
  GPIO_SetBits(GPIOD, GPIO_Pin_5);
 8004c72:	481e      	ldr	r0, [pc, #120]	; (8004cec <USB_Test+0x2e0>)
 8004c74:	2120      	movs	r1, #32
 8004c76:	f7fc faef 	bl	8001258 <GPIO_SetBits>
  
  /*--------------- Part2: with Audio USB cables connected  ------------------*/ 
  
  /*********************************** USB Test *******************************/
  /* Check the ID level with cable connected */
  if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) != Bit_RESET)
 8004c7a:	481e      	ldr	r0, [pc, #120]	; (8004cf4 <USB_Test+0x2e8>)
 8004c7c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8004c80:	f7fc fad6 	bl	8001230 <GPIO_ReadInputDataBit>
 8004c84:	b108      	cbz	r0, 8004c8a <USB_Test+0x27e>
  {
    Fail_Handler();
 8004c86:	f7fe fba3 	bl	80033d0 <Fail_Handler>
  }
  
  /* GPIOA Configuration: Pins 11, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
 8004c8a:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004c8e:	2600      	movs	r6, #0
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 8004c90:	2502      	movs	r5, #2
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004c92:	4818      	ldr	r0, [pc, #96]	; (8004cf4 <USB_Test+0x2e8>)
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 11, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
 8004c94:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004c96:	4669      	mov	r1, sp
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004c98:	2401      	movs	r4, #1
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004c9a:	f44f 7700 	mov.w	r7, #512	; 0x200
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 11, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004c9e:	f88d 6004 	strb.w	r6, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004ca2:	f88d 6006 	strb.w	r6, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 8004ca6:	f88d 5007 	strb.w	r5, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004caa:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004cae:	f7fc fa45 	bl	800113c <GPIO_Init>
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004cb2:	4810      	ldr	r0, [pc, #64]	; (8004cf4 <USB_Test+0x2e8>)
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004cb4:	9700      	str	r7, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004cb6:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004cb8:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004cbc:	f88d 6006 	strb.w	r6, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004cc0:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004cc4:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004cc8:	f7fc fa38 	bl	800113c <GPIO_Init>
  GPIO_SetBits(GPIOA, GPIO_Pin_9);
 8004ccc:	4639      	mov	r1, r7
 8004cce:	4809      	ldr	r0, [pc, #36]	; (8004cf4 <USB_Test+0x2e8>)
 8004cd0:	f7fc fac2 	bl	8001258 <GPIO_SetBits>
  
  /* Waiting delay 10ms */
  Delay(1);
 8004cd4:	4620      	mov	r0, r4
 8004cd6:	f7fe f955 	bl	8002f84 <Delay>
  
  /* Check PA11 and PA12 level with cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) == Bit_RESET) || \
 8004cda:	4806      	ldr	r0, [pc, #24]	; (8004cf4 <USB_Test+0x2e8>)
 8004cdc:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8004ce0:	f7fc faa6 	bl	8001230 <GPIO_ReadInputDataBit>
 8004ce4:	b940      	cbnz	r0, 8004cf8 <USB_Test+0x2ec>
      (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12) == Bit_RESET))
  {
    Fail_Handler();
 8004ce6:	f7fe fb73 	bl	80033d0 <Fail_Handler>
 8004cea:	e00c      	b.n	8004d06 <USB_Test+0x2fa>
 8004cec:	40020c00 	.word	0x40020c00
 8004cf0:	40020800 	.word	0x40020800
 8004cf4:	40020000 	.word	0x40020000
  /* Waiting delay 10ms */
  Delay(1);
  
  /* Check PA11 and PA12 level with cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) == Bit_RESET) || \
      (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12) == Bit_RESET))
 8004cf8:	484f      	ldr	r0, [pc, #316]	; (8004e38 <USB_Test+0x42c>)
 8004cfa:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004cfe:	f7fc fa97 	bl	8001230 <GPIO_ReadInputDataBit>
  
  /* Waiting delay 10ms */
  Delay(1);
  
  /* Check PA11 and PA12 level with cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) == Bit_RESET) || \
 8004d02:	2800      	cmp	r0, #0
 8004d04:	d0ef      	beq.n	8004ce6 <USB_Test+0x2da>
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 9, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_12;
 8004d06:	f44f 5390 	mov.w	r3, #4608	; 0x1200
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004d0a:	2600      	movs	r6, #0
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 8004d0c:	2502      	movs	r5, #2
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d0e:	484a      	ldr	r0, [pc, #296]	; (8004e38 <USB_Test+0x42c>)
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 9, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_12;
 8004d10:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d12:	4669      	mov	r1, sp
  
  /* GPIOA Configuration: Pin 11 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004d14:	2401      	movs	r4, #1
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 11 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 8004d16:	f44f 6700 	mov.w	r7, #2048	; 0x800
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 9, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004d1a:	f88d 6004 	strb.w	r6, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004d1e:	f88d 6006 	strb.w	r6, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 8004d22:	f88d 5007 	strb.w	r5, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004d26:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d2a:	f7fc fa07 	bl	800113c <GPIO_Init>
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d2e:	4842      	ldr	r0, [pc, #264]	; (8004e38 <USB_Test+0x42c>)
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 11 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 8004d30:	9700      	str	r7, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d32:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 11 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004d34:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004d38:	f88d 6006 	strb.w	r6, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004d3c:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004d40:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d44:	f7fc f9fa 	bl	800113c <GPIO_Init>
  GPIO_SetBits(GPIOA, GPIO_Pin_11);
 8004d48:	4639      	mov	r1, r7
 8004d4a:	483b      	ldr	r0, [pc, #236]	; (8004e38 <USB_Test+0x42c>)
 8004d4c:	f7fc fa84 	bl	8001258 <GPIO_SetBits>
  
  /* Waiting delay 10ms */
  Delay(1);
 8004d50:	4620      	mov	r0, r4
 8004d52:	f7fe f917 	bl	8002f84 <Delay>
  
  /* Check PA9 and PA12 level with cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == Bit_RESET)|| \
 8004d56:	4838      	ldr	r0, [pc, #224]	; (8004e38 <USB_Test+0x42c>)
 8004d58:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004d5c:	f7fc fa68 	bl	8001230 <GPIO_ReadInputDataBit>
 8004d60:	b910      	cbnz	r0, 8004d68 <USB_Test+0x35c>
      (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12) == Bit_RESET))
  {
    Fail_Handler();
 8004d62:	f7fe fb35 	bl	80033d0 <Fail_Handler>
 8004d66:	e006      	b.n	8004d76 <USB_Test+0x36a>
  /* Waiting delay 10ms */
  Delay(1);
  
  /* Check PA9 and PA12 level with cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == Bit_RESET)|| \
      (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12) == Bit_RESET))
 8004d68:	4833      	ldr	r0, [pc, #204]	; (8004e38 <USB_Test+0x42c>)
 8004d6a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004d6e:	f7fc fa5f 	bl	8001230 <GPIO_ReadInputDataBit>
  
  /* Waiting delay 10ms */
  Delay(1);
  
  /* Check PA9 and PA12 level with cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == Bit_RESET)|| \
 8004d72:	2800      	cmp	r0, #0
 8004d74:	d0f5      	beq.n	8004d62 <USB_Test+0x356>
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 9, 11 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_11;
 8004d76:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004d7a:	2600      	movs	r6, #0
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 8004d7c:	2502      	movs	r5, #2
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d7e:	482e      	ldr	r0, [pc, #184]	; (8004e38 <USB_Test+0x42c>)
  {
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 9, 11 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_11;
 8004d80:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d82:	4669      	mov	r1, sp
  
  /* GPIOA Configuration: Pin 12 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004d84:	2401      	movs	r4, #1
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 12 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8004d86:	f44f 5780 	mov.w	r7, #4096	; 0x1000
    Fail_Handler();
  }
  
  /* GPIOA Configuration: Pins 9, 11 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004d8a:	f88d 6004 	strb.w	r6, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004d8e:	f88d 6006 	strb.w	r6, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 8004d92:	f88d 5007 	strb.w	r5, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004d96:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d9a:	f7fc f9cf 	bl	800113c <GPIO_Init>
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004d9e:	4826      	ldr	r0, [pc, #152]	; (8004e38 <USB_Test+0x42c>)
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 12 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8004da0:	9700      	str	r7, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004da2:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 12 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004da4:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004da8:	f88d 6006 	strb.w	r6, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004dac:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004db0:	f88d 5005 	strb.w	r5, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004db4:	f7fc f9c2 	bl	800113c <GPIO_Init>
  GPIO_SetBits(GPIOA, GPIO_Pin_12);
 8004db8:	4639      	mov	r1, r7
 8004dba:	481f      	ldr	r0, [pc, #124]	; (8004e38 <USB_Test+0x42c>)
 8004dbc:	f7fc fa4c 	bl	8001258 <GPIO_SetBits>
  
  /* Waiting delay 10ms */
  Delay(1);
 8004dc0:	4620      	mov	r0, r4
 8004dc2:	f7fe f8df 	bl	8002f84 <Delay>
  
  /* Check PA9 and PA12 level with cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == Bit_RESET)|| \
 8004dc6:	481c      	ldr	r0, [pc, #112]	; (8004e38 <USB_Test+0x42c>)
 8004dc8:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004dcc:	f7fc fa30 	bl	8001230 <GPIO_ReadInputDataBit>
 8004dd0:	b910      	cbnz	r0, 8004dd8 <USB_Test+0x3cc>
      (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) == Bit_RESET))
  {
    Fail_Handler();
 8004dd2:	f7fe fafd 	bl	80033d0 <Fail_Handler>
 8004dd6:	e006      	b.n	8004de6 <USB_Test+0x3da>
  /* Waiting delay 10ms */
  Delay(1);
  
  /* Check PA9 and PA12 level with cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == Bit_RESET)|| \
      (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) == Bit_RESET))
 8004dd8:	4817      	ldr	r0, [pc, #92]	; (8004e38 <USB_Test+0x42c>)
 8004dda:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8004dde:	f7fc fa27 	bl	8001230 <GPIO_ReadInputDataBit>
  
  /* Waiting delay 10ms */
  Delay(1);
  
  /* Check PA9 and PA12 level with cable connected */
  if ((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == Bit_RESET)|| \
 8004de2:	2800      	cmp	r0, #0
 8004de4:	d0f5      	beq.n	8004dd2 <USB_Test+0x3c6>
    Fail_Handler();
  }

  /* GPIOA Configuration: Pins 11, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004de6:	2500      	movs	r5, #0
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 8004de8:	2402      	movs	r4, #2
  {
    Fail_Handler();
  }

  /* GPIOA Configuration: Pins 11, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
 8004dea:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004dee:	4669      	mov	r1, sp
 8004df0:	4811      	ldr	r0, [pc, #68]	; (8004e38 <USB_Test+0x42c>)
  {
    Fail_Handler();
  }

  /* GPIOA Configuration: Pins 11, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
 8004df2:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004df4:	f44f 7600 	mov.w	r6, #512	; 0x200
    Fail_Handler();
  }

  /* GPIOA Configuration: Pins 11, 12 in input pull-down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004df8:	f88d 5004 	strb.w	r5, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004dfc:	f88d 5006 	strb.w	r5, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 8004e00:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004e04:	f88d 4005 	strb.w	r4, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004e08:	f7fc f998 	bl	800113c <GPIO_Init>
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004e0c:	2301      	movs	r3, #1
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004e0e:	4669      	mov	r1, sp
 8004e10:	4809      	ldr	r0, [pc, #36]	; (8004e38 <USB_Test+0x42c>)
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004e12:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004e16:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  /* GPIOA Configuration: Pin 9 in output push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8004e1a:	9600      	str	r6, [sp, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004e1c:	f88d 5006 	strb.w	r5, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004e20:	f88d 4005 	strb.w	r4, [sp, #5]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004e24:	f7fc f98a 	bl	800113c <GPIO_Init>
  
  /* Turn LED7 OFF using PA9 */
  GPIO_ResetBits(GPIOA, GPIO_Pin_9);
 8004e28:	4803      	ldr	r0, [pc, #12]	; (8004e38 <USB_Test+0x42c>)
 8004e2a:	4631      	mov	r1, r6
 8004e2c:	f7fc fa16 	bl	800125c <GPIO_ResetBits>
}
 8004e30:	b002      	add	sp, #8
 8004e32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004e36:	bf00      	nop
 8004e38:	40020000 	.word	0x40020000

08004e3c <Audio_Test>:
  *   Audio peripheral.
  * @param  None
  * @retval None
  */
void Audio_Test(void)
{ 
 8004e3c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  GPIO_InitTypeDef  GPIO_InitStructure;  
  uint8_t audioteststatus = 0x00;

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
 8004e40:	f44f 7080 	mov.w	r0, #256	; 0x100
 8004e44:	2101      	movs	r1, #1
 8004e46:	f7fc fe47 	bl	8001ad8 <RCC_APB2PeriphClockCmd>
  
  /* Set the current audio interface: I2S or DAC */
  EVAL_AUDIO_SetAudioInterface();
 8004e4a:	f7fe fcaf 	bl	80037ac <EVAL_AUDIO_SetAudioInterface>
  
  /* Initialize the Audio codec and all related peripherals (I2S, I2C, IOs...) */
  /* I2S code to be exectued under the I2S interrupt */
  if (EVAL_AUDIO_Init(OUTPUT_DEVICE_HEADPHONE, 87, I2S_AudioFreq_48k) !=0)
 8004e4e:	2002      	movs	r0, #2
 8004e50:	2157      	movs	r1, #87	; 0x57
 8004e52:	f64b 3280 	movw	r2, #48000	; 0xbb80
 8004e56:	f7fe fce7 	bl	8003828 <EVAL_AUDIO_Init>
 8004e5a:	b108      	cbz	r0, 8004e60 <Audio_Test+0x24>
  {
    Fail_Handler();
 8004e5c:	f7fe fab8 	bl	80033d0 <Fail_Handler>
  }

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
 8004e60:	4854      	ldr	r0, [pc, #336]	; (8004fb4 <Audio_Test+0x178>)
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles; 
  ADC_CommonInit(&ADC_CommonInitStructure);
  
  /* ADC peripherals Init */
  ADC_StructInit(&ADC_InitStructure);
 8004e62:	4d55      	ldr	r5, [pc, #340]	; (8004fb8 <Audio_Test+0x17c>)
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  counter1 = 0;
 8004e64:	f8df 9168 	ldr.w	r9, [pc, #360]	; 8004fd0 <Audio_Test+0x194>
  counter0 = 0;
 8004e68:	f8df 8168 	ldr.w	r8, [pc, #360]	; 8004fd4 <Audio_Test+0x198>
    Fail_Handler();
  }

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div8;
 8004e6c:	f44f 3340 	mov.w	r3, #196608	; 0x30000
  {
    Fail_Handler();
  }

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
 8004e70:	2400      	movs	r4, #0
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div8;
 8004e72:	6043      	str	r3, [r0, #4]
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles; 
 8004e74:	f44f 6370 	mov.w	r3, #3840	; 0xf00
 8004e78:	60c3      	str	r3, [r0, #12]
  {
    Fail_Handler();
  }

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
 8004e7a:	6004      	str	r4, [r0, #0]
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div8;
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8004e7c:	6084      	str	r4, [r0, #8]
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles; 
  ADC_CommonInit(&ADC_CommonInitStructure);
 8004e7e:	f7fb f9f1 	bl	8000264 <ADC_CommonInit>
  
  /* ADC peripherals Init */
  ADC_StructInit(&ADC_InitStructure);
 8004e82:	4628      	mov	r0, r5
 8004e84:	f7fb f9e4 	bl	8000250 <ADC_StructInit>
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_8b;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 2;
 8004e88:	2602      	movs	r6, #2
  ADC_CommonInit(&ADC_CommonInitStructure);
  
  /* ADC peripherals Init */
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_8b;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 8004e8a:	2701      	movs	r7, #1
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles; 
  ADC_CommonInit(&ADC_CommonInitStructure);
  
  /* ADC peripherals Init */
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_8b;
 8004e8c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 2;
  ADC_Init(ADC1, &ADC_InitStructure);
 8004e90:	4629      	mov	r1, r5
 8004e92:	484a      	ldr	r0, [pc, #296]	; (8004fbc <Audio_Test+0x180>)
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles; 
  ADC_CommonInit(&ADC_CommonInitStructure);
  
  /* ADC peripherals Init */
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_8b;
 8004e94:	602b      	str	r3, [r5, #0]
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 8004e96:	712f      	strb	r7, [r5, #4]
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 2;
 8004e98:	752e      	strb	r6, [r5, #20]
  
  /* ADC peripherals Init */
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_8b;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 8004e9a:	716c      	strb	r4, [r5, #5]
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8004e9c:	60ac      	str	r4, [r5, #8]
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8004e9e:	612c      	str	r4, [r5, #16]
  ADC_InitStructure.ADC_NbrOfConversion = 2;
  ADC_Init(ADC1, &ADC_InitStructure);
 8004ea0:	f7fb f9aa 	bl	80001f8 <ADC_Init>
  
  /* Configure ADC Channels pin as analog input */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8004ea4:	2503      	movs	r5, #3
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 2;
  ADC_Init(ADC1, &ADC_InitStructure);
  
  /* Configure ADC Channels pin as analog input */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8004ea6:	2304      	movs	r3, #4
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004ea8:	4845      	ldr	r0, [pc, #276]	; (8004fc0 <Audio_Test+0x184>)
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 2;
  ADC_Init(ADC1, &ADC_InitStructure);
  
  /* Configure ADC Channels pin as analog input */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8004eaa:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004eac:	4669      	mov	r1, sp
  ADC_InitStructure.ADC_NbrOfConversion = 2;
  ADC_Init(ADC1, &ADC_InitStructure);
  
  /* Configure ADC Channels pin as analog input */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004eae:	f88d 6005 	strb.w	r6, [sp, #5]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8004eb2:	f88d 5004 	strb.w	r5, [sp, #4]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8004eb6:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004eba:	f7fc f93f 	bl	800113c <GPIO_Init>
  
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
 8004ebe:	2308      	movs	r3, #8
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004ec0:	483f      	ldr	r0, [pc, #252]	; (8004fc0 <Audio_Test+0x184>)
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
 8004ec2:	9300      	str	r3, [sp, #0]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004ec4:	4669      	mov	r1, sp
 8004ec6:	f7fc f939 	bl	800113c <GPIO_Init>
  counter1 = 0;
  counter0 = 0;
  audioteststatus = 0;
 
  /* Set Injected sequencer length */
  ADC_InjectedSequencerLengthConfig(ADC1, 2);
 8004eca:	4631      	mov	r1, r6
 8004ecc:	483b      	ldr	r0, [pc, #236]	; (8004fbc <Audio_Test+0x180>)
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  
  counter1 = 0;
 8004ece:	f8a9 4000 	strh.w	r4, [r9]
  counter0 = 0;
 8004ed2:	f8a8 4000 	strh.w	r4, [r8]
  audioteststatus = 0;
 
  /* Set Injected sequencer length */
  ADC_InjectedSequencerLengthConfig(ADC1, 2);
 8004ed6:	f7fb faed 	bl	80004b4 <ADC_InjectedSequencerLengthConfig>
  /* ADCperipheral[PerIdx] Injected Channel Config */ 
  ADC_InjectedChannelConfig(ADC1, ADC_Channel_2, 1, ADC_SampleTime_56Cycles);
 8004eda:	4631      	mov	r1, r6
 8004edc:	463a      	mov	r2, r7
 8004ede:	462b      	mov	r3, r5
 8004ee0:	4836      	ldr	r0, [pc, #216]	; (8004fbc <Audio_Test+0x180>)
 8004ee2:	f7fb fab9 	bl	8000458 <ADC_InjectedChannelConfig>
  ADC_InjectedChannelConfig(ADC1, ADC_Channel_3, 2, ADC_SampleTime_56Cycles);
 8004ee6:	4632      	mov	r2, r6
 8004ee8:	462b      	mov	r3, r5
 8004eea:	4629      	mov	r1, r5
 8004eec:	4833      	ldr	r0, [pc, #204]	; (8004fbc <Audio_Test+0x180>)
 8004eee:	f7fb fab3 	bl	8000458 <ADC_InjectedChannelConfig>
  
  /* Enable ADC1 */
  ADC_Cmd(ADC1, ENABLE);
 8004ef2:	4639      	mov	r1, r7
 8004ef4:	4831      	ldr	r0, [pc, #196]	; (8004fbc <Audio_Test+0x180>)
 8004ef6:	f7fb f9cf 	bl	8000298 <ADC_Cmd>
 
  TimingDelay = 500;
 8004efa:	4b32      	ldr	r3, [pc, #200]	; (8004fc4 <Audio_Test+0x188>)
 8004efc:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8004f00:	601a      	str	r2, [r3, #0]
 8004f02:	464d      	mov	r5, r9
 8004f04:	4646      	mov	r6, r8
 8004f06:	461f      	mov	r7, r3
  /* Wait until detecting 500 data*/
  while((audioteststatus == 0)&&(TimingDelay != 0))
 8004f08:	683c      	ldr	r4, [r7, #0]
 8004f0a:	2c00      	cmp	r4, #0
 8004f0c:	d03d      	beq.n	8004f8a <Audio_Test+0x14e>
  {
    /* ADC1 injected Software Start Conv */ 
    ADC_SoftwareStartInjectedConv(ADC1);
 8004f0e:	482b      	ldr	r0, [pc, #172]	; (8004fbc <Audio_Test+0x180>)
    
    ConvData1 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_1);
 8004f10:	4c2d      	ldr	r4, [pc, #180]	; (8004fc8 <Audio_Test+0x18c>)
  TimingDelay = 500;
  /* Wait until detecting 500 data*/
  while((audioteststatus == 0)&&(TimingDelay != 0))
  {
    /* ADC1 injected Software Start Conv */ 
    ADC_SoftwareStartInjectedConv(ADC1);
 8004f12:	f7fb faef 	bl	80004f4 <ADC_SoftwareStartInjectedConv>
    
    ConvData1 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_1);
 8004f16:	2114      	movs	r1, #20
 8004f18:	4828      	ldr	r0, [pc, #160]	; (8004fbc <Audio_Test+0x180>)
 8004f1a:	f7fb fb09 	bl	8000530 <ADC_GetInjectedConversionValue>
    ConvData2 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_2);
 8004f1e:	2118      	movs	r1, #24
  while((audioteststatus == 0)&&(TimingDelay != 0))
  {
    /* ADC1 injected Software Start Conv */ 
    ADC_SoftwareStartInjectedConv(ADC1);
    
    ConvData1 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_1);
 8004f20:	8020      	strh	r0, [r4, #0]
    ConvData2 = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_2);
 8004f22:	4826      	ldr	r0, [pc, #152]	; (8004fbc <Audio_Test+0x180>)
 8004f24:	f7fb fb04 	bl	8000530 <ADC_GetInjectedConversionValue>
 8004f28:	4b28      	ldr	r3, [pc, #160]	; (8004fcc <Audio_Test+0x190>)
 8004f2a:	8018      	strh	r0, [r3, #0]
    
    /* 1.75V equals to 150 */
    if ((ConvData1 > 150) && (ConvData2 < 10) && (counter1 != 500))
 8004f2c:	8822      	ldrh	r2, [r4, #0]
 8004f2e:	b292      	uxth	r2, r2
 8004f30:	2a96      	cmp	r2, #150	; 0x96
 8004f32:	d90d      	bls.n	8004f50 <Audio_Test+0x114>
 8004f34:	881a      	ldrh	r2, [r3, #0]
 8004f36:	b292      	uxth	r2, r2
 8004f38:	2a09      	cmp	r2, #9
 8004f3a:	d809      	bhi.n	8004f50 <Audio_Test+0x114>
 8004f3c:	8829      	ldrh	r1, [r5, #0]
 8004f3e:	4a24      	ldr	r2, [pc, #144]	; (8004fd0 <Audio_Test+0x194>)
 8004f40:	b289      	uxth	r1, r1
 8004f42:	f5b1 7ffa 	cmp.w	r1, #500	; 0x1f4
 8004f46:	d003      	beq.n	8004f50 <Audio_Test+0x114>
    {
      counter1 ++;
 8004f48:	8811      	ldrh	r1, [r2, #0]
 8004f4a:	3101      	adds	r1, #1
 8004f4c:	b289      	uxth	r1, r1
 8004f4e:	8011      	strh	r1, [r2, #0]
    }
    if ((ConvData1 < 10) && (ConvData2 > 150) && (counter0 != 500))
 8004f50:	8822      	ldrh	r2, [r4, #0]
 8004f52:	b292      	uxth	r2, r2
 8004f54:	2a09      	cmp	r2, #9
 8004f56:	d80d      	bhi.n	8004f74 <Audio_Test+0x138>
 8004f58:	881b      	ldrh	r3, [r3, #0]
 8004f5a:	b29b      	uxth	r3, r3
 8004f5c:	2b96      	cmp	r3, #150	; 0x96
 8004f5e:	d909      	bls.n	8004f74 <Audio_Test+0x138>
 8004f60:	8832      	ldrh	r2, [r6, #0]
 8004f62:	4b1c      	ldr	r3, [pc, #112]	; (8004fd4 <Audio_Test+0x198>)
 8004f64:	b292      	uxth	r2, r2
 8004f66:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
 8004f6a:	d003      	beq.n	8004f74 <Audio_Test+0x138>
    {
      counter0 ++;
 8004f6c:	881a      	ldrh	r2, [r3, #0]
 8004f6e:	3201      	adds	r2, #1
 8004f70:	b292      	uxth	r2, r2
 8004f72:	801a      	strh	r2, [r3, #0]
    }
    if((counter1 == 500) && (counter0 == 500))
 8004f74:	882b      	ldrh	r3, [r5, #0]
 8004f76:	b29b      	uxth	r3, r3
 8004f78:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8004f7c:	d1c4      	bne.n	8004f08 <Audio_Test+0xcc>
 8004f7e:	8833      	ldrh	r3, [r6, #0]
 8004f80:	b29b      	uxth	r3, r3
  /* Enable ADC1 */
  ADC_Cmd(ADC1, ENABLE);
 
  TimingDelay = 500;
  /* Wait until detecting 500 data*/
  while((audioteststatus == 0)&&(TimingDelay != 0))
 8004f82:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8004f86:	d1bf      	bne.n	8004f08 <Audio_Test+0xcc>
 8004f88:	2401      	movs	r4, #1
      audioteststatus = 1; 
    }
  }
  
  /* Disable ADC Peripherals */ 
  ADC_Cmd(ADC1, DISABLE);
 8004f8a:	480c      	ldr	r0, [pc, #48]	; (8004fbc <Audio_Test+0x180>)
 8004f8c:	2100      	movs	r1, #0
 8004f8e:	f7fb f983 	bl	8000298 <ADC_Cmd>
  
  /* Audio test status: FAIL */ 
  if(audioteststatus == 0x00)
 8004f92:	b90c      	cbnz	r4, 8004f98 <Audio_Test+0x15c>
  {
    Fail_Handler();
 8004f94:	f7fe fa1c 	bl	80033d0 <Fail_Handler>
  }
  
  /* Turn Green LED ON: signaling Audio USB Test part2 PASS */
  STM_EVAL_LEDOn(LED4);
 8004f98:	2000      	movs	r0, #0
 8004f9a:	f7fe fa5d 	bl	8003458 <STM_EVAL_LEDOn>
  
  /* Waiting User_Button pressed */
  while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_RESET)
 8004f9e:	2000      	movs	r0, #0
 8004fa0:	f7fe fabe 	bl	8003520 <STM_EVAL_PBGetState>
 8004fa4:	2800      	cmp	r0, #0
 8004fa6:	d0fa      	beq.n	8004f9e <Audio_Test+0x162>
  {}
  
  /* Turn Green LED OFF: signaling the end of Audio USB Test part2 */
  STM_EVAL_LEDOff(LED4);
 8004fa8:	2000      	movs	r0, #0
 8004faa:	f7fe fa61 	bl	8003470 <STM_EVAL_LEDOff>
}
 8004fae:	b003      	add	sp, #12
 8004fb0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004fb4:	20000ca0 	.word	0x20000ca0
 8004fb8:	20000c78 	.word	0x20000c78
 8004fbc:	40012000 	.word	0x40012000
 8004fc0:	40020000 	.word	0x40020000
 8004fc4:	200005f0 	.word	0x200005f0
 8004fc8:	20000c74 	.word	0x20000c74
 8004fcc:	20000cc8 	.word	0x20000cc8
 8004fd0:	200005d2 	.word	0x200005d2
 8004fd4:	200005d0 	.word	0x200005d0

08004fd8 <Microphone_MEMS_Test>:
  *   Microphone MEMS peripheral.
  * @param None
  * @retval None
  */
void Microphone_MEMS_Test(void)
{
 8004fd8:	b570      	push	{r4, r5, r6, lr}
  uint8_t index = 0x00;
  I2S_InitTypeDef  I2S_InitStructure;
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable the SPI clock */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8004fda:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  *   Microphone MEMS peripheral.
  * @param None
  * @retval None
  */
void Microphone_MEMS_Test(void)
{
 8004fde:	b086      	sub	sp, #24
  uint8_t index = 0x00;
  I2S_InitTypeDef  I2S_InitStructure;
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable the SPI clock */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8004fe0:	2101      	movs	r1, #1
 8004fe2:	f7fc fd6d 	bl	8001ac0 <RCC_APB1PeriphClockCmd>

  /* Enable GPIO clocks */
  RCC_AHB1PeriphClockCmd(SPI_SCK_GPIO_CLK | SPI_MOSI_GPIO_CLK, ENABLE);
 8004fe6:	2006      	movs	r0, #6
 8004fe8:	2101      	movs	r1, #1
 8004fea:	f7fc fd45 	bl	8001a78 <RCC_AHB1PeriphClockCmd>
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = SPI_SCK_PIN;
 8004fee:	ad06      	add	r5, sp, #24
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);

  /* Enable GPIO clocks */
  RCC_AHB1PeriphClockCmd(SPI_SCK_GPIO_CLK | SPI_MOSI_GPIO_CLK, ENABLE);

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8004ff0:	2302      	movs	r3, #2
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004ff2:	2400      	movs	r4, #0
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8004ff4:	2601      	movs	r6, #1
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);

  /* Enable GPIO clocks */
  RCC_AHB1PeriphClockCmd(SPI_SCK_GPIO_CLK | SPI_MOSI_GPIO_CLK, ENABLE);

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8004ff6:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = SPI_SCK_PIN;
  GPIO_Init(SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 8004ffa:	482d      	ldr	r0, [pc, #180]	; (80050b0 <Microphone_MEMS_Test+0xd8>)

  /* Enable GPIO clocks */
  RCC_AHB1PeriphClockCmd(SPI_SCK_GPIO_CLK | SPI_MOSI_GPIO_CLK, ENABLE);

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004ffc:	f88d 4006 	strb.w	r4, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = SPI_SCK_PIN;
 8005000:	f44f 6380 	mov.w	r3, #1024	; 0x400
  GPIO_Init(SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 8005004:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = SPI_SCK_PIN;
 8005006:	f845 3d18 	str.w	r3, [r5, #-24]!
  /* Enable GPIO clocks */
  RCC_AHB1PeriphClockCmd(SPI_SCK_GPIO_CLK | SPI_MOSI_GPIO_CLK, ENABLE);

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 800500a:	f88d 6007 	strb.w	r6, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
 800500e:	f88d 6005 	strb.w	r6, [sp, #5]

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = SPI_SCK_PIN;
  GPIO_Init(SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 8005012:	f7fc f893 	bl	800113c <GPIO_Init>
  
  /* Connect SPI pins to AF5 */  
  GPIO_PinAFConfig(SPI_SCK_GPIO_PORT, SPI_SCK_SOURCE, SPI_SCK_AF);
 8005016:	2205      	movs	r2, #5
 8005018:	4825      	ldr	r0, [pc, #148]	; (80050b0 <Microphone_MEMS_Test+0xd8>)
  I2S_Cmd(SPI2, ENABLE);
  
  /* Waiting until MEMS microphone ready : Wake-up Time */
  Delay(10);
  
  TimingDelay = 500;
 800501a:	4d26      	ldr	r5, [pc, #152]	; (80050b4 <Microphone_MEMS_Test+0xdc>)
  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = SPI_SCK_PIN;
  GPIO_Init(SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
  
  /* Connect SPI pins to AF5 */  
  GPIO_PinAFConfig(SPI_SCK_GPIO_PORT, SPI_SCK_SOURCE, SPI_SCK_AF);
 800501c:	210a      	movs	r1, #10
 800501e:	f7fc f92b 	bl	8001278 <GPIO_PinAFConfig>
  
  /* SPI MOSI pin configuration */
  GPIO_InitStructure.GPIO_Pin =  SPI_MOSI_PIN;
 8005022:	2308      	movs	r3, #8
  GPIO_Init(SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
 8005024:	4824      	ldr	r0, [pc, #144]	; (80050b8 <Microphone_MEMS_Test+0xe0>)
  
  /* Connect SPI pins to AF5 */  
  GPIO_PinAFConfig(SPI_SCK_GPIO_PORT, SPI_SCK_SOURCE, SPI_SCK_AF);
  
  /* SPI MOSI pin configuration */
  GPIO_InitStructure.GPIO_Pin =  SPI_MOSI_PIN;
 8005026:	9300      	str	r3, [sp, #0]
  GPIO_Init(SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
 8005028:	4669      	mov	r1, sp
 800502a:	f7fc f887 	bl	800113c <GPIO_Init>
  
  GPIO_PinAFConfig(SPI_MOSI_GPIO_PORT, SPI_MOSI_SOURCE, SPI_MOSI_AF);
 800502e:	2205      	movs	r2, #5
 8005030:	2103      	movs	r1, #3
 8005032:	4821      	ldr	r0, [pc, #132]	; (80050b8 <Microphone_MEMS_Test+0xe0>)
 8005034:	f7fc f920 	bl	8001278 <GPIO_PinAFConfig>
  
  /* I2S configuration -------------------------------------------------------*/
  SPI_I2S_DeInit(SPI2);
 8005038:	4820      	ldr	r0, [pc, #128]	; (80050bc <Microphone_MEMS_Test+0xe4>)
 800503a:	f7fc fe0f 	bl	8001c5c <SPI_I2S_DeInit>
  I2S_InitStructure.I2S_AudioFreq = 64000;
 800503e:	f44f 437a 	mov.w	r3, #64000	; 0xfa00
 8005042:	9304      	str	r3, [sp, #16]
  I2S_InitStructure.I2S_Standard = I2S_Standard_MSB;
 8005044:	2310      	movs	r3, #16
 8005046:	f8ad 300a 	strh.w	r3, [sp, #10]
  I2S_InitStructure.I2S_DataFormat = I2S_DataFormat_16b;
  I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
  I2S_InitStructure.I2S_Mode = I2S_Mode_MasterRx;
  I2S_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Disable;
  /* Initialize the I2S peripheral with the structure above */
  I2S_Init(SPI2, &I2S_InitStructure);
 800504a:	481c      	ldr	r0, [pc, #112]	; (80050bc <Microphone_MEMS_Test+0xe4>)
  
  /* I2S configuration -------------------------------------------------------*/
  SPI_I2S_DeInit(SPI2);
  I2S_InitStructure.I2S_AudioFreq = 64000;
  I2S_InitStructure.I2S_Standard = I2S_Standard_MSB;
  I2S_InitStructure.I2S_DataFormat = I2S_DataFormat_16b;
 800504c:	f8ad 400c 	strh.w	r4, [sp, #12]
  I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
  I2S_InitStructure.I2S_Mode = I2S_Mode_MasterRx;
 8005050:	f44f 7340 	mov.w	r3, #768	; 0x300
  I2S_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Disable;
  /* Initialize the I2S peripheral with the structure above */
  I2S_Init(SPI2, &I2S_InitStructure);
 8005054:	a902      	add	r1, sp, #8
  SPI_I2S_DeInit(SPI2);
  I2S_InitStructure.I2S_AudioFreq = 64000;
  I2S_InitStructure.I2S_Standard = I2S_Standard_MSB;
  I2S_InitStructure.I2S_DataFormat = I2S_DataFormat_16b;
  I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
  I2S_InitStructure.I2S_Mode = I2S_Mode_MasterRx;
 8005056:	f8ad 3008 	strh.w	r3, [sp, #8]
  /* I2S configuration -------------------------------------------------------*/
  SPI_I2S_DeInit(SPI2);
  I2S_InitStructure.I2S_AudioFreq = 64000;
  I2S_InitStructure.I2S_Standard = I2S_Standard_MSB;
  I2S_InitStructure.I2S_DataFormat = I2S_DataFormat_16b;
  I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
 800505a:	f8ad 4014 	strh.w	r4, [sp, #20]
  I2S_InitStructure.I2S_Mode = I2S_Mode_MasterRx;
  I2S_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 800505e:	f8ad 400e 	strh.w	r4, [sp, #14]
  /* Initialize the I2S peripheral with the structure above */
  I2S_Init(SPI2, &I2S_InitStructure);
 8005062:	f7fc fe8d 	bl	8001d80 <I2S_Init>
  
  /* Enable the I2S peripheral */
  I2S_Cmd(SPI2, ENABLE);
 8005066:	4815      	ldr	r0, [pc, #84]	; (80050bc <Microphone_MEMS_Test+0xe4>)
 8005068:	4631      	mov	r1, r6
 800506a:	f7fc ff1d 	bl	8001ea8 <I2S_Cmd>
  
  /* Waiting until MEMS microphone ready : Wake-up Time */
  Delay(10);
 800506e:	200a      	movs	r0, #10
 8005070:	f7fd ff88 	bl	8002f84 <Delay>
  
  TimingDelay = 500;
 8005074:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8005078:	602b      	str	r3, [r5, #0]
  /* Wait until detect the click on the MEMS microphone or TimeOut delay*/
  while((index < 30) && (TimingDelay != 0x00))
 800507a:	682b      	ldr	r3, [r5, #0]
 800507c:	b1a3      	cbz	r3, 80050a8 <Microphone_MEMS_Test+0xd0>
  { 
    /* Waiting RXNE Flag or TimeOut delay */
    while((SPI_I2S_GetFlagStatus(SPI2, SPI_FLAG_RXNE) == RESET)&& (TimingDelay != 0x00))
 800507e:	480f      	ldr	r0, [pc, #60]	; (80050bc <Microphone_MEMS_Test+0xe4>)
 8005080:	2101      	movs	r1, #1
 8005082:	f7fc ffc9 	bl	8002018 <SPI_I2S_GetFlagStatus>
 8005086:	b910      	cbnz	r0, 800508e <Microphone_MEMS_Test+0xb6>
 8005088:	682b      	ldr	r3, [r5, #0]
 800508a:	2b00      	cmp	r3, #0
 800508c:	d1f7      	bne.n	800507e <Microphone_MEMS_Test+0xa6>
    {}
    data = SPI_I2S_ReceiveData(SPI2);
 800508e:	480b      	ldr	r0, [pc, #44]	; (80050bc <Microphone_MEMS_Test+0xe4>)
 8005090:	f7fc ff84 	bl	8001f9c <SPI_I2S_ReceiveData>
    if (data == 0xFFFF)
 8005094:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005098:	4298      	cmp	r0, r3
    {
      index++;  
 800509a:	bf04      	itt	eq
 800509c:	3401      	addeq	r4, #1
 800509e:	b2e4      	uxtbeq	r4, r4
  /* Waiting until MEMS microphone ready : Wake-up Time */
  Delay(10);
  
  TimingDelay = 500;
  /* Wait until detect the click on the MEMS microphone or TimeOut delay*/
  while((index < 30) && (TimingDelay != 0x00))
 80050a0:	2c1d      	cmp	r4, #29
 80050a2:	d9ea      	bls.n	800507a <Microphone_MEMS_Test+0xa2>
      index++;  
    }
  }
  
  /* MEMS microphone test status: Timeout occurs */
  if(index != 30)
 80050a4:	2c1e      	cmp	r4, #30
 80050a6:	d001      	beq.n	80050ac <Microphone_MEMS_Test+0xd4>
  {
    Fail_Handler();
 80050a8:	f7fe f992 	bl	80033d0 <Fail_Handler>
  }
}
 80050ac:	b006      	add	sp, #24
 80050ae:	bd70      	pop	{r4, r5, r6, pc}
 80050b0:	40020400 	.word	0x40020400
 80050b4:	200005f0 	.word	0x200005f0
 80050b8:	40020800 	.word	0x40020800
 80050bc:	40003800 	.word	0x40003800

080050c0 <LSM303DLHC_CompassReadAcc>:
* @brief Read LSM303DLHC output register, and calculate the acceleration ACC=(1/SENSITIVITY)* (out_h*256+out_l)/16 (12 bit rappresentation)
* @param pnData: pointer to float buffer where to store data
* @retval None
*/
void LSM303DLHC_CompassReadAcc(float* pfData)
{
 80050c0:	b570      	push	{r4, r5, r6, lr}
 80050c2:	b086      	sub	sp, #24
  uint8_t buffer[6], cDivider;
  uint8_t i = 0;
  float LSM_Acc_Sensitivity = LSM_Acc_Sensitivity_2g;
  
  /* Read the register content */
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, 2, ctrlx);
 80050c4:	2123      	movs	r1, #35	; 0x23
 80050c6:	2202      	movs	r2, #2
 80050c8:	ab01      	add	r3, sp, #4
* @brief Read LSM303DLHC output register, and calculate the acceleration ACC=(1/SENSITIVITY)* (out_h*256+out_l)/16 (12 bit rappresentation)
* @param pnData: pointer to float buffer where to store data
* @retval None
*/
void LSM303DLHC_CompassReadAcc(float* pfData)
{
 80050ca:	4606      	mov	r6, r0
  uint8_t i = 0;
  float LSM_Acc_Sensitivity = LSM_Acc_Sensitivity_2g;
  
  /* Read the register content */
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, 2, ctrlx);
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, 6, buffer);
 80050cc:	ac04      	add	r4, sp, #16
  uint8_t buffer[6], cDivider;
  uint8_t i = 0;
  float LSM_Acc_Sensitivity = LSM_Acc_Sensitivity_2g;
  
  /* Read the register content */
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, 2, ctrlx);
 80050ce:	2032      	movs	r0, #50	; 0x32
 80050d0:	f7fe ff92 	bl	8003ff8 <LSM303DLHC_Read>
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, 6, buffer);
 80050d4:	2128      	movs	r1, #40	; 0x28
 80050d6:	2206      	movs	r2, #6
 80050d8:	4623      	mov	r3, r4
 80050da:	2032      	movs	r0, #50	; 0x32
 80050dc:	f7fe ff8c 	bl	8003ff8 <LSM303DLHC_Read>
  
  if(ctrlx[1]&0x40)
 80050e0:	f89d 3005 	ldrb.w	r3, [sp, #5]
    cDivider=64;
  else
    cDivider=16;
  
  /* check in the control register4 the data alignment*/
  if(!(ctrlx[0] & 0x40) || (ctrlx[1] & 0x40)) /* Little Endian Mode or FIFO mode */
 80050e4:	f89d 1004 	ldrb.w	r1, [sp, #4]
  
  /* Read the register content */
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, 2, ctrlx);
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, 6, buffer);
  
  if(ctrlx[1]&0x40)
 80050e8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    cDivider=64;
 80050ec:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80050f0:	2b00      	cmp	r3, #0
 80050f2:	bf0c      	ite	eq
 80050f4:	2310      	moveq	r3, #16
 80050f6:	2340      	movne	r3, #64	; 0x40
  else
    cDivider=16;
  
  /* check in the control register4 the data alignment*/
  if(!(ctrlx[0] & 0x40) || (ctrlx[1] & 0x40)) /* Little Endian Mode or FIFO mode */
 80050f8:	f011 0f40 	tst.w	r1, #64	; 0x40
 80050fc:	ad02      	add	r5, sp, #8
 80050fe:	d000      	beq.n	8005102 <LSM303DLHC_CompassReadAcc+0x42>
 8005100:	b1ba      	cbz	r2, 8005132 <LSM303DLHC_CompassReadAcc+0x72>
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, 6, buffer);
  
  if(ctrlx[1]&0x40)
    cDivider=64;
  else
    cDivider=16;
 8005102:	2200      	movs	r2, #0
 8005104:	18a1      	adds	r1, r4, r2
  /* check in the control register4 the data alignment*/
  if(!(ctrlx[0] & 0x40) || (ctrlx[1] & 0x40)) /* Little Endian Mode or FIFO mode */
  {
    for(i=0; i<3; i++)
    {
      pnRawData[i]=((int16_t)((uint16_t)buffer[2*i+1] << 8) + buffer[2*i])/cDivider;
 8005106:	f991 0001 	ldrsb.w	r0, [r1, #1]
 800510a:	5ca1      	ldrb	r1, [r4, r2]
 800510c:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 8005110:	fb91 f1f3 	sdiv	r1, r1, r3
 8005114:	52a9      	strh	r1, [r5, r2]
 8005116:	3202      	adds	r2, #2
    cDivider=16;
  
  /* check in the control register4 the data alignment*/
  if(!(ctrlx[0] & 0x40) || (ctrlx[1] & 0x40)) /* Little Endian Mode or FIFO mode */
  {
    for(i=0; i<3; i++)
 8005118:	2a06      	cmp	r2, #6
 800511a:	d1f3      	bne.n	8005104 <LSM303DLHC_CompassReadAcc+0x44>
  {
    for(i=0; i<3; i++)
      pnRawData[i]=((int16_t)((uint16_t)buffer[2*i] << 8) + buffer[2*i+1])/cDivider;
  }
  /* Read the register content */
  LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, 2, ctrlx);
 800511c:	ab01      	add	r3, sp, #4
 800511e:	2032      	movs	r0, #50	; 0x32
 8005120:	2123      	movs	r1, #35	; 0x23
 8005122:	2202      	movs	r2, #2
 8005124:	f7fe ff68 	bl	8003ff8 <LSM303DLHC_Read>
  
  
  if(ctrlx[1]&0x40)
 8005128:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800512c:	065b      	lsls	r3, r3, #25
 800512e:	d420      	bmi.n	8005172 <LSM303DLHC_CompassReadAcc+0xb2>
 8005130:	e00b      	b.n	800514a <LSM303DLHC_CompassReadAcc+0x8a>
 8005132:	18a1      	adds	r1, r4, r2
    }
  }
  else /* Big Endian Mode */
  {
    for(i=0; i<3; i++)
      pnRawData[i]=((int16_t)((uint16_t)buffer[2*i] << 8) + buffer[2*i+1])/cDivider;
 8005134:	56a0      	ldrsb	r0, [r4, r2]
 8005136:	7849      	ldrb	r1, [r1, #1]
 8005138:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 800513c:	fb91 f1f3 	sdiv	r1, r1, r3
 8005140:	52a9      	strh	r1, [r5, r2]
 8005142:	3202      	adds	r2, #2
      pnRawData[i]=((int16_t)((uint16_t)buffer[2*i+1] << 8) + buffer[2*i])/cDivider;
    }
  }
  else /* Big Endian Mode */
  {
    for(i=0; i<3; i++)
 8005144:	2a06      	cmp	r2, #6
 8005146:	d1f4      	bne.n	8005132 <LSM303DLHC_CompassReadAcc+0x72>
 8005148:	e7e8      	b.n	800511c <LSM303DLHC_CompassReadAcc+0x5c>
  }
  else
  {
    /* normal mode */
    /* switch the sensitivity value set in the CRTL4*/
    switch(ctrlx[0] & 0x30)
 800514a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800514e:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8005152:	2b20      	cmp	r3, #32
 8005154:	d00d      	beq.n	8005172 <LSM303DLHC_CompassReadAcc+0xb2>
 8005156:	2b30      	cmp	r3, #48	; 0x30
 8005158:	d008      	beq.n	800516c <LSM303DLHC_CompassReadAcc+0xac>
{
  int16_t pnRawData[3];
  uint8_t ctrlx[2];
  uint8_t buffer[6], cDivider;
  uint8_t i = 0;
  float LSM_Acc_Sensitivity = LSM_Acc_Sensitivity_2g;
 800515a:	2b10      	cmp	r3, #16
 800515c:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 8005160:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8005164:	bf08      	it	eq
 8005166:	eef0 7a47 	vmoveq.f32	s15, s14
 800516a:	e004      	b.n	8005176 <LSM303DLHC_CompassReadAcc+0xb6>
      break;
    case LSM303DLHC_FULLSCALE_8G:
      LSM_Acc_Sensitivity = LSM_Acc_Sensitivity_8g;
      break;
    case LSM303DLHC_FULLSCALE_16G:
      LSM_Acc_Sensitivity = LSM_Acc_Sensitivity_16g;
 800516c:	eddf 7a0a 	vldr	s15, [pc, #40]	; 8005198 <LSM303DLHC_CompassReadAcc+0xd8>
      break;
 8005170:	e001      	b.n	8005176 <LSM303DLHC_CompassReadAcc+0xb6>
  
  
  if(ctrlx[1]&0x40)
  {
    /* FIFO mode */
    LSM_Acc_Sensitivity = 0.25;
 8005172:	eef5 7a00 	vmov.f32	s15, #80	; 0x50
 8005176:	4630      	mov	r0, r6
 8005178:	2300      	movs	r3, #0
  }
  
  /* Obtain the mg value for the three axis */
  for(i=0; i<3; i++)
  {
    pfData[i]=(float)pnRawData[i]/LSM_Acc_Sensitivity;
 800517a:	5eea      	ldrsh	r2, [r5, r3]
 800517c:	ee07 2a10 	vmov	s14, r2
 8005180:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8005184:	3302      	adds	r3, #2
 8005186:	ee87 7a27 	vdiv.f32	s14, s14, s15
      break;
    }
  }
  
  /* Obtain the mg value for the three axis */
  for(i=0; i<3; i++)
 800518a:	2b06      	cmp	r3, #6
  {
    pfData[i]=(float)pnRawData[i]/LSM_Acc_Sensitivity;
 800518c:	eca0 7a01 	vstmia	r0!, {s14}
      break;
    }
  }
  
  /* Obtain the mg value for the three axis */
  for(i=0; i<3; i++)
 8005190:	d1f3      	bne.n	800517a <LSM303DLHC_CompassReadAcc+0xba>
  {
    pfData[i]=(float)pnRawData[i]/LSM_Acc_Sensitivity;
  }
}
 8005192:	b006      	add	sp, #24
 8005194:	bd70      	pop	{r4, r5, r6, pc}
 8005196:	bf00      	nop
 8005198:	3daacd9f 	.word	0x3daacd9f

0800519c <LSM303DLHC_MEMS_Test>:
  *   MEMS peripheral.
  * @param None
  * @retval None
  */
void LSM303DLHC_MEMS_Test(void)
{
 800519c:	b530      	push	{r4, r5, lr}
 800519e:	b085      	sub	sp, #20
  uint8_t xdata = 0, ydata = 0;
  
  /* MEMS configuration ------------------------------------------------------*/
   /* Fill the accelerometer structure */
  LSM303DLHCAcc_InitStructure.Power_Mode = LSM303DLHC_NORMAL_MODE;
  LSM303DLHCAcc_InitStructure.AccOutput_DataRate = LSM303DLHC_ODR_50_HZ;
 80051a0:	2340      	movs	r3, #64	; 0x40
 80051a2:	f88d 3009 	strb.w	r3, [sp, #9]
  LSM303DLHCAcc_InitStructure.Axes_Enable= LSM303DLHC_AXES_ENABLE;
 80051a6:	2307      	movs	r3, #7
 80051a8:	f88d 300a 	strb.w	r3, [sp, #10]
  LSM303DLHCAcc_InitStructure.AccFull_Scale = LSM303DLHC_FULLSCALE_2G;
  LSM303DLHCAcc_InitStructure.BlockData_Update = LSM303DLHC_BlockUpdate_Continous;
  LSM303DLHCAcc_InitStructure.Endianness=LSM303DLHC_BLE_LSB;
  LSM303DLHCAcc_InitStructure.High_Resolution=LSM303DLHC_HR_ENABLE;
 80051ac:	2308      	movs	r3, #8
  uint8_t memsteststatus = 0x00;
  uint8_t xdata = 0, ydata = 0;
  
  /* MEMS configuration ------------------------------------------------------*/
   /* Fill the accelerometer structure */
  LSM303DLHCAcc_InitStructure.Power_Mode = LSM303DLHC_NORMAL_MODE;
 80051ae:	2400      	movs	r4, #0
  LSM303DLHCAcc_InitStructure.AccFull_Scale = LSM303DLHC_FULLSCALE_2G;
  LSM303DLHCAcc_InitStructure.BlockData_Update = LSM303DLHC_BlockUpdate_Continous;
  LSM303DLHCAcc_InitStructure.Endianness=LSM303DLHC_BLE_LSB;
  LSM303DLHCAcc_InitStructure.High_Resolution=LSM303DLHC_HR_ENABLE;
  /* Configure the accelerometer main parameters */
  LSM303DLHC_AccInit(&LSM303DLHCAcc_InitStructure);
 80051b0:	eb0d 0003 	add.w	r0, sp, r3
  LSM303DLHCAcc_InitStructure.AccOutput_DataRate = LSM303DLHC_ODR_50_HZ;
  LSM303DLHCAcc_InitStructure.Axes_Enable= LSM303DLHC_AXES_ENABLE;
  LSM303DLHCAcc_InitStructure.AccFull_Scale = LSM303DLHC_FULLSCALE_2G;
  LSM303DLHCAcc_InitStructure.BlockData_Update = LSM303DLHC_BlockUpdate_Continous;
  LSM303DLHCAcc_InitStructure.Endianness=LSM303DLHC_BLE_LSB;
  LSM303DLHCAcc_InitStructure.High_Resolution=LSM303DLHC_HR_ENABLE;
 80051b4:	f88d 300b 	strb.w	r3, [sp, #11]
  uint8_t memsteststatus = 0x00;
  uint8_t xdata = 0, ydata = 0;
  
  /* MEMS configuration ------------------------------------------------------*/
   /* Fill the accelerometer structure */
  LSM303DLHCAcc_InitStructure.Power_Mode = LSM303DLHC_NORMAL_MODE;
 80051b8:	f88d 4008 	strb.w	r4, [sp, #8]
  LSM303DLHCAcc_InitStructure.AccOutput_DataRate = LSM303DLHC_ODR_50_HZ;
  LSM303DLHCAcc_InitStructure.Axes_Enable= LSM303DLHC_AXES_ENABLE;
  LSM303DLHCAcc_InitStructure.AccFull_Scale = LSM303DLHC_FULLSCALE_2G;
 80051bc:	f88d 400e 	strb.w	r4, [sp, #14]
  LSM303DLHCAcc_InitStructure.BlockData_Update = LSM303DLHC_BlockUpdate_Continous;
 80051c0:	f88d 400c 	strb.w	r4, [sp, #12]
  LSM303DLHCAcc_InitStructure.Endianness=LSM303DLHC_BLE_LSB;
 80051c4:	f88d 400d 	strb.w	r4, [sp, #13]
  LSM303DLHCAcc_InitStructure.High_Resolution=LSM303DLHC_HR_ENABLE;
  /* Configure the accelerometer main parameters */
  LSM303DLHC_AccInit(&LSM303DLHCAcc_InitStructure);
 80051c8:	f7ff f8f0 	bl	80043ac <LSM303DLHC_AccInit>
  
  /* Fill the accelerometer LPF structure */
  LSM303DLHCFilter_InitStructure.HighPassFilter_Mode_Selection =LSM303DLHC_HPM_NORMAL_MODE;
 80051cc:	2380      	movs	r3, #128	; 0x80
 80051ce:	f88d 3004 	strb.w	r3, [sp, #4]
  LSM303DLHCFilter_InitStructure.HighPassFilter_CutOff_Frequency = LSM303DLHC_HPFCF_16;
  LSM303DLHCFilter_InitStructure.HighPassFilter_AOI1 = LSM303DLHC_HPF_AOI1_DISABLE;
  LSM303DLHCFilter_InitStructure.HighPassFilter_AOI2 = LSM303DLHC_HPF_AOI2_DISABLE;

  /* Configure the accelerometer LPF main parameters */
  LSM303DLHC_AccFilterConfig(&LSM303DLHCFilter_InitStructure);
 80051d2:	a801      	add	r0, sp, #4
  /* Configure the accelerometer main parameters */
  LSM303DLHC_AccInit(&LSM303DLHCAcc_InitStructure);
  
  /* Fill the accelerometer LPF structure */
  LSM303DLHCFilter_InitStructure.HighPassFilter_Mode_Selection =LSM303DLHC_HPM_NORMAL_MODE;
  LSM303DLHCFilter_InitStructure.HighPassFilter_CutOff_Frequency = LSM303DLHC_HPFCF_16;
 80051d4:	2310      	movs	r3, #16
 80051d6:	f88d 3005 	strb.w	r3, [sp, #5]
  LSM303DLHCFilter_InitStructure.HighPassFilter_AOI1 = LSM303DLHC_HPF_AOI1_DISABLE;
 80051da:	f88d 4006 	strb.w	r4, [sp, #6]
  LSM303DLHCFilter_InitStructure.HighPassFilter_AOI2 = LSM303DLHC_HPF_AOI2_DISABLE;
 80051de:	f88d 4007 	strb.w	r4, [sp, #7]

  /* Configure the accelerometer LPF main parameters */
  LSM303DLHC_AccFilterConfig(&LSM303DLHCFilter_InitStructure);
 80051e2:	f7ff f912 	bl	800440a <LSM303DLHC_AccFilterConfig>

  /* Required delay for the MEMS Accelerometre: Turn-on time = 3/Output data Rate 
                                                             = 3/100 = 30ms */
  Delay(30);
 80051e6:	201e      	movs	r0, #30
 80051e8:	f7fd fecc 	bl	8002f84 <Delay>
  
  TimingDelay = 500;
 80051ec:	4b1d      	ldr	r3, [pc, #116]	; (8005264 <LSM303DLHC_MEMS_Test+0xc8>)
 80051ee:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80051f2:	601a      	str	r2, [r3, #0]
 80051f4:	461d      	mov	r5, r3
  /* Wait until detecting all MEMS direction or timeout */
  while((memsteststatus == 0x00)&&(TimingDelay != 0x00))
 80051f6:	682b      	ldr	r3, [r5, #0]
 80051f8:	b1f3      	cbz	r3, 8005238 <LSM303DLHC_MEMS_Test+0x9c>
  {
    LSM303DLHC_CompassReadAcc(pBuffer);
 80051fa:	4c1b      	ldr	r4, [pc, #108]	; (8005268 <LSM303DLHC_MEMS_Test+0xcc>)
 80051fc:	4620      	mov	r0, r4
 80051fe:	f7ff ff5f 	bl	80050c0 <LSM303DLHC_CompassReadAcc>
    xdata = ABS((int8_t)(pBuffer[0]));
 8005202:	ed94 7a00 	vldr	s14, [r4]
    ydata = ABS((int8_t)(pBuffer[2]));
 8005206:	edd4 7a02 	vldr	s15, [r4, #8]
  TimingDelay = 500;
  /* Wait until detecting all MEMS direction or timeout */
  while((memsteststatus == 0x00)&&(TimingDelay != 0x00))
  {
    LSM303DLHC_CompassReadAcc(pBuffer);
    xdata = ABS((int8_t)(pBuffer[0]));
 800520a:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 800520e:	ee17 3a10 	vmov	r3, s14
 8005212:	b25b      	sxtb	r3, r3
 8005214:	2b00      	cmp	r3, #0
 8005216:	bfb8      	it	lt
 8005218:	425b      	neglt	r3, r3
    ydata = ABS((int8_t)(pBuffer[2]));
    /* Check test PASS condition */   
    if ((xdata > MEMS_PASSCONDITION) || (ydata > MEMS_PASSCONDITION)) 
 800521a:	b2db      	uxtb	r3, r3
 800521c:	2b05      	cmp	r3, #5
 800521e:	d80e      	bhi.n	800523e <LSM303DLHC_MEMS_Test+0xa2>
  /* Wait until detecting all MEMS direction or timeout */
  while((memsteststatus == 0x00)&&(TimingDelay != 0x00))
  {
    LSM303DLHC_CompassReadAcc(pBuffer);
    xdata = ABS((int8_t)(pBuffer[0]));
    ydata = ABS((int8_t)(pBuffer[2]));
 8005220:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005224:	ee17 3a90 	vmov	r3, s15
 8005228:	b25b      	sxtb	r3, r3
 800522a:	2b00      	cmp	r3, #0
 800522c:	bfb8      	it	lt
 800522e:	425b      	neglt	r3, r3
    /* Check test PASS condition */   
    if ((xdata > MEMS_PASSCONDITION) || (ydata > MEMS_PASSCONDITION)) 
 8005230:	b2db      	uxtb	r3, r3
 8005232:	2b05      	cmp	r3, #5
 8005234:	d803      	bhi.n	800523e <LSM303DLHC_MEMS_Test+0xa2>
 8005236:	e7de      	b.n	80051f6 <LSM303DLHC_MEMS_Test+0x5a>
    STM_EVAL_LEDOff(LED4);
  }
  /* MEMS test status: Timeout occurs */
  else
  {
    Fail_Handler();
 8005238:	f7fe f8ca 	bl	80033d0 <Fail_Handler>
 800523c:	e00f      	b.n	800525e <LSM303DLHC_MEMS_Test+0xc2>
  
  /* MEMS test status: PASS */ 
  if(memsteststatus != 0x00)
  {
    /* Turn Green LED ON: signaling MEMS Test PASS */
    STM_EVAL_LEDOn(LED4);
 800523e:	2000      	movs	r0, #0
 8005240:	f7fe f90a 	bl	8003458 <STM_EVAL_LEDOn>
    
    /* Waiting User Button is pressed */
    while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_RESET)
 8005244:	2000      	movs	r0, #0
 8005246:	f7fe f96b 	bl	8003520 <STM_EVAL_PBGetState>
 800524a:	2800      	cmp	r0, #0
 800524c:	d0fa      	beq.n	8005244 <LSM303DLHC_MEMS_Test+0xa8>
    {}
    
    /* Waiting User Button is Released */
    while (STM_EVAL_PBGetState(BUTTON_USER) == Bit_SET)
 800524e:	2000      	movs	r0, #0
 8005250:	f7fe f966 	bl	8003520 <STM_EVAL_PBGetState>
 8005254:	2801      	cmp	r0, #1
 8005256:	d0fa      	beq.n	800524e <LSM303DLHC_MEMS_Test+0xb2>
    {}
    
    /* Turn Green LED OFF: signaling the end of MEMS Test and switching to 
       the next Sub Test */
    STM_EVAL_LEDOff(LED4);
 8005258:	2000      	movs	r0, #0
 800525a:	f7fe f909 	bl	8003470 <STM_EVAL_LEDOff>
  /* MEMS test status: Timeout occurs */
  else
  {
    Fail_Handler();
  }
}
 800525e:	b005      	add	sp, #20
 8005260:	bd30      	pop	{r4, r5, pc}
 8005262:	bf00      	nop
 8005264:	200005f0 	.word	0x200005f0
 8005268:	20000cb0 	.word	0x20000cb0

0800526c <EVAL_AUDIO_TransferComplete_CallBack>:
  * @brief  Calculates the remaining file size and new position of the pointer.
  * @param  None
  * @retval None
  */
void EVAL_AUDIO_TransferComplete_CallBack(uint32_t pBuffer, uint32_t Size)
{
 800526c:	4770      	bx	lr
	...

08005270 <EVAL_AUDIO_GetSampleCallBack>:
  */
uint16_t EVAL_AUDIO_GetSampleCallBack(void)
{
  uint16_t data = 0;

  if (Left_Right==0)
 8005270:	4a0f      	ldr	r2, [pc, #60]	; (80052b0 <EVAL_AUDIO_GetSampleCallBack+0x40>)
 8005272:	4810      	ldr	r0, [pc, #64]	; (80052b4 <EVAL_AUDIO_GetSampleCallBack+0x44>)
 8005274:	8811      	ldrh	r1, [r2, #0]
  * @brief  Get next data sample callback
  * @param  None
  * @retval Next data sample to be sent
  */
uint16_t EVAL_AUDIO_GetSampleCallBack(void)
{
 8005276:	b530      	push	{r4, r5, lr}
  uint16_t data = 0;

  if (Left_Right==0)
 8005278:	b961      	cbnz	r1, 8005294 <EVAL_AUDIO_GetSampleCallBack+0x24>
  {
    /* Get the next sample to be sent */
    data = sinebuf[count++];
 800527a:	4b0f      	ldr	r3, [pc, #60]	; (80052b8 <EVAL_AUDIO_GetSampleCallBack+0x48>)
 800527c:	881d      	ldrh	r5, [r3, #0]
 800527e:	1c6c      	adds	r4, r5, #1
 8005280:	b2a4      	uxth	r4, r4
    
    if (count == 48)
 8005282:	2c30      	cmp	r4, #48	; 0x30
  uint16_t data = 0;

  if (Left_Right==0)
  {
    /* Get the next sample to be sent */
    data = sinebuf[count++];
 8005284:	801c      	strh	r4, [r3, #0]
    
    if (count == 48)
    {
      count = 0x00;
 8005286:	bf08      	it	eq
 8005288:	8019      	strheq	r1, [r3, #0]
    }
    Left_Right = 1;
 800528a:	2301      	movs	r3, #1
  uint16_t data = 0;

  if (Left_Right==0)
  {
    /* Get the next sample to be sent */
    data = sinebuf[count++];
 800528c:	f830 0015 	ldrh.w	r0, [r0, r5, lsl #1]
    
    if (count == 48)
    {
      count = 0x00;
    }
    Left_Right = 1;
 8005290:	8013      	strh	r3, [r2, #0]
 8005292:	bd30      	pop	{r4, r5, pc}
  }
  else
  {
    /* Get the next sample to be sent */
    data = sinebuf[count1++];
 8005294:	4b09      	ldr	r3, [pc, #36]	; (80052bc <EVAL_AUDIO_GetSampleCallBack+0x4c>)
 8005296:	881c      	ldrh	r4, [r3, #0]
 8005298:	1c61      	adds	r1, r4, #1
 800529a:	b289      	uxth	r1, r1
 800529c:	8019      	strh	r1, [r3, #0]
    
    if (count1 == 48)
 800529e:	2930      	cmp	r1, #48	; 0x30
 80052a0:	f04f 0100 	mov.w	r1, #0
    Left_Right = 1;
  }
  else
  {
    /* Get the next sample to be sent */
    data = sinebuf[count1++];
 80052a4:	f830 0014 	ldrh.w	r0, [r0, r4, lsl #1]
    
    if (count1 == 48)
    {
      count1 = 0x00;
 80052a8:	bf08      	it	eq
 80052aa:	8019      	strheq	r1, [r3, #0]
    }
    Left_Right = 0;
 80052ac:	8011      	strh	r1, [r2, #0]
  }
  return data;
}
 80052ae:	bd30      	pop	{r4, r5, pc}
 80052b0:	200005ce 	.word	0x200005ce
 80052b4:	08006ac2 	.word	0x08006ac2
 80052b8:	200005cc 	.word	0x200005cc
 80052bc:	200000ac 	.word	0x200000ac

080052c0 <Codec_TIMEOUT_UserCallback>:
  * @brief  Basic management of the timeout situation.
  * @param  None.
  * @retval None.
  */
uint32_t Codec_TIMEOUT_UserCallback(void)
{   
 80052c0:	e7fe      	b.n	80052c0 <Codec_TIMEOUT_UserCallback>
	...

080052c4 <USBD_HID_GetCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_HID_GetCfgDesc (uint8_t speed, uint16_t *length)
{
  *length = sizeof (USBD_HID_CfgDesc);
 80052c4:	2322      	movs	r3, #34	; 0x22
 80052c6:	800b      	strh	r3, [r1, #0]
  return USBD_HID_CfgDesc;
}
 80052c8:	4800      	ldr	r0, [pc, #0]	; (80052cc <USBD_HID_GetCfgDesc+0x8>)
 80052ca:	4770      	bx	lr
 80052cc:	200000f8 	.word	0x200000f8

080052d0 <USBD_HID_DataIn>:
  * @param  epnum: endpoint index
  * @retval status
  */
static uint8_t  USBD_HID_DataIn (void  *pdev, 
                              uint8_t epnum)
{
 80052d0:	b508      	push	{r3, lr}
  
  /* Ensure that the FIFO is empty before a new transfer, this condition could 
  be caused by  a new transfer before the end of the previous transfer */
  DCD_EP_Flush(pdev, HID_IN_EP);
 80052d2:	2181      	movs	r1, #129	; 0x81
 80052d4:	f001 f8d1 	bl	800647a <DCD_EP_Flush>
  return USBD_OK;
}
 80052d8:	2000      	movs	r0, #0
 80052da:	bd08      	pop	{r3, pc}

080052dc <USBD_HID_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_HID_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 80052dc:	b510      	push	{r4, lr}
  uint16_t len = 0;
  uint8_t  *pbuf = NULL;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80052de:	780c      	ldrb	r4, [r1, #0]
 80052e0:	f014 0460 	ands.w	r4, r4, #96	; 0x60
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_HID_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
 80052e4:	4603      	mov	r3, r0
  uint16_t len = 0;
  uint8_t  *pbuf = NULL;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80052e6:	d022      	beq.n	800532e <USBD_HID_Setup+0x52>
 80052e8:	2c20      	cmp	r4, #32
 80052ea:	d146      	bne.n	800537a <USBD_HID_Setup+0x9e>
  {
  case USB_REQ_TYPE_CLASS :  
    switch (req->bRequest)
 80052ec:	784a      	ldrb	r2, [r1, #1]
 80052ee:	3a02      	subs	r2, #2
 80052f0:	2a09      	cmp	r2, #9
 80052f2:	d817      	bhi.n	8005324 <USBD_HID_Setup+0x48>
 80052f4:	e8df f002 	tbb	[pc, r2]
 80052f8:	16160810 	.word	0x16160810
 80052fc:	16161616 	.word	0x16161616
 8005300:	050b      	.short	0x050b
    {
      
      
    case HID_REQ_SET_PROTOCOL:
      USBD_HID_Protocol = (uint8_t)(req->wValue);
 8005302:	788a      	ldrb	r2, [r1, #2]
 8005304:	4b1e      	ldr	r3, [pc, #120]	; (8005380 <USBD_HID_Setup+0xa4>)
 8005306:	e005      	b.n	8005314 <USBD_HID_Setup+0x38>
      break;
      
    case HID_REQ_GET_PROTOCOL:
      USBD_CtlSendData (pdev, 
 8005308:	4618      	mov	r0, r3
 800530a:	491d      	ldr	r1, [pc, #116]	; (8005380 <USBD_HID_Setup+0xa4>)
 800530c:	e006      	b.n	800531c <USBD_HID_Setup+0x40>
                        (uint8_t *)&USBD_HID_Protocol,
                        1);    
      break;
      
    case HID_REQ_SET_IDLE:
      USBD_HID_IdleState = (uint8_t)(req->wValue >> 8);
 800530e:	884a      	ldrh	r2, [r1, #2]
 8005310:	4b1c      	ldr	r3, [pc, #112]	; (8005384 <USBD_HID_Setup+0xa8>)
 8005312:	0a12      	lsrs	r2, r2, #8
 8005314:	601a      	str	r2, [r3, #0]
 8005316:	e030      	b.n	800537a <USBD_HID_Setup+0x9e>
      break;
      
    case HID_REQ_GET_IDLE:
      USBD_CtlSendData (pdev, 
 8005318:	491a      	ldr	r1, [pc, #104]	; (8005384 <USBD_HID_Setup+0xa8>)
 800531a:	4618      	mov	r0, r3
 800531c:	2201      	movs	r2, #1
 800531e:	f000 f98e 	bl	800563e <USBD_CtlSendData>
 8005322:	e02a      	b.n	800537a <USBD_HID_Setup+0x9e>
                        (uint8_t *)&USBD_HID_IdleState,
                        1);        
      break;      
      
    default:
      USBD_CtlError (pdev, req);
 8005324:	4618      	mov	r0, r3
 8005326:	f000 f9ed 	bl	8005704 <USBD_CtlError>
      return USBD_FAIL; 
 800532a:	2402      	movs	r4, #2
 800532c:	e026      	b.n	800537c <USBD_HID_Setup+0xa0>
    }
    break;
    
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 800532e:	784a      	ldrb	r2, [r1, #1]
 8005330:	2a0a      	cmp	r2, #10
 8005332:	d019      	beq.n	8005368 <USBD_HID_Setup+0x8c>
 8005334:	2a0b      	cmp	r2, #11
 8005336:	d01c      	beq.n	8005372 <USBD_HID_Setup+0x96>
 8005338:	2a06      	cmp	r2, #6
 800533a:	d11f      	bne.n	800537c <USBD_HID_Setup+0xa0>
    {
    case USB_REQ_GET_DESCRIPTOR: 
      if( req->wValue >> 8 == HID_REPORT_DESC)
 800533c:	884a      	ldrh	r2, [r1, #2]
 800533e:	0a12      	lsrs	r2, r2, #8
 8005340:	2a22      	cmp	r2, #34	; 0x22
 8005342:	d105      	bne.n	8005350 <USBD_HID_Setup+0x74>
      {
        len = MIN(HID_MOUSE_REPORT_DESC_SIZE , req->wLength);
 8005344:	88ca      	ldrh	r2, [r1, #6]
        pbuf = HID_MOUSE_ReportDesc;
 8005346:	4910      	ldr	r1, [pc, #64]	; (8005388 <USBD_HID_Setup+0xac>)
    switch (req->bRequest)
    {
    case USB_REQ_GET_DESCRIPTOR: 
      if( req->wValue >> 8 == HID_REPORT_DESC)
      {
        len = MIN(HID_MOUSE_REPORT_DESC_SIZE , req->wLength);
 8005348:	2a4a      	cmp	r2, #74	; 0x4a
 800534a:	bf28      	it	cs
 800534c:	224a      	movcs	r2, #74	; 0x4a
 800534e:	e009      	b.n	8005364 <USBD_HID_Setup+0x88>
        pbuf = HID_MOUSE_ReportDesc;
      }
      else if( req->wValue >> 8 == HID_DESCRIPTOR_TYPE)
 8005350:	2a21      	cmp	r2, #33	; 0x21
 8005352:	d105      	bne.n	8005360 <USBD_HID_Setup+0x84>
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
        pbuf = USBD_HID_Desc;   
#else
        pbuf = USBD_HID_CfgDesc + 0x12;
#endif 
        len = MIN(USB_HID_DESC_SIZ , req->wLength);
 8005354:	88ca      	ldrh	r2, [r1, #6]
      {
        
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
        pbuf = USBD_HID_Desc;   
#else
        pbuf = USBD_HID_CfgDesc + 0x12;
 8005356:	490d      	ldr	r1, [pc, #52]	; (800538c <USBD_HID_Setup+0xb0>)
#endif 
        len = MIN(USB_HID_DESC_SIZ , req->wLength);
 8005358:	2a09      	cmp	r2, #9
 800535a:	bf28      	it	cs
 800535c:	2209      	movcs	r2, #9
 800535e:	e001      	b.n	8005364 <USBD_HID_Setup+0x88>
  */
static uint8_t  USBD_HID_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
  uint16_t len = 0;
  uint8_t  *pbuf = NULL;
 8005360:	4621      	mov	r1, r4
  * @retval status
  */
static uint8_t  USBD_HID_Setup (void  *pdev, 
                                USB_SETUP_REQ *req)
{
  uint16_t len = 0;
 8005362:	4622      	mov	r2, r4
        pbuf = USBD_HID_CfgDesc + 0x12;
#endif 
        len = MIN(USB_HID_DESC_SIZ , req->wLength);
      }
      
      USBD_CtlSendData (pdev, 
 8005364:	4618      	mov	r0, r3
 8005366:	e001      	b.n	800536c <USBD_HID_Setup+0x90>
                        len);
      
      break;
      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 8005368:	4909      	ldr	r1, [pc, #36]	; (8005390 <USBD_HID_Setup+0xb4>)
 800536a:	2201      	movs	r2, #1
 800536c:	f000 f967 	bl	800563e <USBD_CtlSendData>
                        (uint8_t *)&USBD_HID_AltSet,
                        1);
      break;
 8005370:	e004      	b.n	800537c <USBD_HID_Setup+0xa0>
      
    case USB_REQ_SET_INTERFACE :
      USBD_HID_AltSet = (uint8_t)(req->wValue);
 8005372:	4b07      	ldr	r3, [pc, #28]	; (8005390 <USBD_HID_Setup+0xb4>)
 8005374:	788a      	ldrb	r2, [r1, #2]
 8005376:	601a      	str	r2, [r3, #0]
      break;
 8005378:	e000      	b.n	800537c <USBD_HID_Setup+0xa0>
    }
  }
  return USBD_OK;
 800537a:	2400      	movs	r4, #0
}
 800537c:	4620      	mov	r0, r4
 800537e:	bd10      	pop	{r4, pc}
 8005380:	200005d4 	.word	0x200005d4
 8005384:	200005d8 	.word	0x200005d8
 8005388:	200000ae 	.word	0x200000ae
 800538c:	2000010a 	.word	0x2000010a
 8005390:	200005dc 	.word	0x200005dc

08005394 <USBD_HID_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_HID_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8005394:	b510      	push	{r4, lr}
  /* Close HID EPs */
  DCD_EP_Close (pdev , HID_IN_EP);
 8005396:	2181      	movs	r1, #129	; 0x81
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_HID_DeInit (void  *pdev, 
                                 uint8_t cfgidx)
{
 8005398:	4604      	mov	r4, r0
  /* Close HID EPs */
  DCD_EP_Close (pdev , HID_IN_EP);
 800539a:	f000 ffee 	bl	800637a <DCD_EP_Close>
  DCD_EP_Close (pdev , HID_OUT_EP);
 800539e:	4620      	mov	r0, r4
 80053a0:	2101      	movs	r1, #1
 80053a2:	f000 ffea 	bl	800637a <DCD_EP_Close>
  
  
  return USBD_OK;
}
 80053a6:	2000      	movs	r0, #0
 80053a8:	bd10      	pop	{r4, pc}

080053aa <USBD_HID_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_HID_Init (void  *pdev, 
                               uint8_t cfgidx)
{
 80053aa:	b510      	push	{r4, lr}
  
  /* Open EP IN */
  DCD_EP_Open(pdev,
 80053ac:	2181      	movs	r1, #129	; 0x81
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_HID_Init (void  *pdev, 
                               uint8_t cfgidx)
{
 80053ae:	4604      	mov	r4, r0
  
  /* Open EP IN */
  DCD_EP_Open(pdev,
 80053b0:	2204      	movs	r2, #4
 80053b2:	2303      	movs	r3, #3
 80053b4:	f000 ffc0 	bl	8006338 <DCD_EP_Open>
              HID_IN_EP,
              HID_IN_PACKET,
              USB_OTG_EP_INT);
  
  /* Open EP OUT */
  DCD_EP_Open(pdev,
 80053b8:	4620      	mov	r0, r4
 80053ba:	2101      	movs	r1, #1
 80053bc:	2204      	movs	r2, #4
 80053be:	2303      	movs	r3, #3
 80053c0:	f000 ffba 	bl	8006338 <DCD_EP_Open>
              HID_OUT_EP,
              HID_OUT_PACKET,
              USB_OTG_EP_INT);
  
  return USBD_OK;
}
 80053c4:	2000      	movs	r0, #0
 80053c6:	bd10      	pop	{r4, pc}

080053c8 <USBD_HID_SendReport>:
  * @retval status
  */
uint8_t USBD_HID_SendReport     (USB_OTG_CORE_HANDLE  *pdev, 
                                 uint8_t *report,
                                 uint16_t len)
{
 80053c8:	b510      	push	{r4, lr}
 80053ca:	4613      	mov	r3, r2
  if (pdev->dev.device_status == USB_OTG_CONFIGURED )
 80053cc:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 80053d0:	2a03      	cmp	r2, #3
  * @retval status
  */
uint8_t USBD_HID_SendReport     (USB_OTG_CORE_HANDLE  *pdev, 
                                 uint8_t *report,
                                 uint16_t len)
{
 80053d2:	460c      	mov	r4, r1
  if (pdev->dev.device_status == USB_OTG_CONFIGURED )
 80053d4:	d103      	bne.n	80053de <USBD_HID_SendReport+0x16>
  {
    DCD_EP_Tx (pdev, HID_IN_EP, report, len);
 80053d6:	2181      	movs	r1, #129	; 0x81
 80053d8:	4622      	mov	r2, r4
 80053da:	f001 f801 	bl	80063e0 <DCD_EP_Tx>
  }
  return USBD_OK;
}
 80053de:	2000      	movs	r0, #0
 80053e0:	bd10      	pop	{r4, pc}

080053e2 <USBD_Resume>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
 80053e2:	b510      	push	{r4, lr}
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 80053e4:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
 80053e8:	4604      	mov	r4, r0
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 80053ea:	691b      	ldr	r3, [r3, #16]
 80053ec:	4798      	blx	r3
  pdev->dev.device_status = pdev->dev.device_old_status;  
  pdev->dev.device_status = USB_OTG_CONFIGURED;  
 80053ee:	2303      	movs	r3, #3
 80053f0:	f884 3112 	strb.w	r3, [r4, #274]	; 0x112
  return USBD_OK;
}
 80053f4:	2000      	movs	r0, #0
 80053f6:	bd10      	pop	{r4, pc}

080053f8 <USBD_Suspend>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
 80053f8:	b508      	push	{r3, lr}
  pdev->dev.device_old_status = pdev->dev.device_status;
 80053fa:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80053fe:	f880 3113 	strb.w	r3, [r0, #275]	; 0x113
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 8005402:	2304      	movs	r3, #4
 8005404:	f880 3112 	strb.w	r3, [r0, #274]	; 0x112
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 8005408:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 800540c:	68db      	ldr	r3, [r3, #12]
 800540e:	4798      	blx	r3
  return USBD_OK;
}
 8005410:	2000      	movs	r0, #0
 8005412:	bd08      	pop	{r3, pc}

08005414 <USBD_SOF>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
{
 8005414:	b508      	push	{r3, lr}
  if(pdev->dev.class_cb->SOF)
 8005416:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
 800541a:	69db      	ldr	r3, [r3, #28]
 800541c:	b103      	cbz	r3, 8005420 <USBD_SOF+0xc>
  {
    pdev->dev.class_cb->SOF(pdev); 
 800541e:	4798      	blx	r3
  }
  return USBD_OK;
}
 8005420:	2000      	movs	r0, #0
 8005422:	bd08      	pop	{r3, pc}

08005424 <USBD_IsoINIncomplete>:
*         Handle iso in incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 8005424:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 8005426:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
 800542a:	6a1b      	ldr	r3, [r3, #32]
 800542c:	4798      	blx	r3
  return USBD_OK;
}
 800542e:	2000      	movs	r0, #0
 8005430:	bd08      	pop	{r3, pc}

08005432 <USBD_IsoOUTIncomplete>:
*         Handle iso out incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 8005432:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 8005434:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
 8005438:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800543a:	4798      	blx	r3
  return USBD_OK;
}
 800543c:	2000      	movs	r0, #0
 800543e:	bd08      	pop	{r3, pc}

08005440 <USBD_Reset>:
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 8005440:	2100      	movs	r1, #0
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 8005442:	b510      	push	{r4, lr}
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 8005444:	460b      	mov	r3, r1
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
 8005446:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  DCD_EP_Open(pdev,
 8005448:	2240      	movs	r2, #64	; 0x40
 800544a:	f000 ff75 	bl	8006338 <DCD_EP_Open>
              0x00,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Open EP0 IN */
  DCD_EP_Open(pdev,
 800544e:	2180      	movs	r1, #128	; 0x80
 8005450:	2240      	movs	r2, #64	; 0x40
 8005452:	4620      	mov	r0, r4
 8005454:	2300      	movs	r3, #0
 8005456:	f000 ff6f 	bl	8006338 <DCD_EP_Open>
              0x80,
              USB_OTG_MAX_EP0_SIZE,
              EP_TYPE_CTRL);
  
  /* Upon Reset call usr call back */
  pdev->dev.device_status = USB_OTG_DEFAULT;
 800545a:	2301      	movs	r3, #1
 800545c:	f884 3112 	strb.w	r3, [r4, #274]	; 0x112
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 8005460:	f8d4 35e8 	ldr.w	r3, [r4, #1512]	; 0x5e8
 8005464:	78a0      	ldrb	r0, [r4, #2]
 8005466:	685b      	ldr	r3, [r3, #4]
 8005468:	4798      	blx	r3
  
  return USBD_OK;
}
 800546a:	2000      	movs	r0, #0
 800546c:	bd10      	pop	{r4, pc}

0800546e <USBD_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 800546e:	b513      	push	{r0, r1, r4, lr}
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 8005470:	4669      	mov	r1, sp
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 8005472:	4604      	mov	r4, r0
  USB_SETUP_REQ req;
  
  USBD_ParseSetupRequest(pdev , &req);
 8005474:	f000 f924 	bl	80056c0 <USBD_ParseSetupRequest>
  
  switch (req.bmRequest & 0x1F) 
 8005478:	f89d 1000 	ldrb.w	r1, [sp]
 800547c:	f001 031f 	and.w	r3, r1, #31
 8005480:	2b01      	cmp	r3, #1
 8005482:	d00c      	beq.n	800549e <USBD_SetupStage+0x30>
 8005484:	d306      	bcc.n	8005494 <USBD_SetupStage+0x26>
 8005486:	2b02      	cmp	r3, #2
 8005488:	d10e      	bne.n	80054a8 <USBD_SetupStage+0x3a>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
 800548a:	4620      	mov	r0, r4
 800548c:	4669      	mov	r1, sp
 800548e:	f000 fa8b 	bl	80059a8 <USBD_StdEPReq>
    break;
 8005492:	e00e      	b.n	80054b2 <USBD_SetupStage+0x44>
  USBD_ParseSetupRequest(pdev , &req);
  
  switch (req.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &req);
 8005494:	4620      	mov	r0, r4
 8005496:	4669      	mov	r1, sp
 8005498:	f000 f942 	bl	8005720 <USBD_StdDevReq>
    break;
 800549c:	e009      	b.n	80054b2 <USBD_SetupStage+0x44>
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &req);
 800549e:	4620      	mov	r0, r4
 80054a0:	4669      	mov	r1, sp
 80054a2:	f000 fa69 	bl	8005978 <USBD_StdItfReq>
    break;
 80054a6:	e004      	b.n	80054b2 <USBD_SetupStage+0x44>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &req);   
    break;
    
  default:           
    DCD_EP_Stall(pdev , req.bmRequest & 0x80);
 80054a8:	4620      	mov	r0, r4
 80054aa:	f001 0180 	and.w	r1, r1, #128	; 0x80
 80054ae:	f000 ffb0 	bl	8006412 <DCD_EP_Stall>
    break;
  }  
  return USBD_OK;
}
 80054b2:	2000      	movs	r0, #0
 80054b4:	b002      	add	sp, #8
 80054b6:	bd10      	pop	{r4, pc}

080054b8 <USBD_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 80054b8:	b570      	push	{r4, r5, r6, lr}
 80054ba:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 80054bc:	2900      	cmp	r1, #0
 80054be:	d147      	bne.n	8005550 <USBD_DataInStage+0x98>
  {
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
 80054c0:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 80054c4:	2b02      	cmp	r3, #2
 80054c6:	d137      	bne.n	8005538 <USBD_DataInStage+0x80>
    {
      if(ep->rem_data_len > ep->maxpacket)
 80054c8:	f8d0 2138 	ldr.w	r2, [r0, #312]	; 0x138
 80054cc:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
 80054d0:	429a      	cmp	r2, r3
 80054d2:	d911      	bls.n	80054f8 <USBD_DataInStage+0x40>
      {
        ep->rem_data_len -=  ep->maxpacket;
        if(pdev->cfg.dma_enable == 1)
 80054d4:	78c1      	ldrb	r1, [r0, #3]
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 80054d6:	1ad2      	subs	r2, r2, r3
        if(pdev->cfg.dma_enable == 1)
 80054d8:	2901      	cmp	r1, #1
    ep = &pdev->dev.in_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 80054da:	f8c0 2138 	str.w	r2, [r0, #312]	; 0x138
        if(pdev->cfg.dma_enable == 1)
 80054de:	d104      	bne.n	80054ea <USBD_DataInStage+0x32>
        {
          /* in slave mode this, is handled by the TxFifoEmpty ISR */
          ep->xfer_buff += ep->maxpacket;
 80054e0:	f8d0 1128 	ldr.w	r1, [r0, #296]	; 0x128
 80054e4:	440b      	add	r3, r1
 80054e6:	f8c0 3128 	str.w	r3, [r0, #296]	; 0x128
        }
        USBD_CtlContinueSendData (pdev, 
 80054ea:	4620      	mov	r0, r4
 80054ec:	f8d4 1128 	ldr.w	r1, [r4, #296]	; 0x128
 80054f0:	b292      	uxth	r2, r2
 80054f2:	f000 f8b5 	bl	8005660 <USBD_CtlContinueSendData>
 80054f6:	e01f      	b.n	8005538 <USBD_DataInStage+0x80>
                                  ep->xfer_buff, 
                                  ep->rem_data_len);
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((ep->total_data_len % ep->maxpacket == 0) &&
 80054f8:	f8d0 513c 	ldr.w	r5, [r0, #316]	; 0x13c
 80054fc:	fbb5 f6f3 	udiv	r6, r5, r3
 8005500:	fb03 5616 	mls	r6, r3, r6, r5
 8005504:	b95e      	cbnz	r6, 800551e <USBD_DataInStage+0x66>
 8005506:	429d      	cmp	r5, r3
 8005508:	d309      	bcc.n	800551e <USBD_DataInStage+0x66>
           (ep->total_data_len >= ep->maxpacket) &&
 800550a:	f8d0 3140 	ldr.w	r3, [r0, #320]	; 0x140
 800550e:	429d      	cmp	r5, r3
 8005510:	d205      	bcs.n	800551e <USBD_DataInStage+0x66>
             (ep->total_data_len < ep->ctl_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8005512:	4632      	mov	r2, r6
 8005514:	f000 f8a4 	bl	8005660 <USBD_CtlContinueSendData>
          ep->ctl_data_len = 0;
 8005518:	f8c4 6140 	str.w	r6, [r4, #320]	; 0x140
 800551c:	e00c      	b.n	8005538 <USBD_DataInStage+0x80>
        }
        else
        {
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
 800551e:	f8d4 35e4 	ldr.w	r3, [r4, #1508]	; 0x5e4
 8005522:	68db      	ldr	r3, [r3, #12]
 8005524:	b12b      	cbz	r3, 8005532 <USBD_DataInStage+0x7a>
 8005526:	f894 2112 	ldrb.w	r2, [r4, #274]	; 0x112
 800552a:	2a03      	cmp	r2, #3
 800552c:	d101      	bne.n	8005532 <USBD_DataInStage+0x7a>
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
          {
            pdev->dev.class_cb->EP0_TxSent(pdev); 
 800552e:	4620      	mov	r0, r4
 8005530:	4798      	blx	r3
          }          
          USBD_CtlReceiveStatus(pdev);
 8005532:	4620      	mov	r0, r4
 8005534:	f000 f8b5 	bl	80056a2 <USBD_CtlReceiveStatus>
        }
      }
    }
    if (pdev->dev.test_mode == 1)
 8005538:	f894 3116 	ldrb.w	r3, [r4, #278]	; 0x116
 800553c:	2b01      	cmp	r3, #1
 800553e:	d110      	bne.n	8005562 <USBD_DataInStage+0xaa>
* @param  pdev: device instance
* @retval status
*/
static uint8_t  USBD_RunTestMode (USB_OTG_CORE_HANDLE  *pdev) 
{
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, SET_TEST_MODE.d32);
 8005540:	4a09      	ldr	r2, [pc, #36]	; (8005568 <USBD_DataInStage+0xb0>)
*         Handle data in stage
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
 8005542:	6923      	ldr	r3, [r4, #16]
* @param  pdev: device instance
* @retval status
*/
static uint8_t  USBD_RunTestMode (USB_OTG_CORE_HANDLE  *pdev) 
{
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, SET_TEST_MODE.d32);
 8005544:	6812      	ldr	r2, [r2, #0]
 8005546:	605a      	str	r2, [r3, #4]
      }
    }
    if (pdev->dev.test_mode == 1)
    {
      USBD_RunTestMode(pdev); 
      pdev->dev.test_mode = 0;
 8005548:	2300      	movs	r3, #0
 800554a:	f884 3116 	strb.w	r3, [r4, #278]	; 0x116
 800554e:	e008      	b.n	8005562 <USBD_DataInStage+0xaa>
    }
  }
  else if((pdev->dev.class_cb->DataIn != NULL)&& 
 8005550:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
 8005554:	695b      	ldr	r3, [r3, #20]
 8005556:	b123      	cbz	r3, 8005562 <USBD_DataInStage+0xaa>
 8005558:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 800555c:	2a03      	cmp	r2, #3
 800555e:	d100      	bne.n	8005562 <USBD_DataInStage+0xaa>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataIn(pdev, epnum); 
 8005560:	4798      	blx	r3
  }  
  return USBD_OK;
}
 8005562:	2000      	movs	r0, #0
 8005564:	bd70      	pop	{r4, r5, r6, pc}
 8005566:	bf00      	nop
 8005568:	20000ccc 	.word	0x20000ccc

0800556c <USBD_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 800556c:	b510      	push	{r4, lr}
 800556e:	4604      	mov	r4, r0
  USB_OTG_EP *ep;
  
  if(epnum == 0) 
 8005570:	bb59      	cbnz	r1, 80055ca <USBD_DataOutStage+0x5e>
  {
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
 8005572:	f890 3111 	ldrb.w	r3, [r0, #273]	; 0x111
 8005576:	2b03      	cmp	r3, #3
 8005578:	d130      	bne.n	80055dc <USBD_DataOutStage+0x70>
    {
      if(ep->rem_data_len > ep->maxpacket)
 800557a:	f8d0 2390 	ldr.w	r2, [r0, #912]	; 0x390
 800557e:	f8d0 337c 	ldr.w	r3, [r0, #892]	; 0x37c
 8005582:	429a      	cmp	r2, r3
 8005584:	d914      	bls.n	80055b0 <USBD_DataOutStage+0x44>
      {
        ep->rem_data_len -=  ep->maxpacket;
        
        if(pdev->cfg.dma_enable == 1)
 8005586:	78c1      	ldrb	r1, [r0, #3]
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 8005588:	1ad2      	subs	r2, r2, r3
        
        if(pdev->cfg.dma_enable == 1)
 800558a:	2901      	cmp	r1, #1
    ep = &pdev->dev.out_ep[0];
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    {
      if(ep->rem_data_len > ep->maxpacket)
      {
        ep->rem_data_len -=  ep->maxpacket;
 800558c:	f8c0 2390 	str.w	r2, [r0, #912]	; 0x390
        
        if(pdev->cfg.dma_enable == 1)
 8005590:	d104      	bne.n	800559c <USBD_DataOutStage+0x30>
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
 8005592:	f8d0 1380 	ldr.w	r1, [r0, #896]	; 0x380
 8005596:	4419      	add	r1, r3
 8005598:	f8c0 1380 	str.w	r1, [r0, #896]	; 0x380
        }        
        USBD_CtlContinueRx (pdev, 
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
 800559c:	429a      	cmp	r2, r3
 800559e:	bf28      	it	cs
 80055a0:	461a      	movcs	r2, r3
        if(pdev->cfg.dma_enable == 1)
        {
          /* in slave mode this, is handled by the RxSTSQLvl ISR */
          ep->xfer_buff += ep->maxpacket; 
        }        
        USBD_CtlContinueRx (pdev, 
 80055a2:	4620      	mov	r0, r4
 80055a4:	f8d4 1380 	ldr.w	r1, [r4, #896]	; 0x380
 80055a8:	b292      	uxth	r2, r2
 80055aa:	f000 f862 	bl	8005672 <USBD_CtlContinueRx>
 80055ae:	e015      	b.n	80055dc <USBD_DataOutStage+0x70>
                            ep->xfer_buff,
                            MIN(ep->rem_data_len ,ep->maxpacket));
      }
      else
      {
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
 80055b0:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
 80055b4:	691b      	ldr	r3, [r3, #16]
 80055b6:	b123      	cbz	r3, 80055c2 <USBD_DataOutStage+0x56>
 80055b8:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 80055bc:	2a03      	cmp	r2, #3
 80055be:	d100      	bne.n	80055c2 <USBD_DataOutStage+0x56>
           (pdev->dev.device_status == USB_OTG_CONFIGURED))
        {
          pdev->dev.class_cb->EP0_RxReady(pdev); 
 80055c0:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 80055c2:	4620      	mov	r0, r4
 80055c4:	f000 f85e 	bl	8005684 <USBD_CtlSendStatus>
 80055c8:	e008      	b.n	80055dc <USBD_DataOutStage+0x70>
      }
    }
  }
  else if((pdev->dev.class_cb->DataOut != NULL)&&
 80055ca:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
 80055ce:	699b      	ldr	r3, [r3, #24]
 80055d0:	b123      	cbz	r3, 80055dc <USBD_DataOutStage+0x70>
 80055d2:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 80055d6:	2a03      	cmp	r2, #3
 80055d8:	d100      	bne.n	80055dc <USBD_DataOutStage+0x70>
          (pdev->dev.device_status == USB_OTG_CONFIGURED))
  {
    pdev->dev.class_cb->DataOut(pdev, epnum); 
 80055da:	4798      	blx	r3
  }  
  return USBD_OK;
}
 80055dc:	2000      	movs	r0, #0
 80055de:	bd10      	pop	{r4, pc}

080055e0 <USBD_Init>:
void USBD_Init(USB_OTG_CORE_HANDLE *pdev,
               USB_OTG_CORE_ID_TypeDef coreID,
               USBD_DEVICE *pDevice,                  
               USBD_Class_cb_TypeDef *class_cb, 
               USBD_Usr_cb_TypeDef *usr_cb)
{
 80055e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80055e4:	4604      	mov	r4, r0
 80055e6:	4616      	mov	r6, r2
 80055e8:	4698      	mov	r8, r3
 80055ea:	460d      	mov	r5, r1
 80055ec:	9f06      	ldr	r7, [sp, #24]
  /* Hardware Init */
  USB_OTG_BSP_Init(pdev);  
 80055ee:	f7ff f8bf 	bl	8004770 <USB_OTG_BSP_Init>
  pdev->dev.class_cb = class_cb;
  pdev->dev.usr_cb = usr_cb;  
  pdev->dev.usr_device = pDevice;    
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 80055f2:	4620      	mov	r0, r4
 80055f4:	4629      	mov	r1, r5
  USB_OTG_BSP_Init(pdev);  
  
  USBD_DeInit(pdev);
  
  /*Register class and user callbacks */
  pdev->dev.class_cb = class_cb;
 80055f6:	f8c4 85e4 	str.w	r8, [r4, #1508]	; 0x5e4
  pdev->dev.usr_cb = usr_cb;  
 80055fa:	f8c4 75e8 	str.w	r7, [r4, #1512]	; 0x5e8
  pdev->dev.usr_device = pDevice;    
 80055fe:	f8c4 65ec 	str.w	r6, [r4, #1516]	; 0x5ec
  
  /* set USB OTG core params */
  DCD_Init(pdev , coreID);
 8005602:	f000 fe4b 	bl	800629c <DCD_Init>
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
 8005606:	f8d4 35e8 	ldr.w	r3, [r4, #1512]	; 0x5e8
 800560a:	681b      	ldr	r3, [r3, #0]
 800560c:	4798      	blx	r3
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 800560e:	4620      	mov	r0, r4
}
 8005610:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  
  /* Upon Init call usr callback */
  pdev->dev.usr_cb->Init();
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 8005614:	f7ff b904 	b.w	8004820 <USB_OTG_BSP_EnableInterrupt>

08005618 <USBD_SetCfg>:
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 8005618:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
* @param  cfgidx: configuration index
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 800561c:	b510      	push	{r4, lr}
 800561e:	4604      	mov	r4, r0
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 8005620:	681b      	ldr	r3, [r3, #0]
 8005622:	4798      	blx	r3
  
  /* Upon set config call usr call back */
  pdev->dev.usr_cb->DeviceConfigured();
 8005624:	f8d4 35e8 	ldr.w	r3, [r4, #1512]	; 0x5e8
 8005628:	689b      	ldr	r3, [r3, #8]
 800562a:	4798      	blx	r3
  return USBD_OK; 
}
 800562c:	2000      	movs	r0, #0
 800562e:	bd10      	pop	{r4, pc}

08005630 <USBD_ClrCfg>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 8005630:	b508      	push	{r3, lr}
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 8005632:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
 8005636:	685b      	ldr	r3, [r3, #4]
 8005638:	4798      	blx	r3
  return USBD_OK;
}
 800563a:	2000      	movs	r0, #0
 800563c:	bd08      	pop	{r3, pc}

0800563e <USBD_CtlSendData>:
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 800563e:	b538      	push	{r3, r4, r5, lr}
 8005640:	4604      	mov	r4, r0
 8005642:	460d      	mov	r5, r1
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
 8005644:	f8c4 213c 	str.w	r2, [r4, #316]	; 0x13c
  pdev->dev.in_ep[0].rem_data_len   = len;
 8005648:	f8c4 2138 	str.w	r2, [r4, #312]	; 0x138
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 800564c:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
  pdev->dev.in_ep[0].rem_data_len   = len;
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 800564e:	2202      	movs	r2, #2
 8005650:	f880 2111 	strb.w	r2, [r0, #273]	; 0x111

  DCD_EP_Tx (pdev, 0, pbuf, len);
 8005654:	2100      	movs	r1, #0
 8005656:	462a      	mov	r2, r5
 8005658:	f000 fec2 	bl	80063e0 <DCD_EP_Tx>
 
  return ret;
}
 800565c:	2000      	movs	r0, #0
 800565e:	bd38      	pop	{r3, r4, r5, pc}

08005660 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_Status  USBD_CtlContinueSendData (USB_OTG_CORE_HANDLE  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8005660:	b510      	push	{r4, lr}
 8005662:	460c      	mov	r4, r1
 8005664:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_Tx (pdev, 0, pbuf, len);
 8005666:	2100      	movs	r1, #0
 8005668:	4622      	mov	r2, r4
 800566a:	f000 feb9 	bl	80063e0 <DCD_EP_Tx>
  
  
  return ret;
}
 800566e:	2000      	movs	r0, #0
 8005670:	bd10      	pop	{r4, pc}

08005672 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_Status  USBD_CtlContinueRx (USB_OTG_CORE_HANDLE  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8005672:	b510      	push	{r4, lr}
 8005674:	460c      	mov	r4, r1
 8005676:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_PrepareRx (pdev,
 8005678:	2100      	movs	r1, #0
 800567a:	4622      	mov	r2, r4
 800567c:	f000 fe95 	bl	80063aa <DCD_EP_PrepareRx>
                    0,                     
                    pbuf,                         
                    len);
  return ret;
}
 8005680:	2000      	movs	r0, #0
 8005682:	bd10      	pop	{r4, pc}

08005684 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 8005684:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 8005686:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 8005688:	2304      	movs	r3, #4
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 800568a:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
  DCD_EP_Tx (pdev,
 800568c:	460a      	mov	r2, r1
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 800568e:	f880 3111 	strb.w	r3, [r0, #273]	; 0x111
  DCD_EP_Tx (pdev,
 8005692:	460b      	mov	r3, r1
 8005694:	f000 fea4 	bl	80063e0 <DCD_EP_Tx>
             0,
             NULL, 
             0); 
  
  USB_OTG_EP0_OutStart(pdev);  
 8005698:	4620      	mov	r0, r4
 800569a:	f000 fdac 	bl	80061f6 <USB_OTG_EP0_OutStart>
  
  return ret;
}
 800569e:	2000      	movs	r0, #0
 80056a0:	bd10      	pop	{r4, pc}

080056a2 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 80056a2:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 80056a4:	2100      	movs	r1, #0
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 80056a6:	2305      	movs	r3, #5
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 80056a8:	4604      	mov	r4, r0
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
  DCD_EP_PrepareRx ( pdev,
 80056aa:	460a      	mov	r2, r1
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 80056ac:	f880 3111 	strb.w	r3, [r0, #273]	; 0x111
  DCD_EP_PrepareRx ( pdev,
 80056b0:	460b      	mov	r3, r1
 80056b2:	f000 fe7a 	bl	80063aa <DCD_EP_PrepareRx>
                    0,
                    NULL,
                    0);  

  USB_OTG_EP0_OutStart(pdev);
 80056b6:	4620      	mov	r0, r4
 80056b8:	f000 fd9d 	bl	80061f6 <USB_OTG_EP0_OutStart>
  
  return ret;
}
 80056bc:	2000      	movs	r0, #0
 80056be:	bd10      	pop	{r4, pc}

080056c0 <USBD_ParseSetupRequest>:
*/

void USBD_ParseSetupRequest( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
 80056c0:	f890 35cc 	ldrb.w	r3, [r0, #1484]	; 0x5cc
 80056c4:	700b      	strb	r3, [r1, #0]
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
 80056c6:	f890 35cd 	ldrb.w	r3, [r0, #1485]	; 0x5cd
 80056ca:	704b      	strb	r3, [r1, #1]
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
 80056cc:	f890 25cf 	ldrb.w	r2, [r0, #1487]	; 0x5cf
 80056d0:	f890 35ce 	ldrb.w	r3, [r0, #1486]	; 0x5ce
 80056d4:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80056d8:	804b      	strh	r3, [r1, #2]
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
 80056da:	f890 25d1 	ldrb.w	r2, [r0, #1489]	; 0x5d1
 80056de:	f890 35d0 	ldrb.w	r3, [r0, #1488]	; 0x5d0
 80056e2:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80056e6:	808b      	strh	r3, [r1, #4]
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 80056e8:	f890 25d3 	ldrb.w	r2, [r0, #1491]	; 0x5d3
 80056ec:	f890 35d2 	ldrb.w	r3, [r0, #1490]	; 0x5d2
 80056f0:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80056f4:	b29b      	uxth	r3, r3
 80056f6:	80cb      	strh	r3, [r1, #6]
  
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
 80056f8:	f8c0 3140 	str.w	r3, [r0, #320]	; 0x140
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 80056fc:	2301      	movs	r3, #1
 80056fe:	f880 3111 	strb.w	r3, [r0, #273]	; 0x111
 8005702:	4770      	bx	lr

08005704 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 8005704:	b510      	push	{r4, lr}
  
  DCD_EP_Stall(pdev , 0x80);
 8005706:	2180      	movs	r1, #128	; 0x80
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
                            USB_SETUP_REQ *req)
{
 8005708:	4604      	mov	r4, r0
  
  DCD_EP_Stall(pdev , 0x80);
 800570a:	f000 fe82 	bl	8006412 <DCD_EP_Stall>
  DCD_EP_Stall(pdev , 0);
 800570e:	4620      	mov	r0, r4
 8005710:	2100      	movs	r1, #0
 8005712:	f000 fe7e 	bl	8006412 <DCD_EP_Stall>
  USB_OTG_EP0_OutStart(pdev);  
 8005716:	4620      	mov	r0, r4
}
 8005718:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                            USB_SETUP_REQ *req)
{
  
  DCD_EP_Stall(pdev , 0x80);
  DCD_EP_Stall(pdev , 0);
  USB_OTG_EP0_OutStart(pdev);  
 800571c:	f000 bd6b 	b.w	80061f6 <USB_OTG_EP0_OutStart>

08005720 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8005720:	b573      	push	{r0, r1, r4, r5, r6, lr}
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 8005722:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdDevReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8005724:	4604      	mov	r4, r0
 8005726:	460d      	mov	r5, r1
  USBD_Status ret = USBD_OK;  
  
  switch (req->bRequest) 
 8005728:	2b09      	cmp	r3, #9
 800572a:	f200 8116 	bhi.w	800595a <USBD_StdDevReq+0x23a>
 800572e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005732:	00c7      	.short	0x00c7
 8005734:	01140102 	.word	0x01140102
 8005738:	011400da 	.word	0x011400da
 800573c:	000a006e 	.word	0x000a006e
 8005740:	00b90114 	.word	0x00b90114
 8005744:	008d      	.short	0x008d
{
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
 8005746:	886b      	ldrh	r3, [r5, #2]
 8005748:	0a1a      	lsrs	r2, r3, #8
 800574a:	3a01      	subs	r2, #1
 800574c:	2a06      	cmp	r2, #6
 800574e:	f200 8104 	bhi.w	800595a <USBD_StdDevReq+0x23a>
 8005752:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005756:	0007      	.short	0x0007
 8005758:	0027001a 	.word	0x0027001a
 800575c:	01020102 	.word	0x01020102
 8005760:	01020102 	.word	0x01020102
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 8005764:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 8005768:	7880      	ldrb	r0, [r0, #2]
 800576a:	681b      	ldr	r3, [r3, #0]
 800576c:	f10d 0106 	add.w	r1, sp, #6
 8005770:	4798      	blx	r3
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 8005772:	88eb      	ldrh	r3, [r5, #6]
 8005774:	2b40      	cmp	r3, #64	; 0x40
  
    
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 8005776:	4601      	mov	r1, r0
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 8005778:	d003      	beq.n	8005782 <USBD_StdDevReq+0x62>
 800577a:	f894 3112 	ldrb.w	r3, [r4, #274]	; 0x112
 800577e:	2b01      	cmp	r3, #1
 8005780:	d135      	bne.n	80057ee <USBD_StdDevReq+0xce>
    {                  
      len = 8;
 8005782:	2308      	movs	r3, #8
 8005784:	f8ad 3006 	strh.w	r3, [sp, #6]
 8005788:	e031      	b.n	80057ee <USBD_StdDevReq+0xce>
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 800578a:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
 800578e:	7880      	ldrb	r0, [r0, #2]
 8005790:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005792:	f10d 0106 	add.w	r1, sp, #6
 8005796:	4798      	blx	r3
       (pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY))
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8005798:	2302      	movs	r3, #2
 800579a:	7043      	strb	r3, [r0, #1]
      len = 8;
    }
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 800579c:	4601      	mov	r1, r0
    {
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetOtherConfigDescriptor(pdev->cfg.speed, &len);
    }
#endif  
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    pdev->dev.pConfig_descriptor = pbuf;    
 800579e:	f8c4 05f0 	str.w	r0, [r4, #1520]	; 0x5f0
 80057a2:	e024      	b.n	80057ee <USBD_StdDevReq+0xce>
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 80057a4:	b2db      	uxtb	r3, r3
 80057a6:	2b05      	cmp	r3, #5
 80057a8:	f200 80d7 	bhi.w	800595a <USBD_StdDevReq+0x23a>
 80057ac:	e8df f003 	tbb	[pc, r3]
 80057b0:	0f0b0703 	.word	0x0f0b0703
 80057b4:	1713      	.short	0x1713
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
 80057b6:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 80057ba:	685b      	ldr	r3, [r3, #4]
 80057bc:	e012      	b.n	80057e4 <USBD_StdDevReq+0xc4>
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
 80057be:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 80057c2:	689b      	ldr	r3, [r3, #8]
 80057c4:	e00e      	b.n	80057e4 <USBD_StdDevReq+0xc4>
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
 80057c6:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 80057ca:	68db      	ldr	r3, [r3, #12]
 80057cc:	e00a      	b.n	80057e4 <USBD_StdDevReq+0xc4>
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
 80057ce:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 80057d2:	691b      	ldr	r3, [r3, #16]
 80057d4:	e006      	b.n	80057e4 <USBD_StdDevReq+0xc4>
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
 80057d6:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 80057da:	695b      	ldr	r3, [r3, #20]
 80057dc:	e002      	b.n	80057e4 <USBD_StdDevReq+0xc4>
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
 80057de:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	; 0x5ec
 80057e2:	699b      	ldr	r3, [r3, #24]
 80057e4:	f10d 0106 	add.w	r1, sp, #6
 80057e8:	78a0      	ldrb	r0, [r4, #2]
 80057ea:	4798      	blx	r3
 80057ec:	4601      	mov	r1, r0
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 80057ee:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80057f2:	2b00      	cmp	r3, #0
 80057f4:	f000 80b5 	beq.w	8005962 <USBD_StdDevReq+0x242>
 80057f8:	88ea      	ldrh	r2, [r5, #6]
 80057fa:	2a00      	cmp	r2, #0
 80057fc:	f000 80b1 	beq.w	8005962 <USBD_StdDevReq+0x242>
  {
    
    len = MIN(len , req->wLength);
 8005800:	429a      	cmp	r2, r3
 8005802:	bf28      	it	cs
 8005804:	461a      	movcs	r2, r3
 8005806:	f8ad 2006 	strh.w	r2, [sp, #6]
    
    USBD_CtlSendData (pdev, 
 800580a:	4620      	mov	r0, r4
 800580c:	e068      	b.n	80058e0 <USBD_StdDevReq+0x1c0>
static void USBD_SetAddress(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 800580e:	88ab      	ldrh	r3, [r5, #4]
 8005810:	2b00      	cmp	r3, #0
 8005812:	f040 80a2 	bne.w	800595a <USBD_StdDevReq+0x23a>
 8005816:	88eb      	ldrh	r3, [r5, #6]
 8005818:	2b00      	cmp	r3, #0
 800581a:	f040 809e 	bne.w	800595a <USBD_StdDevReq+0x23a>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 800581e:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8005822:	78ae      	ldrb	r6, [r5, #2]
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 8005824:	2b03      	cmp	r3, #3
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8005826:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 800582a:	f000 8096 	beq.w	800595a <USBD_StdDevReq+0x23a>
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev.device_address = dev_addr;
 800582e:	f880 6114 	strb.w	r6, [r0, #276]	; 0x114
      DCD_EP_SetAddress(pdev, dev_addr);               
 8005832:	4631      	mov	r1, r6
 8005834:	f000 fe2d 	bl	8006492 <DCD_EP_SetAddress>
      USBD_CtlSendStatus(pdev);                         
 8005838:	4620      	mov	r0, r4
 800583a:	f7ff ff23 	bl	8005684 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 800583e:	b10e      	cbz	r6, 8005844 <USBD_StdDevReq+0x124>
      {
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
 8005840:	2302      	movs	r3, #2
 8005842:	e000      	b.n	8005846 <USBD_StdDevReq+0x126>
      } 
      else 
      {
        pdev->dev.device_status  = USB_OTG_DEFAULT; 
 8005844:	2301      	movs	r3, #1
 8005846:	f884 3112 	strb.w	r3, [r4, #274]	; 0x112
 800584a:	e08a      	b.n	8005962 <USBD_StdDevReq+0x242>
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 800584c:	78a9      	ldrb	r1, [r5, #2]
 800584e:	4e46      	ldr	r6, [pc, #280]	; (8005968 <USBD_StdDevReq+0x248>)
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 8005850:	2901      	cmp	r1, #1
                           USB_SETUP_REQ *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8005852:	7031      	strb	r1, [r6, #0]
  
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 8005854:	f200 8081 	bhi.w	800595a <USBD_StdDevReq+0x23a>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev.device_status) 
 8005858:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800585c:	2b02      	cmp	r3, #2
 800585e:	d002      	beq.n	8005866 <USBD_StdDevReq+0x146>
 8005860:	2b03      	cmp	r3, #3
 8005862:	d009      	beq.n	8005878 <USBD_StdDevReq+0x158>
 8005864:	e079      	b.n	800595a <USBD_StdDevReq+0x23a>
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
 8005866:	2900      	cmp	r1, #0
 8005868:	d061      	beq.n	800592e <USBD_StdDevReq+0x20e>
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 800586a:	2101      	movs	r1, #1
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 800586c:	2303      	movs	r3, #3
    switch (pdev->dev.device_status) 
    {
    case USB_OTG_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev.device_config = cfgidx;
 800586e:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 8005872:	f880 3112 	strb.w	r3, [r0, #274]	; 0x112
 8005876:	e011      	b.n	800589c <USBD_StdDevReq+0x17c>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USB_OTG_CONFIGURED:
      if (cfgidx == 0) 
 8005878:	b939      	cbnz	r1, 800588a <USBD_StdDevReq+0x16a>
      {                           
        pdev->dev.device_status = USB_OTG_ADDRESSED;
 800587a:	2302      	movs	r3, #2
 800587c:	f880 3112 	strb.w	r3, [r0, #274]	; 0x112
        pdev->dev.device_config = cfgidx;          
 8005880:	f880 1110 	strb.w	r1, [r0, #272]	; 0x110
        USBD_ClrCfg(pdev , cfgidx);
 8005884:	f7ff fed4 	bl	8005630 <USBD_ClrCfg>
 8005888:	e051      	b.n	800592e <USBD_StdDevReq+0x20e>
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev.device_config) 
 800588a:	f890 1110 	ldrb.w	r1, [r0, #272]	; 0x110
 800588e:	2901      	cmp	r1, #1
 8005890:	d04d      	beq.n	800592e <USBD_StdDevReq+0x20e>
      {
        /* Clear old configuration */
        USBD_ClrCfg(pdev , pdev->dev.device_config);
 8005892:	f7ff fecd 	bl	8005630 <USBD_ClrCfg>
        
        /* set new configuration */
        pdev->dev.device_config = cfgidx;
 8005896:	7831      	ldrb	r1, [r6, #0]
 8005898:	f884 1110 	strb.w	r1, [r4, #272]	; 0x110
        USBD_SetCfg(pdev , cfgidx);
 800589c:	4620      	mov	r0, r4
 800589e:	f7ff febb 	bl	8005618 <USBD_SetCfg>
 80058a2:	e044      	b.n	800592e <USBD_StdDevReq+0x20e>
*/
static void USBD_GetConfig(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
 
  if (req->wLength != 1) 
 80058a4:	88ea      	ldrh	r2, [r5, #6]
 80058a6:	2a01      	cmp	r2, #1
 80058a8:	d157      	bne.n	800595a <USBD_StdDevReq+0x23a>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev.device_status )  
 80058aa:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80058ae:	2b02      	cmp	r3, #2
 80058b0:	d004      	beq.n	80058bc <USBD_StdDevReq+0x19c>
 80058b2:	2b03      	cmp	r3, #3
 80058b4:	d151      	bne.n	800595a <USBD_StdDevReq+0x23a>
                        1);
      break;
      
    case USB_OTG_CONFIGURED:                   
      
      USBD_CtlSendData (pdev, 
 80058b6:	f500 7188 	add.w	r1, r0, #272	; 0x110
 80058ba:	e011      	b.n	80058e0 <USBD_StdDevReq+0x1c0>
  {
    switch (pdev->dev.device_status )  
    {
    case USB_OTG_ADDRESSED:                     
      
      USBD_CtlSendData (pdev, 
 80058bc:	492b      	ldr	r1, [pc, #172]	; (800596c <USBD_StdDevReq+0x24c>)
 80058be:	e00f      	b.n	80058e0 <USBD_StdDevReq+0x1c0>
static void USBD_GetStatus(USB_OTG_CORE_HANDLE  *pdev, 
                           USB_SETUP_REQ *req)
{
  
    
  switch (pdev->dev.device_status) 
 80058c0:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 80058c4:	3b02      	subs	r3, #2
 80058c6:	2b01      	cmp	r3, #1
 80058c8:	d847      	bhi.n	800595a <USBD_StdDevReq+0x23a>
  case USB_OTG_CONFIGURED:
    
#ifdef USBD_SELF_POWERED
    USBD_cfg_status = USB_CONFIG_SELF_POWERED;                                    
#else
    USBD_cfg_status = 0x00;                                    
 80058ca:	4b29      	ldr	r3, [pc, #164]	; (8005970 <USBD_StdDevReq+0x250>)
 80058cc:	2200      	movs	r2, #0
 80058ce:	601a      	str	r2, [r3, #0]
#endif
                      
    if (pdev->dev.DevRemoteWakeup) 
 80058d0:	f8d0 2118 	ldr.w	r2, [r0, #280]	; 0x118
 80058d4:	b10a      	cbz	r2, 80058da <USBD_StdDevReq+0x1ba>
    {
      USBD_cfg_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 80058d6:	2202      	movs	r2, #2
 80058d8:	601a      	str	r2, [r3, #0]
    }
    
    USBD_CtlSendData (pdev, 
 80058da:	4925      	ldr	r1, [pc, #148]	; (8005970 <USBD_StdDevReq+0x250>)
 80058dc:	4620      	mov	r0, r4
 80058de:	2202      	movs	r2, #2
 80058e0:	f7ff fead 	bl	800563e <USBD_CtlSendData>
 80058e4:	e03d      	b.n	8005962 <USBD_StdDevReq+0x242>
{

  USB_OTG_DCTL_TypeDef     dctl;
  uint8_t test_mode = 0;
 
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80058e6:	886b      	ldrh	r3, [r5, #2]
 80058e8:	2b01      	cmp	r3, #1
 80058ea:	d02d      	beq.n	8005948 <USBD_StdDevReq+0x228>
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 80058ec:	2b02      	cmp	r3, #2
 80058ee:	d138      	bne.n	8005962 <USBD_StdDevReq+0x242>
           ((req->wIndex & 0xFF) == 0))
 80058f0:	88aa      	ldrh	r2, [r5, #4]
    pdev->dev.DevRemoteWakeup = 1;  
    pdev->dev.class_cb->Setup (pdev, req);   
    USBD_CtlSendStatus(pdev);
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 80058f2:	f012 0fff 	tst.w	r2, #255	; 0xff
 80058f6:	d134      	bne.n	8005962 <USBD_StdDevReq+0x242>
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 80058f8:	6903      	ldr	r3, [r0, #16]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 80058fa:	0a12      	lsrs	r2, r2, #8
 80058fc:	3a01      	subs	r2, #1
  }

  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
           ((req->wIndex & 0xFF) == 0))
  {
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 80058fe:	685b      	ldr	r3, [r3, #4]
    
    test_mode = req->wIndex >> 8;
    switch (test_mode) 
 8005900:	2a04      	cmp	r2, #4
 8005902:	d80f      	bhi.n	8005924 <USBD_StdDevReq+0x204>
 8005904:	e8df f002 	tbb	[pc, r2]
 8005908:	09070503 	.word	0x09070503
 800590c:	0b          	.byte	0x0b
 800590d:	00          	.byte	0x00
    {
    case 1: // TEST_J
      dctl.b.tstctl = 1;
 800590e:	2201      	movs	r2, #1
 8005910:	e006      	b.n	8005920 <USBD_StdDevReq+0x200>
      break;
      
    case 2: // TEST_K	
      dctl.b.tstctl = 2;
 8005912:	2202      	movs	r2, #2
 8005914:	e004      	b.n	8005920 <USBD_StdDevReq+0x200>
      break;
      
    case 3: // TEST_SE0_NAK
      dctl.b.tstctl = 3;
 8005916:	2203      	movs	r2, #3
 8005918:	e002      	b.n	8005920 <USBD_StdDevReq+0x200>
      break;
      
    case 4: // TEST_PACKET
      dctl.b.tstctl = 4;
 800591a:	2204      	movs	r2, #4
 800591c:	e000      	b.n	8005920 <USBD_StdDevReq+0x200>
      break;
      
    case 5: // TEST_FORCE_ENABLE
      dctl.b.tstctl = 5;
 800591e:	2205      	movs	r2, #5
 8005920:	f362 1306 	bfi	r3, r2, #4, #3
      break;
    }
    SET_TEST_MODE = dctl;
 8005924:	4a13      	ldr	r2, [pc, #76]	; (8005974 <USBD_StdDevReq+0x254>)
 8005926:	6013      	str	r3, [r2, #0]
    pdev->dev.test_mode = 1;
 8005928:	2301      	movs	r3, #1
 800592a:	f884 3116 	strb.w	r3, [r4, #278]	; 0x116
    USBD_CtlSendStatus(pdev);
 800592e:	4620      	mov	r0, r4
 8005930:	f7ff fea8 	bl	8005684 <USBD_CtlSendStatus>
 8005934:	e015      	b.n	8005962 <USBD_StdDevReq+0x242>
* @retval status
*/
static void USBD_ClrFeature(USB_OTG_CORE_HANDLE  *pdev, 
                            USB_SETUP_REQ *req)
{
  switch (pdev->dev.device_status)
 8005936:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800593a:	3b02      	subs	r3, #2
 800593c:	2b01      	cmp	r3, #1
 800593e:	d80c      	bhi.n	800595a <USBD_StdDevReq+0x23a>
  {
  case USB_OTG_ADDRESSED:
  case USB_OTG_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8005940:	886b      	ldrh	r3, [r5, #2]
 8005942:	2b01      	cmp	r3, #1
 8005944:	d10d      	bne.n	8005962 <USBD_StdDevReq+0x242>
    {
      pdev->dev.DevRemoteWakeup = 0; 
 8005946:	2300      	movs	r3, #0
 8005948:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
      pdev->dev.class_cb->Setup (pdev, req);   
 800594c:	f8d4 35e4 	ldr.w	r3, [r4, #1508]	; 0x5e4
 8005950:	4620      	mov	r0, r4
 8005952:	689b      	ldr	r3, [r3, #8]
 8005954:	4629      	mov	r1, r5
 8005956:	4798      	blx	r3
 8005958:	e7e9      	b.n	800592e <USBD_StdDevReq+0x20e>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
 800595a:	4620      	mov	r0, r4
 800595c:	4629      	mov	r1, r5
 800595e:	f7ff fed1 	bl	8005704 <USBD_CtlError>
    break;
  }
  
  return ret;
}
 8005962:	2000      	movs	r0, #0
 8005964:	b002      	add	sp, #8
 8005966:	bd70      	pop	{r4, r5, r6, pc}
 8005968:	200005ec 	.word	0x200005ec
 800596c:	200005e8 	.word	0x200005e8
 8005970:	200005e0 	.word	0x200005e0
 8005974:	20000ccc 	.word	0x20000ccc

08005978 <USBD_StdItfReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8005978:	b538      	push	{r3, r4, r5, lr}
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 800597a:	f890 3112 	ldrb.w	r3, [r0, #274]	; 0x112
 800597e:	2b03      	cmp	r3, #3
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdItfReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 8005980:	4604      	mov	r4, r0
 8005982:	460d      	mov	r5, r1
  USBD_Status ret = USBD_OK; 
  
  switch (pdev->dev.device_status) 
 8005984:	d10c      	bne.n	80059a0 <USBD_StdItfReq+0x28>
  {
  case USB_OTG_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_ITF_MAX_NUM) 
 8005986:	790b      	ldrb	r3, [r1, #4]
 8005988:	2b01      	cmp	r3, #1
 800598a:	d809      	bhi.n	80059a0 <USBD_StdItfReq+0x28>
    {
      pdev->dev.class_cb->Setup (pdev, req); 
 800598c:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	; 0x5e4
 8005990:	689b      	ldr	r3, [r3, #8]
 8005992:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 8005994:	88eb      	ldrh	r3, [r5, #6]
 8005996:	b92b      	cbnz	r3, 80059a4 <USBD_StdItfReq+0x2c>
      {
         USBD_CtlSendStatus(pdev);
 8005998:	4620      	mov	r0, r4
 800599a:	f7ff fe73 	bl	8005684 <USBD_CtlSendStatus>
 800599e:	e001      	b.n	80059a4 <USBD_StdItfReq+0x2c>
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
 80059a0:	f7ff feb0 	bl	8005704 <USBD_CtlError>
    break;
  }
  return ret;
}
 80059a4:	2000      	movs	r0, #0
 80059a6:	bd38      	pop	{r3, r4, r5, pc}

080059a8 <USBD_StdEPReq>:
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 80059a8:	b570      	push	{r4, r5, r6, lr}
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
 80059aa:	784e      	ldrb	r6, [r1, #1]
{
  
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
 80059ac:	888a      	ldrh	r2, [r1, #4]
  
  switch (req->bRequest) 
 80059ae:	2e01      	cmp	r6, #1
* @param  pdev: USB OTG device instance
* @param  req: usb request
* @retval status
*/
USBD_Status  USBD_StdEPReq (USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 80059b0:	4604      	mov	r4, r0
 80059b2:	460d      	mov	r5, r1
  
  uint8_t   ep_addr;
  USBD_Status ret = USBD_OK; 
  
  ep_addr  = LOBYTE(req->wIndex);   
 80059b4:	b2d3      	uxtb	r3, r2
  
  switch (req->bRequest) 
 80059b6:	d010      	beq.n	80059da <USBD_StdEPReq+0x32>
 80059b8:	d327      	bcc.n	8005a0a <USBD_StdEPReq+0x62>
 80059ba:	2e03      	cmp	r6, #3
 80059bc:	d150      	bne.n	8005a60 <USBD_StdEPReq+0xb8>
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev.device_status) 
 80059be:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 80059c2:	2a02      	cmp	r2, #2
 80059c4:	d028      	beq.n	8005a18 <USBD_StdEPReq+0x70>
 80059c6:	2a03      	cmp	r2, #3
 80059c8:	d148      	bne.n	8005a5c <USBD_StdEPReq+0xb4>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 80059ca:	884a      	ldrh	r2, [r1, #2]
 80059cc:	b99a      	cbnz	r2, 80059f6 <USBD_StdEPReq+0x4e>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80059ce:	065e      	lsls	r6, r3, #25
 80059d0:	d011      	beq.n	80059f6 <USBD_StdEPReq+0x4e>
        { 
          DCD_EP_Stall(pdev , ep_addr);
 80059d2:	4619      	mov	r1, r3
 80059d4:	f000 fd1d 	bl	8006412 <DCD_EP_Stall>
 80059d8:	e00d      	b.n	80059f6 <USBD_StdEPReq+0x4e>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev.device_status) 
 80059da:	f890 2112 	ldrb.w	r2, [r0, #274]	; 0x112
 80059de:	2a02      	cmp	r2, #2
 80059e0:	d01a      	beq.n	8005a18 <USBD_StdEPReq+0x70>
 80059e2:	2a03      	cmp	r2, #3
 80059e4:	d13a      	bne.n	8005a5c <USBD_StdEPReq+0xb4>
        DCD_EP_Stall(pdev , ep_addr);
      }
      break;	
      
    case USB_OTG_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 80059e6:	884a      	ldrh	r2, [r1, #2]
 80059e8:	2a00      	cmp	r2, #0
 80059ea:	d139      	bne.n	8005a60 <USBD_StdEPReq+0xb8>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80059ec:	0659      	lsls	r1, r3, #25
 80059ee:	d008      	beq.n	8005a02 <USBD_StdEPReq+0x5a>
        {        
          DCD_EP_ClrStall(pdev , ep_addr);
 80059f0:	4619      	mov	r1, r3
 80059f2:	f000 fd28 	bl	8006446 <DCD_EP_ClrStall>
          pdev->dev.class_cb->Setup (pdev, req);
 80059f6:	f8d4 35e4 	ldr.w	r3, [r4, #1508]	; 0x5e4
 80059fa:	4620      	mov	r0, r4
 80059fc:	689b      	ldr	r3, [r3, #8]
 80059fe:	4629      	mov	r1, r5
 8005a00:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 8005a02:	4620      	mov	r0, r4
 8005a04:	f7ff fe3e 	bl	8005684 <USBD_CtlSendStatus>
 8005a08:	e02a      	b.n	8005a60 <USBD_StdEPReq+0xb8>
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev.device_status) 
 8005a0a:	f890 5112 	ldrb.w	r5, [r0, #274]	; 0x112
 8005a0e:	2d02      	cmp	r5, #2
 8005a10:	d002      	beq.n	8005a18 <USBD_StdEPReq+0x70>
 8005a12:	2d03      	cmp	r5, #3
 8005a14:	d006      	beq.n	8005a24 <USBD_StdEPReq+0x7c>
 8005a16:	e021      	b.n	8005a5c <USBD_StdEPReq+0xb4>
    {
    case USB_OTG_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8005a18:	065a      	lsls	r2, r3, #25
 8005a1a:	d021      	beq.n	8005a60 <USBD_StdEPReq+0xb8>
      {
        DCD_EP_Stall(pdev , ep_addr);
 8005a1c:	4619      	mov	r1, r3
 8005a1e:	f000 fcf8 	bl	8006412 <DCD_EP_Stall>
 8005a22:	e01d      	b.n	8005a60 <USBD_StdEPReq+0xb8>
      break;	
      
    case USB_OTG_CONFIGURED:         
      
      
      if ((ep_addr & 0x80)== 0x80)
 8005a24:	f012 0f80 	tst.w	r2, #128	; 0x80
 8005a28:	f04f 0128 	mov.w	r1, #40	; 0x28
 8005a2c:	4a0d      	ldr	r2, [pc, #52]	; (8005a64 <USBD_StdEPReq+0xbc>)
 8005a2e:	d010      	beq.n	8005a52 <USBD_StdEPReq+0xaa>
      {
        if(pdev->dev.in_ep[ep_addr & 0x7F].is_stall)
 8005a30:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8005a34:	fb01 0103 	mla	r1, r1, r3, r0
 8005a38:	f891 311e 	ldrb.w	r3, [r1, #286]	; 0x11e
 8005a3c:	b10b      	cbz	r3, 8005a42 <USBD_StdEPReq+0x9a>
        {
          USBD_ep_status = 0x0001;     
 8005a3e:	2301      	movs	r3, #1
 8005a40:	e000      	b.n	8005a44 <USBD_StdEPReq+0x9c>
        }
        else
        {
          USBD_ep_status = 0x0000;  
 8005a42:	2300      	movs	r3, #0
 8005a44:	6013      	str	r3, [r2, #0]
        else 
        {
          USBD_ep_status = 0x0000;     
        }      
      }
      USBD_CtlSendData (pdev,
 8005a46:	4620      	mov	r0, r4
 8005a48:	4906      	ldr	r1, [pc, #24]	; (8005a64 <USBD_StdEPReq+0xbc>)
 8005a4a:	2202      	movs	r2, #2
 8005a4c:	f7ff fdf7 	bl	800563e <USBD_CtlSendData>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
 8005a50:	e006      	b.n	8005a60 <USBD_StdEPReq+0xb8>
          USBD_ep_status = 0x0000;  
        }
      }
      else if ((ep_addr & 0x80)== 0x00)
      {
        if(pdev->dev.out_ep[ep_addr].is_stall)
 8005a52:	fb01 0303 	mla	r3, r1, r3, r0
 8005a56:	f893 3376 	ldrb.w	r3, [r3, #886]	; 0x376
 8005a5a:	e7ef      	b.n	8005a3c <USBD_StdEPReq+0x94>
                        (uint8_t *)&USBD_ep_status,
                        2);
      break;
      
    default:                         
       USBD_CtlError(pdev , req);
 8005a5c:	f7ff fe52 	bl	8005704 <USBD_CtlError>
    
  default:
    break;
  }
  return ret;
}
 8005a60:	2000      	movs	r0, #0
 8005a62:	bd70      	pop	{r4, r5, r6, pc}
 8005a64:	200005e4 	.word	0x200005e4

08005a68 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8005a68:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8005a6a:	b1d0      	cbz	r0, 8005aa2 <USBD_GetString+0x3a>
 8005a6c:	2300      	movs	r3, #0
 8005a6e:	b2dc      	uxtb	r4, r3
 8005a70:	3301      	adds	r3, #1
 8005a72:	18c5      	adds	r5, r0, r3
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 8005a74:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 8005a78:	2d00      	cmp	r5, #0
 8005a7a:	d1f8      	bne.n	8005a6e <USBD_GetString+0x6>
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8005a7c:	1c63      	adds	r3, r4, #1
 8005a7e:	005b      	lsls	r3, r3, #1
 8005a80:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 8005a82:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8005a84:	2303      	movs	r3, #3
 8005a86:	704b      	strb	r3, [r1, #1]
 8005a88:	3801      	subs	r0, #1
 8005a8a:	2302      	movs	r3, #2
    
    while (*desc != NULL) 
 8005a8c:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 8005a90:	b13a      	cbz	r2, 8005aa2 <USBD_GetString+0x3a>
    {
      unicode[idx++] = *desc++;
 8005a92:	1c5c      	adds	r4, r3, #1
 8005a94:	b2e4      	uxtb	r4, r4
 8005a96:	54ca      	strb	r2, [r1, r3]
      unicode[idx++] =  0x00;
 8005a98:	3302      	adds	r3, #2
 8005a9a:	2200      	movs	r2, #0
 8005a9c:	b2db      	uxtb	r3, r3
 8005a9e:	550a      	strb	r2, [r1, r4]
 8005aa0:	e7f4      	b.n	8005a8c <USBD_GetString+0x24>
 8005aa2:	bd30      	pop	{r4, r5, pc}

08005aa4 <USB_OTG_CoreReset.isra.1>:
/**
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
 8005aa4:	b537      	push	{r0, r1, r2, r4, r5, lr}
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8005aa6:	2300      	movs	r3, #0
 8005aa8:	4c10      	ldr	r4, [pc, #64]	; (8005aec <USB_OTG_CoreReset.isra.1+0x48>)
 8005aaa:	9301      	str	r3, [sp, #4]
/**
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
 8005aac:	4605      	mov	r5, r0
  
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8005aae:	2003      	movs	r0, #3
 8005ab0:	f7fe fecc 	bl	800484c <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8005ab4:	682b      	ldr	r3, [r5, #0]
    if (++count > 200000)
 8005ab6:	3c01      	subs	r4, #1
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8005ab8:	691a      	ldr	r2, [r3, #16]
 8005aba:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8005abc:	d013      	beq.n	8005ae6 <USB_OTG_CoreReset.isra.1+0x42>
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8005abe:	9a01      	ldr	r2, [sp, #4]
 8005ac0:	2a00      	cmp	r2, #0
 8005ac2:	daf4      	bge.n	8005aae <USB_OTG_CoreReset.isra.1+0xa>
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8005ac4:	9a01      	ldr	r2, [sp, #4]
 8005ac6:	f042 0201 	orr.w	r2, r2, #1
 8005aca:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8005acc:	9a01      	ldr	r2, [sp, #4]
 8005ace:	611a      	str	r2, [r3, #16]
 8005ad0:	4a06      	ldr	r2, [pc, #24]	; (8005aec <USB_OTG_CoreReset.isra.1+0x48>)
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8005ad2:	6919      	ldr	r1, [r3, #16]
 8005ad4:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 8005ad6:	3a01      	subs	r2, #1
 8005ad8:	d002      	beq.n	8005ae0 <USB_OTG_CoreReset.isra.1+0x3c>
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8005ada:	9901      	ldr	r1, [sp, #4]
 8005adc:	07c9      	lsls	r1, r1, #31
 8005ade:	d4f8      	bmi.n	8005ad2 <USB_OTG_CoreReset.isra.1+0x2e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8005ae0:	2003      	movs	r0, #3
 8005ae2:	f7fe feb3 	bl	800484c <USB_OTG_BSP_uDelay>
  return status;
}
 8005ae6:	2000      	movs	r0, #0
 8005ae8:	b003      	add	sp, #12
 8005aea:	bd30      	pop	{r4, r5, pc}
 8005aec:	00030d41 	.word	0x00030d41

08005af0 <USB_OTG_WritePacket>:
*/
USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
 8005af0:	b530      	push	{r4, r5, lr}
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 8005af2:	78c4      	ldrb	r4, [r0, #3]
 8005af4:	b96c      	cbnz	r4, 8005b12 <USB_OTG_WritePacket+0x22>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8005af6:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  if (pdev->cfg.dma_enable == 0)
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 8005afa:	3303      	adds	r3, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8005afc:	f8d0 50d0 	ldr.w	r5, [r0, #208]	; 0xd0
  if (pdev->cfg.dma_enable == 0)
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 8005b00:	109b      	asrs	r3, r3, #2
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8005b02:	4622      	mov	r2, r4
 8005b04:	429a      	cmp	r2, r3
 8005b06:	d004      	beq.n	8005b12 <USB_OTG_WritePacket+0x22>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8005b08:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
 8005b0c:	6028      	str	r0, [r5, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8005b0e:	3201      	adds	r2, #1
 8005b10:	e7f8      	b.n	8005b04 <USB_OTG_WritePacket+0x14>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
    }
  }
  return status;
}
 8005b12:	2000      	movs	r0, #0
 8005b14:	bd30      	pop	{r4, r5, pc}

08005b16 <USB_OTG_ReadPacket>:
* @retval None
*/
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
 8005b16:	b510      	push	{r4, lr}
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 8005b18:	3203      	adds	r2, #3
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
 8005b1a:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 8005b1e:	1092      	asrs	r2, r2, #2
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8005b20:	2300      	movs	r3, #0
 8005b22:	4293      	cmp	r3, r2
 8005b24:	ea4f 0083 	mov.w	r0, r3, lsl #2
 8005b28:	d004      	beq.n	8005b34 <USB_OTG_ReadPacket+0x1e>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8005b2a:	6820      	ldr	r0, [r4, #0]
 8005b2c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8005b30:	3301      	adds	r3, #1
 8005b32:	e7f6      	b.n	8005b22 <USB_OTG_ReadPacket+0xc>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
    
  }
  return ((void *)dest);
}
 8005b34:	4408      	add	r0, r1
 8005b36:	bd10      	pop	{r4, pc}

08005b38 <USB_OTG_SelectCore>:
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8005b38:	2201      	movs	r2, #1
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
 8005b3a:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8005b3c:	2300      	movs	r3, #0
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8005b3e:	7082      	strb	r2, [r0, #2]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
  
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8005b40:	2901      	cmp	r1, #1
  
  pdev->cfg.dma_enable       = 0;
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8005b42:	f04f 0240 	mov.w	r2, #64	; 0x40
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8005b46:	70c3      	strb	r3, [r0, #3]
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8005b48:	8082      	strh	r2, [r0, #4]
  
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8005b4a:	d10c      	bne.n	8005b66 <USB_OTG_SelectCore+0x2e>
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8005b4c:	2308      	movs	r3, #8
 8005b4e:	7003      	strb	r3, [r0, #0]
    pdev->cfg.dev_endpoints    = 4 ;
 8005b50:	2304      	movs	r3, #4
 8005b52:	7043      	strb	r3, [r0, #1]
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8005b54:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8005b58:	80c3      	strh	r3, [r0, #6]
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8005b5a:	2302      	movs	r3, #2
 8005b5c:	7203      	strb	r3, [r0, #8]
  
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 8005b5e:	72c1      	strb	r1, [r0, #11]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
  
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
 8005b60:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8005b64:	e009      	b.n	8005b7a <USB_OTG_SelectCore+0x42>
    
#ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
 8005b66:	b941      	cbnz	r1, 8005b7a <USB_OTG_SelectCore+0x42>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
 8005b68:	230c      	movs	r3, #12
 8005b6a:	7003      	strb	r3, [r0, #0]
    pdev->cfg.dev_endpoints    = 6 ;
 8005b6c:	2306      	movs	r3, #6
 8005b6e:	7043      	strb	r3, [r0, #1]
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8005b70:	f44f 63a0 	mov.w	r3, #1280	; 0x500
 8005b74:	80c3      	strh	r3, [r0, #6]
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
 8005b76:	4b23      	ldr	r3, [pc, #140]	; (8005c04 <USB_OTG_SelectCore+0xcc>)
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
 8005b78:	72c1      	strb	r1, [r0, #11]
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8005b7a:	f503 6200 	add.w	r2, r3, #2048	; 0x800
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8005b7e:	7845      	ldrb	r5, [r0, #1]
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8005b80:	6102      	str	r2, [r0, #16]
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8005b82:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8005b84:	4602      	mov	r2, r0
 8005b86:	4619      	mov	r1, r3
 8005b88:	2400      	movs	r4, #0
 8005b8a:	42ac      	cmp	r4, r5
 8005b8c:	f101 0620 	add.w	r6, r1, #32
 8005b90:	f102 0204 	add.w	r2, r2, #4
 8005b94:	d208      	bcs.n	8005ba8 <USB_OTG_SelectCore+0x70>
 8005b96:	f501 6710 	add.w	r7, r1, #2304	; 0x900
 8005b9a:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8005b9e:	6511      	str	r1, [r2, #80]	; 0x50
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8005ba0:	6157      	str	r7, [r2, #20]
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8005ba2:	3401      	adds	r4, #1
 8005ba4:	4631      	mov	r1, r6
 8005ba6:	e7f0      	b.n	8005b8a <USB_OTG_SelectCore+0x52>
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8005ba8:	7804      	ldrb	r4, [r0, #0]
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
 8005baa:	f503 6280 	add.w	r2, r3, #1024	; 0x400
 8005bae:	6142      	str	r2, [r0, #20]
 8005bb0:	eb03 1544 	add.w	r5, r3, r4, lsl #5
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
 8005bb4:	f503 6288 	add.w	r2, r3, #1088	; 0x440
 8005bb8:	f8c0 20cc 	str.w	r2, [r0, #204]	; 0xcc
 8005bbc:	f505 65a0 	add.w	r5, r5, #1280	; 0x500
 8005bc0:	f503 62a0 	add.w	r2, r3, #1280	; 0x500
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8005bc4:	4601      	mov	r1, r0
 8005bc6:	42aa      	cmp	r2, r5
 8005bc8:	f101 0104 	add.w	r1, r1, #4
 8005bcc:	d003      	beq.n	8005bd6 <USB_OTG_SelectCore+0x9e>
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8005bce:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
 8005bd2:	3220      	adds	r2, #32
 8005bd4:	e7f7      	b.n	8005bc6 <USB_OTG_SelectCore+0x8e>
 8005bd6:	eb03 3404 	add.w	r4, r3, r4, lsl #12
 8005bda:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8005bde:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8005be2:	4601      	mov	r1, r0
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8005be4:	42a2      	cmp	r2, r4
 8005be6:	f101 0104 	add.w	r1, r1, #4
 8005bea:	d004      	beq.n	8005bf6 <USB_OTG_SelectCore+0xbe>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8005bec:	f8c1 20cc 	str.w	r2, [r1, #204]	; 0xcc
 8005bf0:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8005bf4:	e7f6      	b.n	8005be4 <USB_OTG_SelectCore+0xac>
      (i * USB_OTG_DATA_FIFO_SIZE));
  }
  pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
 8005bf6:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 8005bfa:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  
  return status;
}
 8005bfe:	2000      	movs	r0, #0
 8005c00:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005c02:	bf00      	nop
 8005c04:	40040000 	.word	0x40040000

08005c08 <USB_OTG_CoreInit>:
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8005c08:	b538      	push	{r3, r4, r5, lr}
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  
  
  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8005c0a:	7a03      	ldrb	r3, [r0, #8]
 8005c0c:	2b01      	cmp	r3, #1
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8005c0e:	4605      	mov	r5, r0
  USB_OTG_GCCFG_TypeDef    gccfg;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  usbcfg.d32 = 0;
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
 8005c10:	f04f 0400 	mov.w	r4, #0
 8005c14:	f850 2f0c 	ldr.w	r2, [r0, #12]!
  
  
  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8005c18:	d11e      	bne.n	8005c58 <USB_OTG_CoreInit+0x50>
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8005c1a:	6b93      	ldr	r3, [r2, #56]	; 0x38
    gccfg.b.pwdn = 0;
    
    if (pdev->cfg.Sof_output)
 8005c1c:	7a69      	ldrb	r1, [r5, #9]
  
  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
    gccfg.b.pwdn = 0;
 8005c1e:	f364 4310 	bfi	r3, r4, #16, #1
    
    if (pdev->cfg.Sof_output)
 8005c22:	b109      	cbz	r1, 8005c28 <USB_OTG_CoreInit+0x20>
    {
      gccfg.b.sofouten = 1;   
 8005c24:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    }
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8005c28:	6393      	str	r3, [r2, #56]	; 0x38
    
    /* Init The ULPI Interface */
    usbcfg.d32 = 0;
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8005c2a:	68d3      	ldr	r3, [r2, #12]
    
    usbcfg.b.physel            = 0; /* HS Interface */
 8005c2c:	f36f 1386 	bfc	r3, #6, #1
#else
#ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
#endif
#endif 
    usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
 8005c30:	f36f 5396 	bfc	r3, #22, #1
    
    usbcfg.b.ulpi_fsls = 0;
 8005c34:	f36f 4351 	bfc	r3, #17, #1
    usbcfg.b.ulpi_clk_sus_m = 0;
 8005c38:	f36f 43d3 	bfc	r3, #19, #1
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8005c3c:	60d3      	str	r3, [r2, #12]
    
    /* Reset after a PHY select  */
    USB_OTG_CoreReset(pdev);
 8005c3e:	f7ff ff31 	bl	8005aa4 <USB_OTG_CoreReset.isra.1>
    
    if(pdev->cfg.dma_enable == 1)
 8005c42:	78eb      	ldrb	r3, [r5, #3]
 8005c44:	2b01      	cmp	r3, #1
 8005c46:	d119      	bne.n	8005c7c <USB_OTG_CoreInit+0x74>
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8005c48:	2305      	movs	r3, #5
 8005c4a:	f363 0444 	bfi	r4, r3, #1, #4
      ahbcfg.b.dmaenable = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8005c4e:	68eb      	ldr	r3, [r5, #12]
    
    if(pdev->cfg.dma_enable == 1)
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
      ahbcfg.b.dmaenable = 1;
 8005c50:	f044 0420 	orr.w	r4, r4, #32
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8005c54:	609c      	str	r4, [r3, #8]
 8005c56:	e011      	b.n	8005c7c <USB_OTG_CoreInit+0x74>
    }    
  }
  else /* FS interface (embedded Phy) */
  {
    
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 8005c58:	68d3      	ldr	r3, [r2, #12]
    usbcfg.b.physel  = 1; /* FS Interface */
 8005c5a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8005c5e:	60d3      	str	r3, [r2, #12]
    /* Reset after a PHY select and set Host mode */
    USB_OTG_CoreReset(pdev);
 8005c60:	f7ff ff20 	bl	8005aa4 <USB_OTG_CoreReset.isra.1>
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
#endif    
    
    if(pdev->cfg.Sof_output)
 8005c64:	7a6b      	ldrb	r3, [r5, #9]
    {
      gccfg.b.sofouten = 1;  
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8005c66:	68ea      	ldr	r2, [r5, #12]
    gccfg.b.disablevbussensing = 1; 
#endif    
    
    if(pdev->cfg.Sof_output)
    {
      gccfg.b.sofouten = 1;  
 8005c68:	2b00      	cmp	r3, #0
 8005c6a:	bf0c      	ite	eq
 8005c6c:	f44f 1334 	moveq.w	r3, #2949120	; 0x2d0000
 8005c70:	f44f 1374 	movne.w	r3, #3997696	; 0x3d0000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8005c74:	6393      	str	r3, [r2, #56]	; 0x38
    USB_OTG_BSP_mDelay(20);
 8005c76:	2014      	movs	r0, #20
 8005c78:	f7fe fdf2 	bl	8004860 <USB_OTG_BSP_mDelay>
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 8005c7c:	78eb      	ldrb	r3, [r5, #3]
 8005c7e:	2b01      	cmp	r3, #1
 8005c80:	d107      	bne.n	8005c92 <USB_OTG_CoreInit+0x8a>
  {
    
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 8005c82:	68eb      	ldr	r3, [r5, #12]
 8005c84:	689c      	ldr	r4, [r3, #8]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8005c86:	2205      	movs	r2, #5
 8005c88:	f362 0444 	bfi	r4, r2, #1, #4
    ahbcfg.b.dmaenable = 1;
 8005c8c:	f044 0420 	orr.w	r4, r4, #32
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8005c90:	609c      	str	r4, [r3, #8]
  usbcfg.b.srpcap = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_EnableCommonInt(pdev);
#endif
  return status;
}
 8005c92:	2000      	movs	r0, #0
 8005c94:	bd38      	pop	{r3, r4, r5, pc}

08005c96 <USB_OTG_EnableGlobalInt>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 8005c96:	68c3      	ldr	r3, [r0, #12]
 8005c98:	689a      	ldr	r2, [r3, #8]
 8005c9a:	f042 0201 	orr.w	r2, r2, #1
 8005c9e:	609a      	str	r2, [r3, #8]
  return status;
}
 8005ca0:	2000      	movs	r0, #0
 8005ca2:	4770      	bx	lr

08005ca4 <USB_OTG_DisableGlobalInt>:
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 8005ca4:	68c3      	ldr	r3, [r0, #12]
 8005ca6:	689a      	ldr	r2, [r3, #8]
 8005ca8:	f022 0201 	bic.w	r2, r2, #1
 8005cac:	609a      	str	r2, [r3, #8]
  return status;
}
 8005cae:	2000      	movs	r0, #0
 8005cb0:	4770      	bx	lr
	...

08005cb4 <USB_OTG_FlushTxFifo>:
* @param  pdev : Selected device
* @param  num : FO num
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
{
 8005cb4:	b507      	push	{r0, r1, r2, lr}
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
 8005cb6:	2300      	movs	r3, #0
 8005cb8:	9301      	str	r3, [sp, #4]
  greset.b.txfflsh = 1;
 8005cba:	9b01      	ldr	r3, [sp, #4]
 8005cbc:	f043 0320 	orr.w	r3, r3, #32
 8005cc0:	9301      	str	r3, [sp, #4]
  greset.b.txfnum  = num;
 8005cc2:	9b01      	ldr	r3, [sp, #4]
 8005cc4:	f361 138a 	bfi	r3, r1, #6, #5
 8005cc8:	9301      	str	r3, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8005cca:	68c2      	ldr	r2, [r0, #12]
 8005ccc:	9b01      	ldr	r3, [sp, #4]
 8005cce:	6113      	str	r3, [r2, #16]
 8005cd0:	4b07      	ldr	r3, [pc, #28]	; (8005cf0 <USB_OTG_FlushTxFifo+0x3c>)
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8005cd2:	6911      	ldr	r1, [r2, #16]
 8005cd4:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 8005cd6:	3b01      	subs	r3, #1
 8005cd8:	d002      	beq.n	8005ce0 <USB_OTG_FlushTxFifo+0x2c>
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8005cda:	9901      	ldr	r1, [sp, #4]
 8005cdc:	0689      	lsls	r1, r1, #26
 8005cde:	d4f8      	bmi.n	8005cd2 <USB_OTG_FlushTxFifo+0x1e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8005ce0:	2003      	movs	r0, #3
 8005ce2:	f7fe fdb3 	bl	800484c <USB_OTG_BSP_uDelay>
  return status;
}
 8005ce6:	2000      	movs	r0, #0
 8005ce8:	b003      	add	sp, #12
 8005cea:	f85d fb04 	ldr.w	pc, [sp], #4
 8005cee:	bf00      	nop
 8005cf0:	00030d41 	.word	0x00030d41

08005cf4 <USB_OTG_FlushRxFifo>:
* @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
{
 8005cf4:	b507      	push	{r0, r1, r2, lr}
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8005cf6:	2300      	movs	r3, #0
 8005cf8:	9301      	str	r3, [sp, #4]
  greset.b.rxfflsh = 1;
 8005cfa:	9b01      	ldr	r3, [sp, #4]
 8005cfc:	f043 0310 	orr.w	r3, r3, #16
 8005d00:	9301      	str	r3, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8005d02:	68c2      	ldr	r2, [r0, #12]
 8005d04:	9b01      	ldr	r3, [sp, #4]
 8005d06:	6113      	str	r3, [r2, #16]
 8005d08:	4b07      	ldr	r3, [pc, #28]	; (8005d28 <USB_OTG_FlushRxFifo+0x34>)
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8005d0a:	6911      	ldr	r1, [r2, #16]
 8005d0c:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 8005d0e:	3b01      	subs	r3, #1
 8005d10:	d002      	beq.n	8005d18 <USB_OTG_FlushRxFifo+0x24>
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 8005d12:	9901      	ldr	r1, [sp, #4]
 8005d14:	06c9      	lsls	r1, r1, #27
 8005d16:	d4f8      	bmi.n	8005d0a <USB_OTG_FlushRxFifo+0x16>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8005d18:	2003      	movs	r0, #3
 8005d1a:	f7fe fd97 	bl	800484c <USB_OTG_BSP_uDelay>
  return status;
}
 8005d1e:	2000      	movs	r0, #0
 8005d20:	b003      	add	sp, #12
 8005d22:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d26:	bf00      	nop
 8005d28:	00030d41 	.word	0x00030d41

08005d2c <USB_OTG_SetCurrentMode>:
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8005d2c:	68c2      	ldr	r2, [r0, #12]
* @param  pdev : Selected device
* @param  mode :  (Host/device)
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
 8005d2e:	b508      	push	{r3, lr}
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8005d30:	68d3      	ldr	r3, [r2, #12]
  
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
 8005d32:	2901      	cmp	r1, #1
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  usbcfg.b.force_host = 0;
 8005d34:	f36f 735d 	bfc	r3, #29, #1
  usbcfg.b.force_dev = 0;
 8005d38:	f36f 739e 	bfc	r3, #30, #1
  
  if ( mode == HOST_MODE)
 8005d3c:	d102      	bne.n	8005d44 <USB_OTG_SetCurrentMode+0x18>
  {
    usbcfg.b.force_host = 1;
 8005d3e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8005d42:	e002      	b.n	8005d4a <USB_OTG_SetCurrentMode+0x1e>
  }
  else if ( mode == DEVICE_MODE)
 8005d44:	b909      	cbnz	r1, 8005d4a <USB_OTG_SetCurrentMode+0x1e>
  {
    usbcfg.b.force_dev = 1;
 8005d46:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8005d4a:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8005d4c:	2032      	movs	r0, #50	; 0x32
 8005d4e:	f7fe fd87 	bl	8004860 <USB_OTG_BSP_mDelay>
  return status;
}
 8005d52:	2000      	movs	r0, #0
 8005d54:	bd08      	pop	{r3, pc}

08005d56 <USB_OTG_IsDeviceMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8005d56:	68c3      	ldr	r3, [r0, #12]
 8005d58:	6958      	ldr	r0, [r3, #20]
 8005d5a:	f000 0001 	and.w	r0, r0, #1
* @retval num_in_ep
*/
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) != HOST_MODE);
}
 8005d5e:	f080 0001 	eor.w	r0, r0, #1
 8005d62:	4770      	bx	lr

08005d64 <USB_OTG_ReadCoreItr>:
* @retval Status
*/
uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v = 0;
  v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 8005d64:	68c3      	ldr	r3, [r0, #12]
 8005d66:	695a      	ldr	r2, [r3, #20]
  v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 8005d68:	6998      	ldr	r0, [r3, #24]
  return v;
}
 8005d6a:	4010      	ands	r0, r2
 8005d6c:	4770      	bx	lr

08005d6e <USB_OTG_InitDevSpeed>:
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 8005d6e:	6903      	ldr	r3, [r0, #16]
 8005d70:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devspd = speed;
 8005d72:	f361 0201 	bfi	r2, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 8005d76:	601a      	str	r2, [r3, #0]
 8005d78:	4770      	bx	lr
	...

08005d7c <USB_OTG_EnableDevInt>:
* @brief  USB_OTG_EnableDevInt : Enables the Device mode interrupts
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
{
 8005d7c:	b510      	push	{r4, lr}
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 8005d7e:	68c2      	ldr	r2, [r0, #12]
USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
 8005d80:	2300      	movs	r3, #0
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
 8005d82:	f06f 4180 	mvn.w	r1, #1073741824	; 0x40000000
  USB_OTG_GINTMSK_TypeDef  int_mask;
  
  int_mask.d32 = 0;
  /* Clear any pending USB_OTG Interrupts */
#ifndef USE_OTG_MODE
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 8005d86:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  USB_OTG_GINTMSK_TypeDef  intmsk;
  
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 8005d8a:	6193      	str	r3, [r2, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
 8005d8c:	6151      	str	r1, [r2, #20]
  USB_OTG_GINTMSK_TypeDef  int_mask;
  
  int_mask.d32 = 0;
  /* Clear any pending USB_OTG Interrupts */
#ifndef USE_OTG_MODE
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 8005d8e:	6054      	str	r4, [r2, #4]
#endif
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
 8005d90:	6151      	str	r1, [r2, #20]
  /* Enable the interrupts in the INTMSK */
  int_mask.b.wkupintr = 1;
  int_mask.b.usbsuspend = 1; 
 8005d92:	4908      	ldr	r1, [pc, #32]	; (8005db4 <USB_OTG_EnableDevInt+0x38>)
#ifdef USE_OTG_MODE
  int_mask.b.otgintr = 1;
  int_mask.b.sessreqintr = 1;
  int_mask.b.conidstschng = 1;
#endif
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 8005d94:	6191      	str	r1, [r2, #24]
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
 8005d96:	78c1      	ldrb	r1, [r0, #3]
 8005d98:	4299      	cmp	r1, r3
  {
    intmsk.b.rxstsqlvl = 1;
 8005d9a:	bf08      	it	eq
 8005d9c:	2310      	moveq	r3, #16
  intmsk.b.inepintr   = 1;
  intmsk.b.outepintr  = 1;
  intmsk.b.sofintr    = 1; 
  
  intmsk.b.incomplisoin    = 1; 
  intmsk.b.incomplisoout    = 1;   
 8005d9e:	f443 1370 	orr.w	r3, r3, #3932160	; 0x3c0000
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8005da2:	6991      	ldr	r1, [r2, #24]
  intmsk.b.inepintr   = 1;
  intmsk.b.outepintr  = 1;
  intmsk.b.sofintr    = 1; 
  
  intmsk.b.incomplisoin    = 1; 
  intmsk.b.incomplisoout    = 1;   
 8005da4:	f443 5360 	orr.w	r3, r3, #14336	; 0x3800
 8005da8:	f043 0308 	orr.w	r3, r3, #8
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8005dac:	430b      	orrs	r3, r1
 8005dae:	6193      	str	r3, [r2, #24]
  return status;
}
 8005db0:	2000      	movs	r0, #0
 8005db2:	bd10      	pop	{r4, pc}
 8005db4:	80000800 	.word	0x80000800

08005db8 <USB_OTG_CoreInitDev>:
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 8005db8:	b538      	push	{r3, r4, r5, lr}
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 8005dba:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
  USB_OTG_DIEPMSK_TypeDef msk;
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
 8005dbe:	2200      	movs	r2, #0
  txfifosize.d32 = 0;
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 8005dc0:	601a      	str	r2, [r3, #0]
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 8005dc2:	6903      	ldr	r3, [r0, #16]
  USB_OTG_DTHRCTL_TypeDef dthrctl;  
  
  depctl.d32 = 0;
  dcfg.d32 = 0;
  nptxfifosize.d32 = 0;
  txfifosize.d32 = 0;
 8005dc4:	4615      	mov	r5, r2
  msk.d32 = 0;
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
  /* Device configuration register */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 8005dc6:	681a      	ldr	r2, [r3, #0]
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
 8005dc8:	f365 22cc 	bfi	r2, r5, #11, #2
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
 8005dcc:	601a      	str	r2, [r3, #0]
  
#ifdef USB_OTG_FS_CORE
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
 8005dce:	7ac3      	ldrb	r3, [r0, #11]
 8005dd0:	2b01      	cmp	r3, #1
*         for device mode
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
{
 8005dd2:	4604      	mov	r4, r0
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
  
#ifdef USB_OTG_FS_CORE
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
 8005dd4:	d11b      	bne.n	8005e0e <USB_OTG_CoreInitDev+0x56>
  {  
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
 8005dd6:	2103      	movs	r1, #3
 8005dd8:	f7ff ffc9 	bl	8005d6e <USB_OTG_InitDevSpeed>
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 8005ddc:	68e3      	ldr	r3, [r4, #12]
 8005dde:	2180      	movs	r1, #128	; 0x80
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
 8005de0:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
 8005de4:	f361 020f 	bfi	r2, r1, #0, #16
    
    /* Set Full speed phy */
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
    
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 8005de8:	6259      	str	r1, [r3, #36]	; 0x24
    
    /* EP0 TX*/
    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
 8005dea:	629a      	str	r2, [r3, #40]	; 0x28
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
 8005dec:	22c0      	movs	r2, #192	; 0xc0
 8005dee:	f362 050f 	bfi	r5, r2, #0, #16
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
 8005df2:	f361 451f 	bfi	r5, r1, #16, #16
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 8005df6:	f44f 72a0 	mov.w	r2, #320	; 0x140
    
    
    /* EP1 TX*/
    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
 8005dfa:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104
    
    
    /* EP2 TX*/
    txfifosize.b.startaddr += txfifosize.b.depth;
 8005dfe:	f362 050f 	bfi	r5, r2, #0, #16
    txfifosize.b.depth = TX2_FIFO_FS_SIZE;
 8005e02:	f36f 451f 	bfc	r5, #16, #16
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
 8005e06:	f8c3 5108 	str.w	r5, [r3, #264]	; 0x108
    
    
    /* EP3 TX*/  
    txfifosize.b.startaddr += txfifosize.b.depth;
    txfifosize.b.depth = TX3_FIFO_FS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
 8005e0a:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
    txfifosize.b.depth = TX5_FIFO_HS_SIZE;
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
  }
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
 8005e0e:	2110      	movs	r1, #16
 8005e10:	4620      	mov	r0, r4
 8005e12:	f7ff ff4f 	bl	8005cb4 <USB_OTG_FlushTxFifo>
  USB_OTG_FlushRxFifo(pdev);
 8005e16:	4620      	mov	r0, r4
 8005e18:	f7ff ff6c 	bl	8005cf4 <USB_OTG_FlushRxFifo>
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8005e1c:	6923      	ldr	r3, [r4, #16]
 8005e1e:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8005e20:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
#endif  
  /* Flush the FIFOs */
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
  USB_OTG_FlushRxFifo(pdev);
  /* Clear all pending Device Interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 8005e24:	611a      	str	r2, [r3, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 8005e26:	615a      	str	r2, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8005e28:	6199      	str	r1, [r3, #24]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 8005e2a:	61da      	str	r2, [r3, #28]
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8005e2c:	7861      	ldrb	r1, [r4, #1]
 8005e2e:	428a      	cmp	r2, r1
 8005e30:	d20f      	bcs.n	8005e52 <USB_OTG_CoreInitDev+0x9a>
 8005e32:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8005e36:	3201      	adds	r2, #1
  {
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
 8005e38:	6989      	ldr	r1, [r1, #24]
 8005e3a:	6808      	ldr	r0, [r1, #0]
    if (depctl.b.epena)
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 8005e3c:	2800      	cmp	r0, #0
 8005e3e:	bfac      	ite	ge
 8005e40:	2000      	movge	r0, #0
 8005e42:	f04f 4090 	movlt.w	r0, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
 8005e46:	6008      	str	r0, [r1, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 8005e48:	2000      	movs	r0, #0
 8005e4a:	6108      	str	r0, [r1, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8005e4c:	20ff      	movs	r0, #255	; 0xff
 8005e4e:	6088      	str	r0, [r1, #8]
 8005e50:	e7ec      	b.n	8005e2c <USB_OTG_CoreInitDev+0x74>
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8005e52:	2200      	movs	r2, #0
    }
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
  }
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 8005e54:	7861      	ldrb	r1, [r4, #1]
 8005e56:	428a      	cmp	r2, r1
 8005e58:	d20f      	bcs.n	8005e7a <USB_OTG_CoreInitDev+0xc2>
 8005e5a:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8005e5e:	3201      	adds	r2, #1
  {
    USB_OTG_DEPCTL_TypeDef  depctl;
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
 8005e60:	6d49      	ldr	r1, [r1, #84]	; 0x54
 8005e62:	6808      	ldr	r0, [r1, #0]
    if (depctl.b.epena)
    {
      depctl.d32 = 0;
      depctl.b.epdis = 1;
      depctl.b.snak = 1;
 8005e64:	2800      	cmp	r0, #0
 8005e66:	bfac      	ite	ge
 8005e68:	2000      	movge	r0, #0
 8005e6a:	f04f 4090 	movlt.w	r0, #1207959552	; 0x48000000
    }
    else
    {
      depctl.d32 = 0;
    }
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
 8005e6e:	6008      	str	r0, [r1, #0]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 8005e70:	2000      	movs	r0, #0
 8005e72:	6108      	str	r0, [r1, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8005e74:	20ff      	movs	r0, #255	; 0xff
 8005e76:	6088      	str	r0, [r1, #8]
 8005e78:	e7ec      	b.n	8005e54 <USB_OTG_CoreInitDev+0x9c>
  }
  msk.d32 = 0;
  msk.b.txfifoundrn = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
 8005e7a:	691a      	ldr	r2, [r3, #16]
 8005e7c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005e80:	611a      	str	r2, [r3, #16]
  
  if (pdev->cfg.dma_enable == 1)
 8005e82:	78e2      	ldrb	r2, [r4, #3]
 8005e84:	2a01      	cmp	r2, #1
 8005e86:	d104      	bne.n	8005e92 <USB_OTG_CoreInitDev+0xda>
  {
    dthrctl.d32 = 0;
    dthrctl.b.non_iso_thr_en = 1;
    dthrctl.b.iso_thr_en = 1;
    dthrctl.b.tx_thr_len = 64;
    dthrctl.b.rx_thr_en = 1;
 8005e88:	4a04      	ldr	r2, [pc, #16]	; (8005e9c <USB_OTG_CoreInitDev+0xe4>)
    dthrctl.b.rx_thr_len = 64;
 8005e8a:	2140      	movs	r1, #64	; 0x40
 8005e8c:	f361 4259 	bfi	r2, r1, #17, #9
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
 8005e90:	631a      	str	r2, [r3, #48]	; 0x30
  }
  USB_OTG_EnableDevInt(pdev);
 8005e92:	4620      	mov	r0, r4
 8005e94:	f7ff ff72 	bl	8005d7c <USB_OTG_EnableDevInt>
  return status;
}
 8005e98:	2000      	movs	r0, #0
 8005e9a:	bd38      	pop	{r3, r4, r5, pc}
 8005e9c:	00010103 	.word	0x00010103

08005ea0 <USB_OTG_GetDeviceSpeed>:
{
  USB_OTG_DSTS_TypeDef  dsts;
  enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
  
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8005ea0:	6903      	ldr	r3, [r0, #16]
 8005ea2:	689b      	ldr	r3, [r3, #8]
  
  switch (dsts.b.enumspd)
 8005ea4:	f3c3 0341 	ubfx	r3, r3, #1, #2
 8005ea8:	2b02      	cmp	r3, #2
 8005eaa:	d005      	beq.n	8005eb8 <USB_OTG_GetDeviceSpeed+0x18>
 8005eac:	2b03      	cmp	r3, #3
 8005eae:	d005      	beq.n	8005ebc <USB_OTG_GetDeviceSpeed+0x1c>
 8005eb0:	2b01      	cmp	r3, #1
 8005eb2:	d003      	beq.n	8005ebc <USB_OTG_GetDeviceSpeed+0x1c>
  {
  case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
    speed = USB_SPEED_HIGH;
 8005eb4:	2003      	movs	r0, #3
 8005eb6:	4770      	bx	lr
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    speed = USB_SPEED_FULL;
    break;
    
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    speed = USB_SPEED_LOW;
 8005eb8:	2001      	movs	r0, #1
    break;
 8005eba:	4770      	bx	lr
  case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
    speed = USB_SPEED_HIGH;
    break;
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    speed = USB_SPEED_FULL;
 8005ebc:	2002      	movs	r0, #2
    speed = USB_SPEED_LOW;
    break;
  }
  
  return speed;
}
 8005ebe:	4770      	bx	lr

08005ec0 <USB_OTG_EP0Activate>:
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8005ec0:	6903      	ldr	r3, [r0, #16]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 8005ec2:	6981      	ldr	r1, [r0, #24]
*   for transmitting packets
* @param  None
* @retval USB_OTG_STS : status
*/
USB_OTG_STS  USB_OTG_EP0Activate(USB_OTG_CORE_HANDLE *pdev)
{
 8005ec4:	b510      	push	{r4, lr}
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8005ec6:	689c      	ldr	r4, [r3, #8]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 8005ec8:	680a      	ldr	r2, [r1, #0]
  /* Set the MPS of the IN EP based on the enumeration speed */
  switch (dsts.b.enumspd)
 8005eca:	f3c4 0041 	ubfx	r0, r4, #1, #2
 8005ece:	2802      	cmp	r0, #2
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
 8005ed0:	bf06      	itte	eq
 8005ed2:	2003      	moveq	r0, #3
 8005ed4:	f360 020a 	bfieq	r2, r0, #0, #11
  switch (dsts.b.enumspd)
  {
  case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
 8005ed8:	f36f 020a 	bfcne	r2, #0, #11
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 8005edc:	600a      	str	r2, [r1, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 8005ede:	685a      	ldr	r2, [r3, #4]
 8005ee0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005ee4:	605a      	str	r2, [r3, #4]
  return status;
}
 8005ee6:	2000      	movs	r0, #0
 8005ee8:	bd10      	pop	{r4, pc}

08005eea <USB_OTG_EPActivate>:
* @brief  USB_OTG_EPActivate : Activates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8005eea:	b530      	push	{r4, r5, lr}
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8005eec:	784d      	ldrb	r5, [r1, #1]
 8005eee:	780b      	ldrb	r3, [r1, #0]
 8005ef0:	2d01      	cmp	r5, #1
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
 8005ef2:	f04f 0200 	mov.w	r2, #0
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8005ef6:	eb00 0483 	add.w	r4, r0, r3, lsl #2
  
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8005efa:	d105      	bne.n	8005f08 <USB_OTG_EPActivate+0x1e>
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
 8005efc:	fa05 f303 	lsl.w	r3, r5, r3
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8005f00:	69a4      	ldr	r4, [r4, #24]
    daintmsk.ep.in = 1 << ep->num;
 8005f02:	f363 020f 	bfi	r2, r3, #0, #16
 8005f06:	e005      	b.n	8005f14 <USB_OTG_EPActivate+0x2a>
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
    daintmsk.ep.out = 1 << ep->num;
 8005f08:	2501      	movs	r5, #1
 8005f0a:	fa05 f303 	lsl.w	r3, r5, r3
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 8005f0e:	6d64      	ldr	r4, [r4, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 8005f10:	f363 421f 	bfi	r2, r3, #16, #16
  }
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
 8005f14:	6823      	ldr	r3, [r4, #0]
  if (!depctl.b.usbactep)
 8005f16:	041d      	lsls	r5, r3, #16
 8005f18:	d40d      	bmi.n	8005f36 <USB_OTG_EPActivate+0x4c>
  {
    depctl.b.mps    = ep->maxpacket;
 8005f1a:	688d      	ldr	r5, [r1, #8]
 8005f1c:	f365 030a 	bfi	r3, r5, #0, #11
    depctl.b.eptype = ep->type;
 8005f20:	78cd      	ldrb	r5, [r1, #3]
    depctl.b.txfnum = ep->tx_fifo_num;
 8005f22:	88c9      	ldrh	r1, [r1, #6]
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
  if (!depctl.b.usbactep)
  {
    depctl.b.mps    = ep->maxpacket;
    depctl.b.eptype = ep->type;
 8005f24:	f365 4393 	bfi	r3, r5, #18, #2
    depctl.b.txfnum = ep->tx_fifo_num;
 8005f28:	f361 5399 	bfi	r3, r1, #22, #4
    depctl.b.setd0pid = 1;
    depctl.b.usbactep = 1;
 8005f2c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005f30:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    USB_OTG_WRITE_REG32(addr, depctl.d32);
 8005f34:	6023      	str	r3, [r4, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
  }
  else
#endif   
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
 8005f36:	6903      	ldr	r3, [r0, #16]
 8005f38:	69d9      	ldr	r1, [r3, #28]
 8005f3a:	430a      	orrs	r2, r1
 8005f3c:	61da      	str	r2, [r3, #28]
  return status;
}
 8005f3e:	2000      	movs	r0, #0
 8005f40:	bd30      	pop	{r4, r5, pc}

08005f42 <USB_OTG_EPDeactivate>:
* @brief  USB_OTG_EPDeactivate : Deactivates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8005f42:	b530      	push	{r4, r5, lr}
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8005f44:	784d      	ldrb	r5, [r1, #1]
 8005f46:	780b      	ldrb	r3, [r1, #0]
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
 8005f48:	2400      	movs	r4, #0
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8005f4a:	2d01      	cmp	r5, #1
  USB_OTG_DEPCTL_TypeDef  depctl;
  USB_OTG_DAINT_TypeDef  daintmsk;
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
 8005f4c:	4622      	mov	r2, r4
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8005f4e:	eb00 0183 	add.w	r1, r0, r3, lsl #2
  __IO uint32_t *addr;
  
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 8005f52:	d105      	bne.n	8005f60 <USB_OTG_EPDeactivate+0x1e>
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
 8005f54:	fa05 f303 	lsl.w	r3, r5, r3
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 8005f58:	6989      	ldr	r1, [r1, #24]
    daintmsk.ep.in = 1 << ep->num;
 8005f5a:	f363 020f 	bfi	r2, r3, #0, #16
 8005f5e:	e005      	b.n	8005f6c <USB_OTG_EPDeactivate+0x2a>
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
    daintmsk.ep.out = 1 << ep->num;
 8005f60:	2501      	movs	r5, #1
 8005f62:	fa05 f303 	lsl.w	r3, r5, r3
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
    daintmsk.ep.in = 1 << ep->num;
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 8005f66:	6d49      	ldr	r1, [r1, #84]	; 0x54
    daintmsk.ep.out = 1 << ep->num;
 8005f68:	f363 421f 	bfi	r2, r3, #16, #16
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 8005f6c:	6903      	ldr	r3, [r0, #16]
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
    daintmsk.ep.out = 1 << ep->num;
  }
  depctl.b.usbactep = 0;
 8005f6e:	f36f 34cf 	bfc	r4, #15, #1
  USB_OTG_WRITE_REG32(addr, depctl.d32);
 8005f72:	600c      	str	r4, [r1, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 8005f74:	69d9      	ldr	r1, [r3, #28]
 8005f76:	ea21 0202 	bic.w	r2, r1, r2
 8005f7a:	61da      	str	r2, [r3, #28]
  return status;
}
 8005f7c:	2000      	movs	r0, #0
 8005f7e:	bd30      	pop	{r4, r5, pc}

08005f80 <USB_OTG_EPStartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8005f80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t fifoemptymsk = 0;  
  
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 8005f82:	784e      	ldrb	r6, [r1, #1]
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8005f84:	460a      	mov	r2, r1
 8005f86:	7809      	ldrb	r1, [r1, #0]
 8005f88:	6953      	ldr	r3, [r2, #20]
  uint32_t fifoemptymsk = 0;  
  
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 8005f8a:	2e01      	cmp	r6, #1
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 8005f8c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
  uint32_t fifoemptymsk = 0;  
  
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 8005f90:	d145      	bne.n	800601e <USB_OTG_EPStartXfer+0x9e>
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 8005f92:	698d      	ldr	r5, [r1, #24]
 8005f94:	6829      	ldr	r1, [r5, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
 8005f96:	692c      	ldr	r4, [r5, #16]
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 8005f98:	f363 0412 	bfi	r4, r3, #0, #19
  if (ep->is_in == 1)
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 8005f9c:	b913      	cbnz	r3, 8005fa4 <USB_OTG_EPStartXfer+0x24>
    {
      deptsiz.b.xfersize = 0;
      deptsiz.b.pktcnt = 1;
 8005f9e:	f366 44dc 	bfi	r4, r6, #19, #10
 8005fa2:	e00b      	b.n	8005fbc <USB_OTG_EPStartXfer+0x3c>
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 8005fa4:	6896      	ldr	r6, [r2, #8]
 8005fa6:	199f      	adds	r7, r3, r6
 8005fa8:	3f01      	subs	r7, #1
 8005faa:	fbb7 f6f6 	udiv	r6, r7, r6
 8005fae:	f366 44dc 	bfi	r4, r6, #19, #10
      
      if (ep->type == EP_TYPE_ISOC)
 8005fb2:	78d6      	ldrb	r6, [r2, #3]
 8005fb4:	2e01      	cmp	r6, #1
      {
        deptsiz.b.mc = 1;
 8005fb6:	bf08      	it	eq
 8005fb8:	f366 745e 	bfieq	r4, r6, #29, #2
      }       
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
 8005fbc:	612c      	str	r4, [r5, #16]
    
    if (pdev->cfg.dma_enable == 1)
 8005fbe:	78c4      	ldrb	r4, [r0, #3]
 8005fc0:	7815      	ldrb	r5, [r2, #0]
 8005fc2:	2c01      	cmp	r4, #1
 8005fc4:	d105      	bne.n	8005fd2 <USB_OTG_EPStartXfer+0x52>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
 8005fc6:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8005fca:	6914      	ldr	r4, [r2, #16]
 8005fcc:	69ad      	ldr	r5, [r5, #24]
 8005fce:	616c      	str	r4, [r5, #20]
 8005fd0:	e00a      	b.n	8005fe8 <USB_OTG_EPStartXfer+0x68>
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 8005fd2:	78d4      	ldrb	r4, [r2, #3]
 8005fd4:	2c01      	cmp	r4, #1
 8005fd6:	d007      	beq.n	8005fe8 <USB_OTG_EPStartXfer+0x68>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
 8005fd8:	b133      	cbz	r3, 8005fe8 <USB_OTG_EPStartXfer+0x68>
        {
          fifoemptymsk = 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8005fda:	6904      	ldr	r4, [r0, #16]
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 8005fdc:	2701      	movs	r7, #1
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8005fde:	6b66      	ldr	r6, [r4, #52]	; 0x34
      if (ep->type != EP_TYPE_ISOC)
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0)
        {
          fifoemptymsk = 1 << ep->num;
 8005fe0:	fa07 f505 	lsl.w	r5, r7, r5
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8005fe4:	4335      	orrs	r5, r6
 8005fe6:	6365      	str	r5, [r4, #52]	; 0x34
        }
      }
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
 8005fe8:	78d4      	ldrb	r4, [r2, #3]
 8005fea:	2c01      	cmp	r4, #1
 8005fec:	d107      	bne.n	8005ffe <USB_OTG_EPStartXfer+0x7e>
    {
      dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8005fee:	6904      	ldr	r4, [r0, #16]
 8005ff0:	68a4      	ldr	r4, [r4, #8]
      
      if (((dsts.b.soffn)&0x1) == 0)
 8005ff2:	05e4      	lsls	r4, r4, #23
      {
        depctl.b.setd1pid = 1;
 8005ff4:	bf54      	ite	pl
 8005ff6:	f041 5100 	orrpl.w	r1, r1, #536870912	; 0x20000000
      }
      else
      {
        depctl.b.setd0pid = 1;
 8005ffa:	f041 5180 	orrmi.w	r1, r1, #268435456	; 0x10000000
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 8005ffe:	7814      	ldrb	r4, [r2, #0]
 8006000:	eb00 0484 	add.w	r4, r0, r4, lsl #2
      }
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 8006004:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 8006008:	69a4      	ldr	r4, [r4, #24]
 800600a:	6021      	str	r1, [r4, #0]
    
    if (ep->type == EP_TYPE_ISOC)
 800600c:	78d1      	ldrb	r1, [r2, #3]
 800600e:	2901      	cmp	r1, #1
 8006010:	d136      	bne.n	8006080 <USB_OTG_EPStartXfer+0x100>
    {
      USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
 8006012:	68d1      	ldr	r1, [r2, #12]
 8006014:	7812      	ldrb	r2, [r2, #0]
 8006016:	b29b      	uxth	r3, r3
 8006018:	f7ff fd6a 	bl	8005af0 <USB_OTG_WritePacket>
 800601c:	e030      	b.n	8006080 <USB_OTG_EPStartXfer+0x100>
    }    
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 800601e:	6d4e      	ldr	r6, [r1, #84]	; 0x54
 8006020:	6895      	ldr	r5, [r2, #8]
 8006022:	6831      	ldr	r1, [r6, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
 8006024:	6934      	ldr	r4, [r6, #16]
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    if (ep->xfer_len == 0)
 8006026:	b92b      	cbnz	r3, 8006034 <USB_OTG_EPStartXfer+0xb4>
    {
      deptsiz.b.xfersize = ep->maxpacket;
 8006028:	f365 0412 	bfi	r4, r5, #0, #19
      deptsiz.b.pktcnt = 1;
 800602c:	2301      	movs	r3, #1
 800602e:	f363 44dc 	bfi	r4, r3, #19, #10
 8006032:	e00a      	b.n	800604a <USB_OTG_EPStartXfer+0xca>
    }
    else
    {
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
 8006034:	442b      	add	r3, r5
 8006036:	3b01      	subs	r3, #1
 8006038:	fbb3 f3f5 	udiv	r3, r3, r5
 800603c:	f363 44dc 	bfi	r4, r3, #19, #10
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
 8006040:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8006044:	435d      	muls	r5, r3
 8006046:	f365 0412 	bfi	r4, r5, #0, #19
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 800604a:	6134      	str	r4, [r6, #16]
    
    if (pdev->cfg.dma_enable == 1)
 800604c:	78c3      	ldrb	r3, [r0, #3]
 800604e:	2b01      	cmp	r3, #1
 8006050:	d105      	bne.n	800605e <USB_OTG_EPStartXfer+0xde>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 8006052:	7813      	ldrb	r3, [r2, #0]
 8006054:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8006058:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800605a:	6913      	ldr	r3, [r2, #16]
 800605c:	6163      	str	r3, [r4, #20]
    }
    
    if (ep->type == EP_TYPE_ISOC)
 800605e:	78d3      	ldrb	r3, [r2, #3]
 8006060:	2b01      	cmp	r3, #1
 8006062:	d106      	bne.n	8006072 <USB_OTG_EPStartXfer+0xf2>
    {
      if (ep->even_odd_frame)
 8006064:	7953      	ldrb	r3, [r2, #5]
 8006066:	b113      	cbz	r3, 800606e <USB_OTG_EPStartXfer+0xee>
      {
        depctl.b.setd1pid = 1;
 8006068:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 800606c:	e001      	b.n	8006072 <USB_OTG_EPStartXfer+0xf2>
      }
      else
      {
        depctl.b.setd0pid = 1;
 800606e:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 8006072:	7813      	ldrb	r3, [r2, #0]
 8006074:	eb00 0083 	add.w	r0, r0, r3, lsl #2
        depctl.b.setd0pid = 1;
      }
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 8006078:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 800607c:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800607e:	6019      	str	r1, [r3, #0]
  }
  return status;
}
 8006080:	2000      	movs	r0, #0
 8006082:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006084 <USB_OTG_EP0StartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 8006084:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 8006086:	f891 c001 	ldrb.w	ip, [r1, #1]
 800608a:	694a      	ldr	r2, [r1, #20]
 800608c:	f1bc 0f01 	cmp.w	ip, #1
 8006090:	d13d      	bne.n	800610e <USB_OTG_EP0StartXfer+0x8a>
  {
    in_regs = pdev->regs.INEP_REGS[0];
 8006092:	6984      	ldr	r4, [r0, #24]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
 8006094:	6823      	ldr	r3, [r4, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
 8006096:	6926      	ldr	r6, [r4, #16]
 8006098:	9600      	str	r6, [sp, #0]
 800609a:	b2f5      	uxtb	r5, r6
 800609c:	f3c6 4707 	ubfx	r7, r6, #16, #8
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 80060a0:	b942      	cbnz	r2, 80060b4 <USB_OTG_EP0StartXfer+0x30>
    {
      deptsiz.b.xfersize = 0;
 80060a2:	f362 0506 	bfi	r5, r2, #0, #7
      deptsiz.b.pktcnt = 1;
 80060a6:	f36c 07c4 	bfi	r7, ip, #3, #2
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = 0;
 80060aa:	f88d 5000 	strb.w	r5, [sp]
      deptsiz.b.pktcnt = 1;
 80060ae:	f88d 7002 	strb.w	r7, [sp, #2]
 80060b2:	e00f      	b.n	80060d4 <USB_OTG_EP0StartXfer+0x50>
      
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
 80060b4:	688e      	ldr	r6, [r1, #8]
 80060b6:	42b2      	cmp	r2, r6
      {
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
 80060b8:	bf8a      	itet	hi
 80060ba:	f366 0506 	bfihi	r5, r6, #0, #7
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
 80060be:	f362 0506 	bfils	r5, r2, #0, #7
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
 80060c2:	614e      	strhi	r6, [r1, #20]
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
      }
      deptsiz.b.pktcnt = 1;
 80060c4:	2201      	movs	r2, #1
 80060c6:	463e      	mov	r6, r7
 80060c8:	f362 06c4 	bfi	r6, r2, #3, #2
        ep->xfer_len = ep->maxpacket;
        deptsiz.b.xfersize = ep->maxpacket;
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
 80060cc:	f88d 5000 	strb.w	r5, [sp]
      }
      deptsiz.b.pktcnt = 1;
 80060d0:	f88d 6002 	strb.w	r6, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
 80060d4:	9a00      	ldr	r2, [sp, #0]
 80060d6:	6122      	str	r2, [r4, #16]
    
    if (pdev->cfg.dma_enable == 1)
 80060d8:	78c2      	ldrb	r2, [r0, #3]
 80060da:	2a01      	cmp	r2, #1
 80060dc:	d105      	bne.n	80060ea <USB_OTG_EP0StartXfer+0x66>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
 80060de:	780a      	ldrb	r2, [r1, #0]
 80060e0:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80060e4:	6995      	ldr	r5, [r2, #24]
 80060e6:	690a      	ldr	r2, [r1, #16]
 80060e8:	616a      	str	r2, [r5, #20]
    }
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 80060ea:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
 80060ee:	6023      	str	r3, [r4, #0]
    
    
    
    if (pdev->cfg.dma_enable == 0)
 80060f0:	78c3      	ldrb	r3, [r0, #3]
 80060f2:	2b00      	cmp	r3, #0
 80060f4:	d13f      	bne.n	8006176 <USB_OTG_EP0StartXfer+0xf2>
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
 80060f6:	694b      	ldr	r3, [r1, #20]
 80060f8:	2b00      	cmp	r3, #0
 80060fa:	d03c      	beq.n	8006176 <USB_OTG_EP0StartXfer+0xf2>
      {
        {
          fifoemptymsk |= 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 80060fc:	6903      	ldr	r3, [r0, #16]
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 80060fe:	780a      	ldrb	r2, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8006100:	6b58      	ldr	r0, [r3, #52]	; 0x34
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
      {
        {
          fifoemptymsk |= 1 << ep->num;
 8006102:	2101      	movs	r1, #1
 8006104:	fa01 f202 	lsl.w	r2, r1, r2
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 8006108:	4302      	orrs	r2, r0
 800610a:	635a      	str	r2, [r3, #52]	; 0x34
 800610c:	e033      	b.n	8006176 <USB_OTG_EP0StartXfer+0xf2>
    }
  }
  else
  {
    /* OUT endpoint */
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 800610e:	780b      	ldrb	r3, [r1, #0]
 8006110:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8006114:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 8006116:	6823      	ldr	r3, [r4, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
 8006118:	6925      	ldr	r5, [r4, #16]
 800611a:	9500      	str	r5, [sp, #0]
 800611c:	b2ef      	uxtb	r7, r5
 800611e:	f3c5 4607 	ubfx	r6, r5, #16, #8
 8006122:	688d      	ldr	r5, [r1, #8]
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
 8006124:	b94a      	cbnz	r2, 800613a <USB_OTG_EP0StartXfer+0xb6>
    {
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
 8006126:	2201      	movs	r2, #1
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 8006128:	f365 0706 	bfi	r7, r5, #0, #7
      deptsiz.b.pktcnt = 1;
 800612c:	f362 06c4 	bfi	r6, r2, #3, #2
    /* Program the transfer size and packet count as follows:
    * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
    * pktcnt = N           */
    if (ep->xfer_len == 0)
    {
      deptsiz.b.xfersize = ep->maxpacket;
 8006130:	f88d 7000 	strb.w	r7, [sp]
      deptsiz.b.pktcnt = 1;
 8006134:	f88d 6002 	strb.w	r6, [sp, #2]
 8006138:	e00b      	b.n	8006152 <USB_OTG_EP0StartXfer+0xce>
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
      deptsiz.b.xfersize = ep->maxpacket;
 800613a:	463a      	mov	r2, r7
 800613c:	f365 0206 	bfi	r2, r5, #0, #7
      deptsiz.b.xfersize = ep->maxpacket;
      deptsiz.b.pktcnt = 1;
    }
    else
    {
      ep->xfer_len = ep->maxpacket;
 8006140:	614d      	str	r5, [r1, #20]
      deptsiz.b.xfersize = ep->maxpacket;
 8006142:	f88d 2000 	strb.w	r2, [sp]
      deptsiz.b.pktcnt = 1;
 8006146:	4635      	mov	r5, r6
 8006148:	2201      	movs	r2, #1
 800614a:	f362 05c4 	bfi	r5, r2, #3, #2
 800614e:	f88d 5002 	strb.w	r5, [sp, #2]
    }
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 8006152:	9a00      	ldr	r2, [sp, #0]
 8006154:	6122      	str	r2, [r4, #16]
    if (pdev->cfg.dma_enable == 1)
 8006156:	78c2      	ldrb	r2, [r0, #3]
 8006158:	2a01      	cmp	r2, #1
 800615a:	d105      	bne.n	8006168 <USB_OTG_EP0StartXfer+0xe4>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 800615c:	780a      	ldrb	r2, [r1, #0]
 800615e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8006162:	6d54      	ldr	r4, [r2, #84]	; 0x54
 8006164:	690a      	ldr	r2, [r1, #16]
 8006166:	6162      	str	r2, [r4, #20]
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 8006168:	780a      	ldrb	r2, [r1, #0]
 800616a:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    {
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
    }
    /* EP enable */
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
 800616e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 8006172:	6d42      	ldr	r2, [r0, #84]	; 0x54
 8006174:	6013      	str	r3, [r2, #0]
    
  }
  return status;
}
 8006176:	2000      	movs	r0, #0
 8006178:	b003      	add	sp, #12
 800617a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800617c <USB_OTG_EPSetStall>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 800617c:	784b      	ldrb	r3, [r1, #1]
 800617e:	2b01      	cmp	r3, #1
 8006180:	780b      	ldrb	r3, [r1, #0]
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8006182:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 8006186:	d106      	bne.n	8006196 <USB_OTG_EPSetStall+0x1a>
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 8006188:	6982      	ldr	r2, [r0, #24]
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 800618a:	6813      	ldr	r3, [r2, #0]
    /* set the disable and stall bits */
    if (depctl.b.epena)
 800618c:	2b00      	cmp	r3, #0
 800618e:	da04      	bge.n	800619a <USB_OTG_EPSetStall+0x1e>
    {
      depctl.b.epdis = 1;
 8006190:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8006194:	e001      	b.n	800619a <USB_OTG_EPSetStall+0x1e>
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 8006196:	6d42      	ldr	r2, [r0, #84]	; 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 8006198:	6813      	ldr	r3, [r2, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
 800619a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 800619e:	6013      	str	r3, [r2, #0]
  }
  return status;
}
 80061a0:	2000      	movs	r0, #0
 80061a2:	4770      	bx	lr

080061a4 <USB_OTG_EPClearStall>:
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
 80061a4:	784b      	ldrb	r3, [r1, #1]
 80061a6:	2b01      	cmp	r3, #1
 80061a8:	780b      	ldrb	r3, [r1, #0]
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80061aa:	78c9      	ldrb	r1, [r1, #3]
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80061ac:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80061b0:	f1a1 0102 	sub.w	r1, r1, #2
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 80061b4:	bf0c      	ite	eq
 80061b6:	6982      	ldreq	r2, [r0, #24]
  }
  else
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 80061b8:	6d42      	ldrne	r2, [r0, #84]	; 0x54
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 80061ba:	6813      	ldr	r3, [r2, #0]
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80061bc:	2901      	cmp	r1, #1
  {
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
 80061be:	f36f 5355 	bfc	r3, #21, #1
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
  {
    depctl.b.setd0pid = 1; /* DATA0 */
 80061c2:	bf98      	it	ls
 80061c4:	f043 5380 	orrls.w	r3, r3, #268435456	; 0x10000000
  }
  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 80061c8:	6013      	str	r3, [r2, #0]
  return status;
}
 80061ca:	2000      	movs	r0, #0
 80061cc:	4770      	bx	lr

080061ce <USB_OTG_ReadDevAllOutEp_itr>:
* @retval OUT endpoint interrupt bits
*/
uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 80061ce:	6903      	ldr	r3, [r0, #16]
 80061d0:	699a      	ldr	r2, [r3, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 80061d2:	69d8      	ldr	r0, [r3, #28]
 80061d4:	4010      	ands	r0, r2
  return ((v & 0xffff0000) >> 16);
}
 80061d6:	0c00      	lsrs	r0, r0, #16
 80061d8:	4770      	bx	lr

080061da <USB_OTG_ReadDevOutEP_itr>:
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 80061da:	eb00 0181 	add.w	r1, r0, r1, lsl #2
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 80061de:	6902      	ldr	r2, [r0, #16]
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 80061e0:	6d4b      	ldr	r3, [r1, #84]	; 0x54
 80061e2:	689b      	ldr	r3, [r3, #8]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 80061e4:	6950      	ldr	r0, [r2, #20]
  return v;
}
 80061e6:	4018      	ands	r0, r3
 80061e8:	4770      	bx	lr

080061ea <USB_OTG_ReadDevAllInEPItr>:
* @retval int status register
*/
uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 80061ea:	6903      	ldr	r3, [r0, #16]
 80061ec:	6998      	ldr	r0, [r3, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 80061ee:	69db      	ldr	r3, [r3, #28]
 80061f0:	4018      	ands	r0, r3
  return (v & 0xffff);
}
 80061f2:	b280      	uxth	r0, r0
 80061f4:	4770      	bx	lr

080061f6 <USB_OTG_EP0_OutStart>:
* @brief  configures EPO to receive SETUP packets
* @param  None
* @retval : None
*/
void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
{
 80061f6:	b082      	sub	sp, #8
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
 80061f8:	2300      	movs	r3, #0
 80061fa:	9300      	str	r3, [sp, #0]
  doeptsize0.b.supcnt = 3;
 80061fc:	23c0      	movs	r3, #192	; 0xc0
 80061fe:	f88d 3003 	strb.w	r3, [sp, #3]
  doeptsize0.b.pktcnt = 1;
 8006202:	2201      	movs	r2, #1
 8006204:	f04f 0300 	mov.w	r3, #0
 8006208:	f362 03c4 	bfi	r3, r2, #3, #2
 800620c:	f88d 3002 	strb.w	r3, [sp, #2]
  doeptsize0.b.xfersize = 8 * 3;
 8006210:	2318      	movs	r3, #24
 8006212:	f88d 3000 	strb.w	r3, [sp]
  USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
 8006216:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8006218:	9a00      	ldr	r2, [sp, #0]
 800621a:	611a      	str	r2, [r3, #16]
  
  if (pdev->cfg.dma_enable == 1)
 800621c:	78c2      	ldrb	r2, [r0, #3]
 800621e:	2a01      	cmp	r2, #1
 8006220:	d106      	bne.n	8006230 <USB_OTG_EP0_OutStart+0x3a>
  {
    USB_OTG_DEPCTL_TypeDef  doepctl;
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
 8006222:	f200 50cc 	addw	r0, r0, #1484	; 0x5cc
 8006226:	6158      	str	r0, [r3, #20]
                        (uint32_t)&pdev->dev.setup_packet);
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
 8006228:	681a      	ldr	r2, [r3, #0]
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 800622a:	f04f 2280 	mov.w	r2, #2147516416	; 0x80008000
 800622e:	601a      	str	r2, [r3, #0]
  }
}
 8006230:	b002      	add	sp, #8
 8006232:	4770      	bx	lr

08006234 <USB_OTG_UngateClock>:
* @param  None
* @retval : None
*/
void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
{
  if(pdev->cfg.low_power)
 8006234:	7a83      	ldrb	r3, [r0, #10]
 8006236:	b163      	cbz	r3, 8006252 <USB_OTG_UngateClock+0x1e>
  {
    
    USB_OTG_DSTS_TypeDef     dsts;
    USB_OTG_PCGCCTL_TypeDef  power; 
    
    dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8006238:	6903      	ldr	r3, [r0, #16]
 800623a:	689b      	ldr	r3, [r3, #8]
    
    if(dsts.b.suspsts == 1)
 800623c:	07db      	lsls	r3, r3, #31
 800623e:	d508      	bpl.n	8006252 <USB_OTG_UngateClock+0x1e>
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 8006240:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
      power.b.gatehclk = 0;
      power.b.stoppclk = 0;
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8006244:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
    
    if(dsts.b.suspsts == 1)
    {
      /* un-gate USB Core clock */
      power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
      power.b.gatehclk = 0;
 8006248:	f36f 0341 	bfc	r3, #1, #1
      power.b.stoppclk = 0;
 800624c:	f36f 0300 	bfc	r3, #0, #1
      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 8006250:	6013      	str	r3, [r2, #0]
 8006252:	4770      	bx	lr

08006254 <USB_OTG_StopDevice>:
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
 8006254:	2301      	movs	r3, #1
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 8006256:	b510      	push	{r4, lr}
  uint32_t i;
  
  pdev->dev.device_status = 1;
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8006258:	2200      	movs	r2, #0
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
 800625a:	f880 3112 	strb.w	r3, [r0, #274]	; 0x112
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
{
 800625e:	4604      	mov	r4, r0
 8006260:	4603      	mov	r3, r0
  uint32_t i;
  
  pdev->dev.device_status = 1;
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8006262:	7861      	ldrb	r1, [r4, #1]
 8006264:	428a      	cmp	r2, r1
 8006266:	f103 0304 	add.w	r3, r3, #4
 800626a:	d206      	bcs.n	800627a <USB_OTG_StopDevice+0x26>
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 800626c:	6958      	ldr	r0, [r3, #20]
 800626e:	21ff      	movs	r1, #255	; 0xff
 8006270:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8006272:	6d18      	ldr	r0, [r3, #80]	; 0x50
{
  uint32_t i;
  
  pdev->dev.device_status = 1;
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 8006274:	3201      	adds	r2, #1
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8006276:	6081      	str	r1, [r0, #8]
 8006278:	e7f3      	b.n	8006262 <USB_OTG_StopDevice+0xe>
  }
  
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 800627a:	6923      	ldr	r3, [r4, #16]
 800627c:	2200      	movs	r2, #0
 800627e:	611a      	str	r2, [r3, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 8006280:	615a      	str	r2, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 8006282:	61da      	str	r2, [r3, #28]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 8006284:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 8006288:	4620      	mov	r0, r4
  }
  
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
 800628a:	619a      	str	r2, [r3, #24]
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 800628c:	f7ff fd32 	bl	8005cf4 <USB_OTG_FlushRxFifo>
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 8006290:	4620      	mov	r0, r4
 8006292:	2110      	movs	r1, #16
}
 8006294:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 8006298:	f7ff bd0c 	b.w	8005cb4 <USB_OTG_FlushTxFifo>

0800629c <DCD_Init>:



void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
              USB_OTG_CORE_ID_TypeDef coreID)
{
 800629c:	b510      	push	{r4, lr}
 800629e:	4604      	mov	r4, r0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
 80062a0:	f7ff fc4a 	bl	8005b38 <USB_OTG_SelectCore>
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 80062a4:	2301      	movs	r3, #1
  pdev->dev.device_address = 0;
 80062a6:	2200      	movs	r2, #0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 80062a8:	f884 3112 	strb.w	r3, [r4, #274]	; 0x112
  pdev->dev.device_address = 0;
 80062ac:	f884 2114 	strb.w	r2, [r4, #276]	; 0x114
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80062b0:	4623      	mov	r3, r4
 80062b2:	7861      	ldrb	r1, [r4, #1]
 80062b4:	428a      	cmp	r2, r1
 80062b6:	f103 0328 	add.w	r3, r3, #40	; 0x28
 80062ba:	d212      	bcs.n	80062e2 <DCD_Init+0x46>
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
 80062bc:	2101      	movs	r1, #1
 80062be:	f883 10f5 	strb.w	r1, [r3, #245]	; 0xf5
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 80062c2:	2040      	movs	r0, #64	; 0x40
    /* Init ep structure */
    ep->is_in = 1;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 80062c4:	2100      	movs	r1, #0
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    ep = &pdev->dev.in_ep[i];
    /* Init ep structure */
    ep->is_in = 1;
    ep->num = i;
 80062c6:	f883 20f4 	strb.w	r2, [r3, #244]	; 0xf4
    ep->tx_fifo_num = i;
 80062ca:	f8a3 20fa 	strh.w	r2, [r3, #250]	; 0xfa
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 80062ce:	f883 10f7 	strb.w	r1, [r3, #247]	; 0xf7
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 80062d2:	f8c3 00fc 	str.w	r0, [r3, #252]	; 0xfc
    ep->xfer_buff = 0;
 80062d6:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    ep->xfer_len = 0;
 80062da:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
  pdev->dev.device_address = 0;
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 80062de:	3201      	adds	r2, #1
 80062e0:	e7e7      	b.n	80062b2 <DCD_Init+0x16>
 80062e2:	4623      	mov	r3, r4
 80062e4:	2200      	movs	r2, #0
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80062e6:	7861      	ldrb	r1, [r4, #1]
 80062e8:	428a      	cmp	r2, r1
 80062ea:	f103 0328 	add.w	r3, r3, #40	; 0x28
 80062ee:	d211      	bcs.n	8006314 <DCD_Init+0x78>
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 80062f0:	2100      	movs	r1, #0
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 80062f2:	2040      	movs	r0, #64	; 0x40
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
    ep->num = i;
 80062f4:	f883 234c 	strb.w	r2, [r3, #844]	; 0x34c
    ep->tx_fifo_num = i;
 80062f8:	f8a3 2352 	strh.w	r2, [r3, #850]	; 0x352
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 80062fc:	f883 134d 	strb.w	r1, [r3, #845]	; 0x34d
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
 8006300:	f883 134f 	strb.w	r1, [r3, #847]	; 0x34f
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 8006304:	f8c3 0354 	str.w	r0, [r3, #852]	; 0x354
    ep->xfer_buff = 0;
 8006308:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
    ep->xfer_len = 0;
 800630c:	f8c3 1360 	str.w	r1, [r3, #864]	; 0x360
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8006310:	3201      	adds	r2, #1
 8006312:	e7e8      	b.n	80062e6 <DCD_Init+0x4a>
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  USB_OTG_DisableGlobalInt(pdev);
 8006314:	4620      	mov	r0, r4
 8006316:	f7ff fcc5 	bl	8005ca4 <USB_OTG_DisableGlobalInt>
  
  /*Init the Core (common init.) */
  USB_OTG_CoreInit(pdev);
 800631a:	4620      	mov	r0, r4
 800631c:	f7ff fc74 	bl	8005c08 <USB_OTG_CoreInit>


  /* Force Device Mode*/
  USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
 8006320:	4620      	mov	r0, r4
 8006322:	2100      	movs	r1, #0
 8006324:	f7ff fd02 	bl	8005d2c <USB_OTG_SetCurrentMode>
  
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
 8006328:	4620      	mov	r0, r4
 800632a:	f7ff fd45 	bl	8005db8 <USB_OTG_CoreInitDev>
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 800632e:	4620      	mov	r0, r4
}
 8006330:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 8006334:	f7ff bcaf 	b.w	8005c96 <USB_OTG_EnableGlobalInt>

08006338 <DCD_EP_Open>:
*/
uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
                     uint8_t ep_addr,
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
 8006338:	b570      	push	{r4, r5, r6, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 800633a:	b2cd      	uxtb	r5, r1
 800633c:	f015 0f80 	tst.w	r5, #128	; 0x80
 8006340:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 8006344:	f04f 0628 	mov.w	r6, #40	; 0x28
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8006348:	bf15      	itete	ne
 800634a:	fb06 0104 	mlane	r1, r6, r4, r0
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 800634e:	fb06 0101 	mlaeq	r1, r6, r1, r0
{
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8006352:	f501 718e 	addne.w	r1, r1, #284	; 0x11c
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8006356:	f501 715d 	addeq.w	r1, r1, #884	; 0x374
  }
  ep->num   = ep_addr & 0x7F;
 800635a:	b2e4      	uxtb	r4, r4
  
  ep->is_in = (0x80 & ep_addr) != 0;
 800635c:	09ed      	lsrs	r5, r5, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 800635e:	700c      	strb	r4, [r1, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8006360:	704d      	strb	r5, [r1, #1]
  ep->maxpacket = ep_mps;
 8006362:	608a      	str	r2, [r1, #8]
  ep->type = ep_type;
 8006364:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in)
 8006366:	b105      	cbz	r5, 800636a <DCD_EP_Open+0x32>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8006368:	80cc      	strh	r4, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == USB_OTG_EP_BULK )
 800636a:	2b02      	cmp	r3, #2
  {
    ep->data_pid_start = 0;
 800636c:	bf04      	itt	eq
 800636e:	2300      	moveq	r3, #0
 8006370:	710b      	strbeq	r3, [r1, #4]
  }
  USB_OTG_EPActivate(pdev , ep );
 8006372:	f7ff fdba 	bl	8005eea <USB_OTG_EPActivate>
  return 0;
}
 8006376:	2000      	movs	r0, #0
 8006378:	bd70      	pop	{r4, r5, r6, pc}

0800637a <DCD_EP_Close>:
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 800637a:	b2cb      	uxtb	r3, r1
 800637c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8006380:	f001 027f 	and.w	r2, r1, #127	; 0x7f
* @param pdev: device instance
* @param ep_addr: endpoint address
* @retval : status
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
 8006384:	b510      	push	{r4, lr}
 8006386:	f04f 0428 	mov.w	r4, #40	; 0x28
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 800638a:	bf15      	itete	ne
 800638c:	fb04 0102 	mlane	r1, r4, r2, r0
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8006390:	fb04 0101 	mlaeq	r1, r4, r1, r0
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 8006394:	f501 718e 	addne.w	r1, r1, #284	; 0x11c
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 8006398:	f501 715d 	addeq.w	r1, r1, #884	; 0x374
  }
  ep->num   = ep_addr & 0x7F;
  ep->is_in = (0x80 & ep_addr) != 0;
 800639c:	09db      	lsrs	r3, r3, #7
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 800639e:	700a      	strb	r2, [r1, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 80063a0:	704b      	strb	r3, [r1, #1]
  USB_OTG_EPDeactivate(pdev , ep );
 80063a2:	f7ff fdce 	bl	8005f42 <USB_OTG_EPDeactivate>
  return 0;
}
 80063a6:	2000      	movs	r0, #0
 80063a8:	bd10      	pop	{r4, pc}

080063aa <DCD_EP_PrepareRx>:
*/
uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
                            uint8_t   ep_addr,
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
 80063aa:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 80063ac:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 80063b0:	2528      	movs	r5, #40	; 0x28
 80063b2:	fb05 0504 	mla	r5, r5, r4, r0
 80063b6:	f505 715d 	add.w	r1, r5, #884	; 0x374
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
  ep->xfer_len = buf_len;
 80063ba:	614b      	str	r3, [r1, #20]
  ep->xfer_count = 0;
 80063bc:	2300      	movs	r3, #0
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 80063be:	60ca      	str	r2, [r1, #12]
  ep->xfer_len = buf_len;
  ep->xfer_count = 0;
 80063c0:	618b      	str	r3, [r1, #24]
  ep->is_in = 0;
 80063c2:	704b      	strb	r3, [r1, #1]
  ep->num = ep_addr & 0x7F;
 80063c4:	f885 4374 	strb.w	r4, [r5, #884]	; 0x374
  
  if (pdev->cfg.dma_enable == 1)
 80063c8:	78c3      	ldrb	r3, [r0, #3]
 80063ca:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pbuf;  
 80063cc:	bf08      	it	eq
 80063ce:	610a      	streq	r2, [r1, #16]
  }
  
  if ( ep->num == 0 )
 80063d0:	b914      	cbnz	r4, 80063d8 <DCD_EP_PrepareRx+0x2e>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 80063d2:	f7ff fe57 	bl	8006084 <USB_OTG_EP0StartXfer>
 80063d6:	e001      	b.n	80063dc <DCD_EP_PrepareRx+0x32>
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 80063d8:	f7ff fdd2 	bl	8005f80 <USB_OTG_EPStartXfer>
  }
  return 0;
}
 80063dc:	2000      	movs	r0, #0
 80063de:	bd38      	pop	{r3, r4, r5, pc}

080063e0 <DCD_EP_Tx>:
*/
uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
                     uint8_t   ep_addr,
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
 80063e0:	b570      	push	{r4, r5, r6, lr}
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 80063e2:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 80063e6:	2528      	movs	r5, #40	; 0x28
 80063e8:	fb05 0504 	mla	r5, r5, r4, r0
 80063ec:	f505 718e 	add.w	r1, r5, #284	; 0x11c
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 80063f0:	2601      	movs	r6, #1
 80063f2:	704e      	strb	r6, [r1, #1]
  ep->num = ep_addr & 0x7F;  
 80063f4:	f885 411c 	strb.w	r4, [r5, #284]	; 0x11c
  ep->xfer_buff = pbuf;
 80063f8:	60ca      	str	r2, [r1, #12]
  ep->dma_addr = (uint32_t)pbuf;  
 80063fa:	610a      	str	r2, [r1, #16]
  ep->xfer_count = 0;
 80063fc:	2200      	movs	r2, #0
 80063fe:	618a      	str	r2, [r1, #24]
  ep->xfer_len  = buf_len;
 8006400:	614b      	str	r3, [r1, #20]
  
  if ( ep->num == 0 )
 8006402:	b914      	cbnz	r4, 800640a <DCD_EP_Tx+0x2a>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 8006404:	f7ff fe3e 	bl	8006084 <USB_OTG_EP0StartXfer>
 8006408:	e001      	b.n	800640e <DCD_EP_Tx+0x2e>
  }
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
 800640a:	f7ff fdb9 	bl	8005f80 <USB_OTG_EPStartXfer>
  }
  return 0;
}
 800640e:	2000      	movs	r0, #0
 8006410:	bd70      	pop	{r4, r5, r6, pc}

08006412 <DCD_EP_Stall>:
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8006412:	b2cb      	uxtb	r3, r1
 8006414:	f013 0f80 	tst.w	r3, #128	; 0x80
 8006418:	f001 027f 	and.w	r2, r1, #127	; 0x7f
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
 800641c:	b510      	push	{r4, lr}
 800641e:	f04f 0428 	mov.w	r4, #40	; 0x28
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
 8006422:	bf15      	itete	ne
 8006424:	fb04 0102 	mlane	r1, r4, r2, r0
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8006428:	fb04 0101 	mlaeq	r1, r4, r1, r0
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
 800642c:	f501 718e 	addne.w	r1, r1, #284	; 0x11c
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8006430:	f501 715d 	addeq.w	r1, r1, #884	; 0x374
  }

  ep->is_stall = 1;
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 8006434:	09db      	lsrs	r3, r3, #7
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }

  ep->is_stall = 1;
 8006436:	2401      	movs	r4, #1
 8006438:	708c      	strb	r4, [r1, #2]
  ep->num   = epnum & 0x7F;
 800643a:	700a      	strb	r2, [r1, #0]
  ep->is_in = ((epnum & 0x80) == 0x80);
 800643c:	704b      	strb	r3, [r1, #1]
  
  USB_OTG_EPSetStall(pdev , ep);
 800643e:	f7ff fe9d 	bl	800617c <USB_OTG_EPSetStall>
  return (0);
}
 8006442:	2000      	movs	r0, #0
 8006444:	bd10      	pop	{r4, pc}

08006446 <DCD_EP_ClrStall>:
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 8006446:	b2cb      	uxtb	r3, r1
 8006448:	f013 0f80 	tst.w	r3, #128	; 0x80
 800644c:	f001 027f 	and.w	r2, r1, #127	; 0x7f
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
 8006450:	b510      	push	{r4, lr}
 8006452:	f04f 0428 	mov.w	r4, #40	; 0x28
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8006456:	bf15      	itete	ne
 8006458:	fb04 0102 	mlane	r1, r4, r2, r0
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 800645c:	fb04 0101 	mlaeq	r1, r4, r1, r0
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 8006460:	f501 718e 	addne.w	r1, r1, #284	; 0x11c
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 8006464:	f501 715d 	addeq.w	r1, r1, #884	; 0x374
  }
  
  ep->is_stall = 0;  
 8006468:	2400      	movs	r4, #0
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 800646a:	09db      	lsrs	r3, r3, #7
  else
  {
    ep = &pdev->dev.out_ep[epnum];
  }
  
  ep->is_stall = 0;  
 800646c:	708c      	strb	r4, [r1, #2]
  ep->num   = epnum & 0x7F;
 800646e:	700a      	strb	r2, [r1, #0]
  ep->is_in = ((epnum & 0x80) == 0x80);
 8006470:	704b      	strb	r3, [r1, #1]
  
  USB_OTG_EPClearStall(pdev , ep);
 8006472:	f7ff fe97 	bl	80061a4 <USB_OTG_EPClearStall>
  return (0);
}
 8006476:	4620      	mov	r0, r4
 8006478:	bd10      	pop	{r4, pc}

0800647a <DCD_EP_Flush>:
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
 800647a:	b508      	push	{r3, lr}

  if ((epnum & 0x80) == 0x80)
 800647c:	060b      	lsls	r3, r1, #24
 800647e:	d504      	bpl.n	800648a <DCD_EP_Flush+0x10>
  {
    USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
 8006480:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8006484:	f7ff fc16 	bl	8005cb4 <USB_OTG_FlushTxFifo>
 8006488:	e001      	b.n	800648e <DCD_EP_Flush+0x14>
  }
  else
  {
    USB_OTG_FlushRxFifo(pdev);
 800648a:	f7ff fc33 	bl	8005cf4 <USB_OTG_FlushRxFifo>
  }

  return (0);
}
 800648e:	2000      	movs	r0, #0
 8006490:	bd08      	pop	{r3, pc}

08006492 <DCD_EP_SetAddress>:
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 8006492:	6902      	ldr	r2, [r0, #16]
* @retval : status
*/
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
 8006494:	2300      	movs	r3, #0
  dcfg.b.devaddr = address;
 8006496:	f361 130a 	bfi	r3, r1, #4, #7
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 800649a:	6811      	ldr	r1, [r2, #0]
 800649c:	430b      	orrs	r3, r1
 800649e:	6013      	str	r3, [r2, #0]
 80064a0:	4770      	bx	lr

080064a2 <DCD_DevDisconnect>:
*/
void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
{
#ifndef USE_OTG_MODE
  USB_OTG_DCTL_TypeDef  dctl;
  dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 80064a2:	6903      	ldr	r3, [r0, #16]
 80064a4:	685a      	ldr	r2, [r3, #4]
  /* Disconnect device for 3ms */
  dctl.b.sftdiscon  = 1;
 80064a6:	f042 0202 	orr.w	r2, r2, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
 80064aa:	605a      	str	r2, [r3, #4]
  USB_OTG_BSP_mDelay(3);
 80064ac:	2003      	movs	r0, #3
 80064ae:	f7fe b9d7 	b.w	8004860 <USB_OTG_BSP_mDelay>
	...

080064b4 <USBD_OTG_ISR_Handler>:
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 80064b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80064b8:	b085      	sub	sp, #20
 80064ba:	4604      	mov	r4, r0
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
 80064bc:	f7ff fc4b 	bl	8005d56 <USB_OTG_IsDeviceMode>
 80064c0:	b908      	cbnz	r0, 80064c6 <USBD_OTG_ISR_Handler+0x12>
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
 80064c2:	2000      	movs	r0, #0
 80064c4:	e204      	b.n	80068d0 <USBD_OTG_ISR_Handler+0x41c>
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
  {
    gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
 80064c6:	4620      	mov	r0, r4
 80064c8:	f7ff fc4c 	bl	8005d64 <USB_OTG_ReadCoreItr>
    if (!gintr_status.d32) /* avoid spurious interrupt */
 80064cc:	4607      	mov	r7, r0
 80064ce:	2800      	cmp	r0, #0
 80064d0:	d0f7      	beq.n	80064c2 <USBD_OTG_ISR_Handler+0xe>
    {
      return 0;
    }
    
    if (gintr_status.b.outepintr)
 80064d2:	f3c0 40c0 	ubfx	r0, r0, #19, #1
 80064d6:	2800      	cmp	r0, #0
 80064d8:	d04f      	beq.n	800657a <USBD_OTG_ISR_Handler+0xc6>
  uint32_t epnum = 0;
  
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
 80064da:	4620      	mov	r0, r4
 80064dc:	f7ff fe77 	bl	80061ce <USB_OTG_ReadDevAllOutEp_itr>
 80064e0:	4626      	mov	r6, r4
 80064e2:	4680      	mov	r8, r0
 80064e4:	46a1      	mov	r9, r4
static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t ep_intr;
  USB_OTG_DOEPINTn_TypeDef  doepint;
  USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
  uint32_t epnum = 0;
 80064e6:	f04f 0a00 	mov.w	sl, #0
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
  
  while ( ep_intr )
 80064ea:	f1b8 0f00 	cmp.w	r8, #0
 80064ee:	d043      	beq.n	8006578 <USBD_OTG_ISR_Handler+0xc4>
  {
    if (ep_intr&0x1)
 80064f0:	f018 0f01 	tst.w	r8, #1
 80064f4:	d038      	beq.n	8006568 <USBD_OTG_ISR_Handler+0xb4>
    {
      
      doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
 80064f6:	fa5f fb8a 	uxtb.w	fp, sl
 80064fa:	4620      	mov	r0, r4
 80064fc:	4659      	mov	r1, fp
 80064fe:	f7ff fe6c 	bl	80061da <USB_OTG_ReadDevOutEP_itr>
      
      /* Transfer complete */
      if ( doepint.b.xfercompl )
 8006502:	07c2      	lsls	r2, r0, #31
  while ( ep_intr )
  {
    if (ep_intr&0x1)
    {
      
      doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
 8006504:	4605      	mov	r5, r0
      
      /* Transfer complete */
      if ( doepint.b.xfercompl )
 8006506:	d520      	bpl.n	800654a <USBD_OTG_ISR_Handler+0x96>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
 8006508:	6d73      	ldr	r3, [r6, #84]	; 0x54
 800650a:	2501      	movs	r5, #1
 800650c:	609d      	str	r5, [r3, #8]
        if (pdev->cfg.dma_enable == 1)
 800650e:	78e2      	ldrb	r2, [r4, #3]
 8006510:	42aa      	cmp	r2, r5
 8006512:	d107      	bne.n	8006524 <USBD_OTG_ISR_Handler+0x70>
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
 8006514:	691a      	ldr	r2, [r3, #16]
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 8006516:	f8d9 337c 	ldr.w	r3, [r9, #892]	; 0x37c
            deptsiz.b.xfersize;
 800651a:	f3c2 0212 	ubfx	r2, r2, #0, #19
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
        if (pdev->cfg.dma_enable == 1)
        {
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
          /*ToDo : handle more than one single MPS size packet */
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 800651e:	1a9b      	subs	r3, r3, r2
 8006520:	f8c9 338c 	str.w	r3, [r9, #908]	; 0x38c
            deptsiz.b.xfersize;
        }
        /* Inform upper layer: data ready */
        /* RX COMPLETE */
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
 8006524:	4ba6      	ldr	r3, [pc, #664]	; (80067c0 <USBD_OTG_ISR_Handler+0x30c>)
 8006526:	681b      	ldr	r3, [r3, #0]
 8006528:	4620      	mov	r0, r4
 800652a:	681b      	ldr	r3, [r3, #0]
 800652c:	4659      	mov	r1, fp
 800652e:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 8006530:	78e3      	ldrb	r3, [r4, #3]
 8006532:	2b01      	cmp	r3, #1
 8006534:	d109      	bne.n	800654a <USBD_OTG_ISR_Handler+0x96>
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_OUT))
 8006536:	f1ba 0f00 	cmp.w	sl, #0
 800653a:	d106      	bne.n	800654a <USBD_OTG_ISR_Handler+0x96>
 800653c:	f894 3111 	ldrb.w	r3, [r4, #273]	; 0x111
 8006540:	2b05      	cmp	r3, #5
 8006542:	d102      	bne.n	800654a <USBD_OTG_ISR_Handler+0x96>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 8006544:	4620      	mov	r0, r4
 8006546:	f7ff fe56 	bl	80061f6 <USB_OTG_EP0_OutStart>
          }
        }        
      }
      /* Endpoint disable  */
      if ( doepint.b.epdisabled )
 800654a:	07ab      	lsls	r3, r5, #30
 800654c:	d502      	bpl.n	8006554 <USBD_OTG_ISR_Handler+0xa0>
      {
        /* Clear the bit in DOEPINTn for this interrupt */
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
 800654e:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8006550:	2502      	movs	r5, #2
 8006552:	609d      	str	r5, [r3, #8]
      }
      /* Setup Phase Done (control EPs) */
      if ( doepint.b.setup )
 8006554:	0728      	lsls	r0, r5, #28
 8006556:	d507      	bpl.n	8006568 <USBD_OTG_ISR_Handler+0xb4>
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 8006558:	4b99      	ldr	r3, [pc, #612]	; (80067c0 <USBD_OTG_ISR_Handler+0x30c>)
 800655a:	681b      	ldr	r3, [r3, #0]
 800655c:	4620      	mov	r0, r4
 800655e:	689b      	ldr	r3, [r3, #8]
 8006560:	4798      	blx	r3
        CLEAR_OUT_EP_INTR(epnum, setup);
 8006562:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8006564:	2508      	movs	r5, #8
 8006566:	609d      	str	r5, [r3, #8]
      }
    }
    epnum++;
 8006568:	f10a 0a01 	add.w	sl, sl, #1
    ep_intr >>= 1;
 800656c:	ea4f 0858 	mov.w	r8, r8, lsr #1
 8006570:	3604      	adds	r6, #4
 8006572:	f109 0928 	add.w	r9, r9, #40	; 0x28
 8006576:	e7b8      	b.n	80064ea <USBD_OTG_ISR_Handler+0x36>
      return 0;
    }
    
    if (gintr_status.b.outepintr)
    {
      retval |= DCD_HandleOutEP_ISR(pdev);
 8006578:	2001      	movs	r0, #1
    }    
    
    if (gintr_status.b.inepint)
 800657a:	0379      	lsls	r1, r7, #13
 800657c:	f140 80a3 	bpl.w	80066c6 <USBD_OTG_ISR_Handler+0x212>
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
 8006580:	4620      	mov	r0, r4
 8006582:	f7ff fe32 	bl	80061ea <USB_OTG_ReadDevAllInEPItr>
 8006586:	46a0      	mov	r8, r4
 8006588:	4682      	mov	sl, r0
 800658a:	4626      	mov	r6, r4
static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_DIEPINTn_TypeDef  diepint;
  
  uint32_t ep_intr;
  uint32_t epnum = 0;
 800658c:	f04f 0900 	mov.w	r9, #0
  uint32_t fifoemptymsk;
  diepint.d32 = 0;
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
  
  while ( ep_intr )
 8006590:	f1ba 0f00 	cmp.w	sl, #0
 8006594:	f000 8096 	beq.w	80066c4 <USBD_OTG_ISR_Handler+0x210>
  {
    if (ep_intr&0x1) /* In ITR */
 8006598:	f01a 0f01 	tst.w	sl, #1
 800659c:	f000 808a 	beq.w	80066b4 <USBD_OTG_ISR_Handler+0x200>
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 80065a0:	6923      	ldr	r3, [r4, #16]
  
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
 80065a2:	fa5f fb89 	uxtb.w	fp, r9
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 80065a6:	6919      	ldr	r1, [r3, #16]
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
 80065a8:	6b5d      	ldr	r5, [r3, #52]	; 0x34
  msk |= ((emp >> epnum) & 0x1) << 7;
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 80065aa:	eb04 028b 	add.w	r2, r4, fp, lsl #2
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 80065ae:	fa25 f50b 	lsr.w	r5, r5, fp
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 80065b2:	6992      	ldr	r2, [r2, #24]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 80065b4:	01ed      	lsls	r5, r5, #7
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 80065b6:	6892      	ldr	r2, [r2, #8]
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
  msk |= ((emp >> epnum) & 0x1) << 7;
 80065b8:	b2ed      	uxtb	r5, r5
 80065ba:	430d      	orrs	r5, r1
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 80065bc:	4015      	ands	r5, r2
  while ( ep_intr )
  {
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
 80065be:	07ea      	lsls	r2, r5, #31
 80065c0:	d51c      	bpl.n	80065fc <USBD_OTG_ISR_Handler+0x148>
      {
        fifoemptymsk = 0x1 << epnum;
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 80065c2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    if (ep_intr&0x1) /* In ITR */
    {
      diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
      if ( diepint.b.xfercompl )
      {
        fifoemptymsk = 0x1 << epnum;
 80065c4:	2501      	movs	r5, #1
 80065c6:	fa05 f109 	lsl.w	r1, r5, r9
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 80065ca:	ea22 0201 	bic.w	r2, r2, r1
 80065ce:	635a      	str	r2, [r3, #52]	; 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 80065d0:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80065d4:	609d      	str	r5, [r3, #8]
        /* TX COMPLETE */
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 80065d6:	4b7a      	ldr	r3, [pc, #488]	; (80067c0 <USBD_OTG_ISR_Handler+0x30c>)
 80065d8:	681b      	ldr	r3, [r3, #0]
 80065da:	4620      	mov	r0, r4
 80065dc:	685b      	ldr	r3, [r3, #4]
 80065de:	4659      	mov	r1, fp
 80065e0:	4798      	blx	r3
        
        if (pdev->cfg.dma_enable == 1)
 80065e2:	78e3      	ldrb	r3, [r4, #3]
 80065e4:	42ab      	cmp	r3, r5
 80065e6:	d109      	bne.n	80065fc <USBD_OTG_ISR_Handler+0x148>
        {
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_IN))
 80065e8:	f1b9 0f00 	cmp.w	r9, #0
 80065ec:	d106      	bne.n	80065fc <USBD_OTG_ISR_Handler+0x148>
 80065ee:	f894 3111 	ldrb.w	r3, [r4, #273]	; 0x111
 80065f2:	2b04      	cmp	r3, #4
 80065f4:	d102      	bne.n	80065fc <USBD_OTG_ISR_Handler+0x148>
          {
            /* prepare to rx more setup packets */
            USB_OTG_EP0_OutStart(pdev);
 80065f6:	4620      	mov	r0, r4
 80065f8:	f7ff fdfd 	bl	80061f6 <USB_OTG_EP0_OutStart>
          }
        }           
      }
      if ( diepint.b.timeout )
 80065fc:	072b      	lsls	r3, r5, #28
 80065fe:	d503      	bpl.n	8006608 <USBD_OTG_ISR_Handler+0x154>
      {
        CLEAR_IN_EP_INTR(epnum, timeout);
 8006600:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8006604:	2508      	movs	r5, #8
 8006606:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.intktxfemp)
 8006608:	06e8      	lsls	r0, r5, #27
 800660a:	d503      	bpl.n	8006614 <USBD_OTG_ISR_Handler+0x160>
      {
        CLEAR_IN_EP_INTR(epnum, intktxfemp);
 800660c:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8006610:	2510      	movs	r5, #16
 8006612:	609d      	str	r5, [r3, #8]
      }
      if (diepint.b.inepnakeff)
 8006614:	0669      	lsls	r1, r5, #25
 8006616:	d503      	bpl.n	8006620 <USBD_OTG_ISR_Handler+0x16c>
      {
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
 8006618:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800661c:	2540      	movs	r5, #64	; 0x40
 800661e:	609d      	str	r5, [r3, #8]
      }
      if ( diepint.b.epdisabled )
 8006620:	07aa      	lsls	r2, r5, #30
 8006622:	d503      	bpl.n	800662c <USBD_OTG_ISR_Handler+0x178>
      {
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 8006624:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8006628:	2502      	movs	r5, #2
 800662a:	609d      	str	r5, [r3, #8]
      }       
      if (diepint.b.emptyintr)
 800662c:	062b      	lsls	r3, r5, #24
 800662e:	d541      	bpl.n	80066b4 <USBD_OTG_ISR_Handler+0x200>
  uint32_t len32b;
  txstatus.d32 = 0;
  
  ep = &pdev->dev.in_ep[epnum];    
  
  len = ep->xfer_len - ep->xfer_count;
 8006630:	f8d6 3134 	ldr.w	r3, [r6, #308]	; 0x134
 8006634:	f8d6 2130 	ldr.w	r2, [r6, #304]	; 0x130
 8006638:	1ad2      	subs	r2, r2, r3
  
  if (len > ep->maxpacket)
 800663a:	f8d6 3124 	ldr.w	r3, [r6, #292]	; 0x124
 800663e:	429a      	cmp	r2, r3
 8006640:	bf38      	it	cc
 8006642:	4613      	movcc	r3, r2
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 8006644:	f103 0c03 	add.w	ip, r3, #3
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 8006648:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800664c:	699b      	ldr	r3, [r3, #24]
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }
  
  len32b = (len + 3) / 4;
 800664e:	ea4f 0c9c 	mov.w	ip, ip, lsr #2
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8006652:	b29b      	uxth	r3, r3
 8006654:	4563      	cmp	r3, ip
 8006656:	d929      	bls.n	80066ac <USBD_OTG_ISR_Handler+0x1f8>
          ep->xfer_count < ep->xfer_len &&
 8006658:	f8d6 5134 	ldr.w	r5, [r6, #308]	; 0x134
 800665c:	f8d6 3130 	ldr.w	r3, [r6, #304]	; 0x130
  len32b = (len + 3) / 4;
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
  
  
  
  while  (txstatus.b.txfspcavail > len32b &&
 8006660:	429d      	cmp	r5, r3
 8006662:	d223      	bcs.n	80066ac <USBD_OTG_ISR_Handler+0x1f8>
          ep->xfer_count < ep->xfer_len &&
 8006664:	b313      	cbz	r3, 80066ac <USBD_OTG_ISR_Handler+0x1f8>
            ep->xfer_len != 0)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
    
    if (len > ep->maxpacket)
 8006666:	f8d6 2124 	ldr.w	r2, [r6, #292]	; 0x124
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
 800666a:	f8d6 1128 	ldr.w	r1, [r6, #296]	; 0x128
  while  (txstatus.b.txfspcavail > len32b &&
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 800666e:	1b5d      	subs	r5, r3, r5
 8006670:	4295      	cmp	r5, r2
 8006672:	bf28      	it	cs
 8006674:	4615      	movcs	r5, r2
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3) / 4;
 8006676:	f105 0c03 	add.w	ip, r5, #3
 800667a:	ea4f 0c9c 	mov.w	ip, ip, lsr #2
    
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
 800667e:	b2ab      	uxth	r3, r5
 8006680:	4620      	mov	r0, r4
 8006682:	465a      	mov	r2, fp
 8006684:	f8cd c004 	str.w	ip, [sp, #4]
 8006688:	f7ff fa32 	bl	8005af0 <USB_OTG_WritePacket>
    
    ep->xfer_buff  += len;
 800668c:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
 8006690:	442b      	add	r3, r5
 8006692:	f8c6 3128 	str.w	r3, [r6, #296]	; 0x128
    ep->xfer_count += len;
 8006696:	f8d6 3134 	ldr.w	r3, [r6, #308]	; 0x134
 800669a:	441d      	add	r5, r3
 800669c:	f8c6 5134 	str.w	r5, [r6, #308]	; 0x134
    
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 80066a0:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80066a4:	f8dd c004 	ldr.w	ip, [sp, #4]
 80066a8:	699b      	ldr	r3, [r3, #24]
 80066aa:	e7d2      	b.n	8006652 <USBD_OTG_ISR_Handler+0x19e>
      if (diepint.b.emptyintr)
      {
        
        DCD_WriteEmptyTxFifo(pdev , epnum);
        
        CLEAR_IN_EP_INTR(epnum, emptyintr);
 80066ac:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80066b0:	2580      	movs	r5, #128	; 0x80
 80066b2:	609d      	str	r5, [r3, #8]
      }
    }
    epnum++;
 80066b4:	f109 0901 	add.w	r9, r9, #1
    ep_intr >>= 1;
 80066b8:	ea4f 0a5a 	mov.w	sl, sl, lsr #1
 80066bc:	f108 0804 	add.w	r8, r8, #4
 80066c0:	3628      	adds	r6, #40	; 0x28
 80066c2:	e765      	b.n	8006590 <USBD_OTG_ISR_Handler+0xdc>
      retval |= DCD_HandleOutEP_ISR(pdev);
    }    
    
    if (gintr_status.b.inepint)
    {
      retval |= DCD_HandleInEP_ISR(pdev);
 80066c4:	2001      	movs	r0, #1
    }
    
    if (gintr_status.b.modemismatch)
 80066c6:	07bd      	lsls	r5, r7, #30
 80066c8:	d502      	bpl.n	80066d0 <USBD_OTG_ISR_Handler+0x21c>
      USB_OTG_GINTSTS_TypeDef  gintsts;
      
      /* Clear interrupt */
      gintsts.d32 = 0;
      gintsts.b.modemismatch = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80066ca:	68e3      	ldr	r3, [r4, #12]
 80066cc:	2202      	movs	r2, #2
 80066ce:	615a      	str	r2, [r3, #20]
    }
    
    if (gintr_status.b.wkupintr)
 80066d0:	2f00      	cmp	r7, #0
 80066d2:	da19      	bge.n	8006708 <USBD_OTG_ISR_Handler+0x254>
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_DCTL_TypeDef     devctl;
  USB_OTG_PCGCCTL_TypeDef  power;
  
  if(pdev->cfg.low_power)
 80066d4:	7aa3      	ldrb	r3, [r4, #10]
 80066d6:	b143      	cbz	r3, 80066ea <USBD_OTG_ISR_Handler+0x236>
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 80066d8:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
    power.b.gatehclk = 0;
    power.b.stoppclk = 0;
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 80066dc:	f8d4 210c 	ldr.w	r2, [r4, #268]	; 0x10c
  
  if(pdev->cfg.low_power)
  {
    /* un-gate USB Core clock */
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
    power.b.gatehclk = 0;
 80066e0:	f36f 0341 	bfc	r3, #1, #1
    power.b.stoppclk = 0;
 80066e4:	f36f 0300 	bfc	r3, #0, #1
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 80066e8:	6013      	str	r3, [r2, #0]
  }
  
  /* Clear the Remote Wake-up Signaling */
  devctl.d32 = 0;
  devctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 80066ea:	6923      	ldr	r3, [r4, #16]
 80066ec:	685a      	ldr	r2, [r3, #4]
 80066ee:	f022 0201 	bic.w	r2, r2, #1
 80066f2:	605a      	str	r2, [r3, #4]
  
  /* Inform upper layer by the Resume Event */
  USBD_DCD_INT_fops->Resume (pdev);
 80066f4:	4b32      	ldr	r3, [pc, #200]	; (80067c0 <USBD_OTG_ISR_Handler+0x30c>)
 80066f6:	681b      	ldr	r3, [r3, #0]
 80066f8:	4620      	mov	r0, r4
 80066fa:	699b      	ldr	r3, [r3, #24]
 80066fc:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.wkupintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80066fe:	68e3      	ldr	r3, [r4, #12]
 8006700:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8006704:	615a      	str	r2, [r3, #20]
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
    }
    
    if (gintr_status.b.wkupintr)
    {
      retval |= DCD_HandleResume_ISR(pdev);
 8006706:	2001      	movs	r0, #1
    }
    
    if (gintr_status.b.usbsuspend)
 8006708:	0539      	lsls	r1, r7, #20
 800670a:	d52d      	bpl.n	8006768 <USBD_OTG_ISR_Handler+0x2b4>
static uint32_t DCD_HandleUSBSuspend_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_PCGCCTL_TypeDef  power;
  USB_OTG_DSTS_TypeDef     dsts;
  __IO uint8_t prev_status = 0;
 800670c:	2300      	movs	r3, #0
 800670e:	f88d 300f 	strb.w	r3, [sp, #15]
  
  prev_status = pdev->dev.device_status;
 8006712:	f894 3112 	ldrb.w	r3, [r4, #274]	; 0x112
 8006716:	f88d 300f 	strb.w	r3, [sp, #15]
  USBD_DCD_INT_fops->Suspend (pdev);      
 800671a:	4b29      	ldr	r3, [pc, #164]	; (80067c0 <USBD_OTG_ISR_Handler+0x30c>)
 800671c:	681b      	ldr	r3, [r3, #0]
 800671e:	4620      	mov	r0, r4
 8006720:	695b      	ldr	r3, [r3, #20]
 8006722:	4798      	blx	r3
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 8006724:	6923      	ldr	r3, [r4, #16]
 8006726:	689a      	ldr	r2, [r3, #8]
    
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8006728:	68e3      	ldr	r3, [r4, #12]
 800672a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800672e:	6159      	str	r1, [r3, #20]
  
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1)  && 
 8006730:	7aa3      	ldrb	r3, [r4, #10]
 8006732:	b1c3      	cbz	r3, 8006766 <USBD_OTG_ISR_Handler+0x2b2>
 8006734:	07d2      	lsls	r2, r2, #31
 8006736:	d516      	bpl.n	8006766 <USBD_OTG_ISR_Handler+0x2b2>
 8006738:	f894 3115 	ldrb.w	r3, [r4, #277]	; 0x115
 800673c:	2b01      	cmp	r3, #1
 800673e:	d112      	bne.n	8006766 <USBD_OTG_ISR_Handler+0x2b2>
    (pdev->dev.connection_status == 1) && 
    (prev_status  == USB_OTG_CONFIGURED))
 8006740:	f89d 300f 	ldrb.w	r3, [sp, #15]
  gintsts.d32 = 0;
  gintsts.b.usbsuspend = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
  
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1)  && 
    (pdev->dev.connection_status == 1) && 
 8006744:	2b03      	cmp	r3, #3
 8006746:	d10e      	bne.n	8006766 <USBD_OTG_ISR_Handler+0x2b2>
    (prev_status  == USB_OTG_CONFIGURED))
  {
	/*  switch-off the clocks */
    power.d32 = 0;
    power.b.stoppclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 8006748:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
 800674c:	681a      	ldr	r2, [r3, #0]
 800674e:	f042 0201 	orr.w	r2, r2, #1
 8006752:	601a      	str	r2, [r3, #0]
    
    power.b.gatehclk = 1;
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
 8006754:	681a      	ldr	r2, [r3, #0]
 8006756:	f042 0203 	orr.w	r2, r2, #3
 800675a:	601a      	str	r2, [r3, #0]
    
    /* Request to enter Sleep mode after exit from current ISR */
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 800675c:	4b19      	ldr	r3, [pc, #100]	; (80067c4 <USBD_OTG_ISR_Handler+0x310>)
 800675e:	691a      	ldr	r2, [r3, #16]
 8006760:	f042 0206 	orr.w	r2, r2, #6
 8006764:	611a      	str	r2, [r3, #16]
      retval |= DCD_HandleResume_ISR(pdev);
    }
    
    if (gintr_status.b.usbsuspend)
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
 8006766:	2001      	movs	r0, #1
    }
    if (gintr_status.b.sofintr)
 8006768:	073b      	lsls	r3, r7, #28
 800676a:	d508      	bpl.n	800677e <USBD_OTG_ISR_Handler+0x2ca>
static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  GINTSTS;
  
  
  USBD_DCD_INT_fops->SOF(pdev);
 800676c:	4b14      	ldr	r3, [pc, #80]	; (80067c0 <USBD_OTG_ISR_Handler+0x30c>)
 800676e:	681b      	ldr	r3, [r3, #0]
 8006770:	4620      	mov	r0, r4
 8006772:	68db      	ldr	r3, [r3, #12]
 8006774:	4798      	blx	r3
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 8006776:	68e3      	ldr	r3, [r4, #12]
 8006778:	2208      	movs	r2, #8
 800677a:	615a      	str	r2, [r3, #20]
    {
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
    }
    if (gintr_status.b.sofintr)
    {
      retval |= DCD_HandleSof_ISR(pdev);
 800677c:	2001      	movs	r0, #1
      
    }
    
    if (gintr_status.b.rxstsqlvl)
 800677e:	06fe      	lsls	r6, r7, #27
 8006780:	d536      	bpl.n	80067f0 <USBD_OTG_ISR_Handler+0x33c>
  USB_OTG_EP *ep;
  
  /* Disable the Rx Status Queue Level interrupt */
  int_mask.d32 = 0;
  int_mask.b.rxstsqlvl = 1;
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
 8006782:	68e3      	ldr	r3, [r4, #12]
 8006784:	699a      	ldr	r2, [r3, #24]
 8006786:	f022 0210 	bic.w	r2, r2, #16
 800678a:	619a      	str	r2, [r3, #24]
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
 800678c:	6a1e      	ldr	r6, [r3, #32]
  
  ep = &pdev->dev.out_ep[status.b.epnum];
 800678e:	2528      	movs	r5, #40	; 0x28
 8006790:	f006 030f 	and.w	r3, r6, #15
 8006794:	fb05 4503 	mla	r5, r5, r3, r4
  
  switch (status.b.pktsts)
 8006798:	f3c6 4343 	ubfx	r3, r6, #17, #4
 800679c:	2b02      	cmp	r3, #2
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
  
  ep = &pdev->dev.out_ep[status.b.epnum];
 800679e:	f505 755d 	add.w	r5, r5, #884	; 0x374
  
  switch (status.b.pktsts)
 80067a2:	d011      	beq.n	80067c8 <USBD_OTG_ISR_Handler+0x314>
 80067a4:	2b06      	cmp	r3, #6
 80067a6:	d11d      	bne.n	80067e4 <USBD_OTG_ISR_Handler+0x330>
    break;
  case STS_SETUP_COMP:
    break;
  case STS_SETUP_UPDT:
    /* Copy the setup packet received in FIFO into the setup buffer in RAM */
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 80067a8:	4620      	mov	r0, r4
 80067aa:	f204 51cc 	addw	r1, r4, #1484	; 0x5cc
 80067ae:	2208      	movs	r2, #8
 80067b0:	f7ff f9b1 	bl	8005b16 <USB_OTG_ReadPacket>
    ep->xfer_count += status.b.bcnt;
 80067b4:	69ab      	ldr	r3, [r5, #24]
 80067b6:	f3c6 160a 	ubfx	r6, r6, #4, #11
 80067ba:	4433      	add	r3, r6
 80067bc:	61ab      	str	r3, [r5, #24]
 80067be:	e011      	b.n	80067e4 <USBD_OTG_ISR_Handler+0x330>
 80067c0:	20000148 	.word	0x20000148
 80067c4:	e000ed00 	.word	0xe000ed00
  switch (status.b.pktsts)
  {
  case STS_GOUT_NAK:
    break;
  case STS_DATA_UPDT:
    if (status.b.bcnt)
 80067c8:	f3c6 160a 	ubfx	r6, r6, #4, #11
 80067cc:	b156      	cbz	r6, 80067e4 <USBD_OTG_ISR_Handler+0x330>
    {
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
 80067ce:	4632      	mov	r2, r6
 80067d0:	4620      	mov	r0, r4
 80067d2:	68e9      	ldr	r1, [r5, #12]
 80067d4:	f7ff f99f 	bl	8005b16 <USB_OTG_ReadPacket>
      ep->xfer_buff += status.b.bcnt;
 80067d8:	68eb      	ldr	r3, [r5, #12]
 80067da:	4433      	add	r3, r6
 80067dc:	60eb      	str	r3, [r5, #12]
      ep->xfer_count += status.b.bcnt;
 80067de:	69ab      	ldr	r3, [r5, #24]
 80067e0:	441e      	add	r6, r3
 80067e2:	61ae      	str	r6, [r5, #24]
  default:
    break;
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, int_mask.d32);
 80067e4:	68e3      	ldr	r3, [r4, #12]
 80067e6:	699a      	ldr	r2, [r3, #24]
 80067e8:	f042 0210 	orr.w	r2, r2, #16
 80067ec:	619a      	str	r2, [r3, #24]
      
    }
    
    if (gintr_status.b.rxstsqlvl)
    {
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
 80067ee:	2001      	movs	r0, #1
      
    }
    
    if (gintr_status.b.usbreset)
 80067f0:	04fd      	lsls	r5, r7, #19
 80067f2:	d535      	bpl.n	8006860 <USBD_OTG_ISR_Handler+0x3ac>
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 80067f4:	6923      	ldr	r3, [r4, #16]
 80067f6:	685a      	ldr	r2, [r3, #4]
  USB_OTG_DCFG_TypeDef     dcfg;
  USB_OTG_DCTL_TypeDef     dctl;
  USB_OTG_GINTSTS_TypeDef  gintsts;
  uint32_t i;
  
  dctl.d32 = 0;
 80067f8:	2500      	movs	r5, #0
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 80067fa:	f022 0201 	bic.w	r2, r2, #1
 80067fe:	605a      	str	r2, [r3, #4]
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
 8006800:	4620      	mov	r0, r4
 8006802:	4629      	mov	r1, r5
 8006804:	f7ff fa56 	bl	8005cb4 <USB_OTG_FlushTxFifo>
 8006808:	4623      	mov	r3, r4
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800680a:	462a      	mov	r2, r5
 800680c:	7861      	ldrb	r1, [r4, #1]
 800680e:	428a      	cmp	r2, r1
 8006810:	f103 0304 	add.w	r3, r3, #4
 8006814:	d206      	bcs.n	8006824 <USBD_OTG_ISR_Handler+0x370>
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 8006816:	6958      	ldr	r0, [r3, #20]
 8006818:	21ff      	movs	r1, #255	; 0xff
 800681a:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 800681c:	6d18      	ldr	r0, [r3, #80]	; 0x50
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 800681e:	3201      	adds	r2, #1
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 8006820:	6081      	str	r1, [r0, #8]
 8006822:	e7f3      	b.n	800680c <USBD_OTG_ISR_Handler+0x358>
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8006824:	6923      	ldr	r3, [r4, #16]
  
  daintmsk.ep.in = 1;
 8006826:	2601      	movs	r6, #1
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8006828:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  
  daintmsk.ep.in = 1;
 800682c:	f366 050f 	bfi	r5, r6, #0, #16
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 8006830:	619a      	str	r2, [r3, #24]
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
 8006832:	f366 451f 	bfi	r5, r6, #16, #16
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.epdisabled = 1;
 8006836:	220b      	movs	r2, #11
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
 8006838:	61dd      	str	r5, [r3, #28]
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 800683a:	615a      	str	r2, [r3, #20]
#endif
  diepmsk.b.xfercompl = 1;
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 800683c:	611a      	str	r2, [r3, #16]
#ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DINEP1MSK, diepmsk.d32 );
#endif
  /* Reset Device Address */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 800683e:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devaddr = 0;
 8006840:	f36f 120a 	bfc	r2, #4, #7
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32);
 8006844:	601a      	str	r2, [r3, #0]
  
  
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
 8006846:	4620      	mov	r0, r4
 8006848:	f7ff fcd5 	bl	80061f6 <USB_OTG_EP0_OutStart>
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 800684c:	68e3      	ldr	r3, [r4, #12]
 800684e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8006852:	615a      	str	r2, [r3, #20]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 8006854:	4b20      	ldr	r3, [pc, #128]	; (80068d8 <USBD_OTG_ISR_Handler+0x424>)
 8006856:	681b      	ldr	r3, [r3, #0]
 8006858:	4620      	mov	r0, r4
 800685a:	691b      	ldr	r3, [r3, #16]
 800685c:	4798      	blx	r3
      
    }
    
    if (gintr_status.b.usbreset)
    {
      retval |= DCD_HandleUsbReset_ISR(pdev);
 800685e:	4630      	mov	r0, r6
      
    }
    if (gintr_status.b.enumdone)
 8006860:	04b9      	lsls	r1, r7, #18
 8006862:	d51d      	bpl.n	80068a0 <USBD_OTG_ISR_Handler+0x3ec>
static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
 8006864:	4620      	mov	r0, r4
 8006866:	f7ff fb2b 	bl	8005ec0 <USB_OTG_EP0Activate>
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 800686a:	68e3      	ldr	r3, [r4, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 800686c:	4620      	mov	r0, r4
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 800686e:	68dd      	ldr	r5, [r3, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 8006870:	f7ff fb16 	bl	8005ea0 <USB_OTG_GetDeviceSpeed>
 8006874:	2803      	cmp	r0, #3
 8006876:	d106      	bne.n	8006886 <USBD_OTG_ISR_Handler+0x3d2>
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 8006878:	2300      	movs	r3, #0
 800687a:	70a3      	strb	r3, [r4, #2]
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 800687c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006880:	80a3      	strh	r3, [r4, #4]
    gusbcfg.b.usbtrdtim = 9;
 8006882:	2309      	movs	r3, #9
 8006884:	e004      	b.n	8006890 <USBD_OTG_ISR_Handler+0x3dc>
  }
  else
  {
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8006886:	2301      	movs	r3, #1
 8006888:	70a3      	strb	r3, [r4, #2]
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
 800688a:	2340      	movs	r3, #64	; 0x40
 800688c:	80a3      	strh	r3, [r4, #4]
    gusbcfg.b.usbtrdtim = 5;
 800688e:	2305      	movs	r3, #5
 8006890:	f363 258d 	bfi	r5, r3, #10, #4
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 8006894:	68e3      	ldr	r3, [r4, #12]
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
 8006896:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
    gusbcfg.b.usbtrdtim = 5;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 800689a:	60dd      	str	r5, [r3, #12]
      retval |= DCD_HandleUsbReset_ISR(pdev);
      
    }
    if (gintr_status.b.enumdone)
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
 800689c:	2001      	movs	r0, #1
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 800689e:	615a      	str	r2, [r3, #20]
    if (gintr_status.b.enumdone)
    {
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
 80068a0:	02fa      	lsls	r2, r7, #11
 80068a2:	d509      	bpl.n	80068b8 <USBD_OTG_ISR_Handler+0x404>
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
 80068a4:	4b0c      	ldr	r3, [pc, #48]	; (80068d8 <USBD_OTG_ISR_Handler+0x424>)
 80068a6:	681b      	ldr	r3, [r3, #0]
 80068a8:	4620      	mov	r0, r4
 80068aa:	69db      	ldr	r3, [r3, #28]
 80068ac:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80068ae:	68e3      	ldr	r3, [r4, #12]
 80068b0:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 80068b4:	615a      	str	r2, [r3, #20]
      retval |= DCD_HandleEnumDone_ISR(pdev);
    }
    
    if (gintr_status.b.incomplisoin)
    {
      retval |= DCD_IsoINIncomplete_ISR(pdev);
 80068b6:	2001      	movs	r0, #1
    }

    if (gintr_status.b.incomplisoout)
 80068b8:	02bb      	lsls	r3, r7, #10
 80068ba:	d509      	bpl.n	80068d0 <USBD_OTG_ISR_Handler+0x41c>
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
 80068bc:	4b06      	ldr	r3, [pc, #24]	; (80068d8 <USBD_OTG_ISR_Handler+0x424>)
 80068be:	681b      	ldr	r3, [r3, #0]
 80068c0:	4620      	mov	r0, r4
 80068c2:	6a1b      	ldr	r3, [r3, #32]
 80068c4:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80068c6:	68e3      	ldr	r3, [r4, #12]
 80068c8:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 80068cc:	615a      	str	r2, [r3, #20]
      retval |= DCD_IsoINIncomplete_ISR(pdev);
    }

    if (gintr_status.b.incomplisoout)
    {
      retval |= DCD_IsoOUTIncomplete_ISR(pdev);
 80068ce:	2001      	movs	r0, #1
      retval |= DCD_OTG_ISR(pdev);
    }   
#endif    
  }
  return retval;
}
 80068d0:	b005      	add	sp, #20
 80068d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80068d6:	bf00      	nop
 80068d8:	20000148 	.word	0x20000148

080068dc <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80068dc:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80068de:	f000 b804 	b.w	80068ea <LoopCopyDataInit>

080068e2 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80068e2:	4b0c      	ldr	r3, [pc, #48]	; (8006914 <LoopFillZerobss+0x12>)
  ldr  r3, [r3, r1]
 80068e4:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80068e6:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80068e8:	3104      	adds	r1, #4

080068ea <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80068ea:	480b      	ldr	r0, [pc, #44]	; (8006918 <LoopFillZerobss+0x16>)
  ldr  r3, =_edata
 80068ec:	4b0b      	ldr	r3, [pc, #44]	; (800691c <LoopFillZerobss+0x1a>)
  adds  r2, r0, r1
 80068ee:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80068f0:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80068f2:	f4ff aff6 	bcc.w	80068e2 <CopyDataInit>
  ldr  r2, =_sbss
 80068f6:	4a0a      	ldr	r2, [pc, #40]	; (8006920 <LoopFillZerobss+0x1e>)
  b  LoopFillZerobss
 80068f8:	f000 b803 	b.w	8006902 <LoopFillZerobss>

080068fc <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80068fc:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80068fe:	f842 3b04 	str.w	r3, [r2], #4

08006902 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8006902:	4b08      	ldr	r3, [pc, #32]	; (8006924 <LoopFillZerobss+0x22>)
  cmp  r2, r3
 8006904:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8006906:	f4ff aff9 	bcc.w	80068fc <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800690a:	f7fd fea7 	bl	800465c <SystemInit>
/* Call the application's entry point.*/
  bl  main
 800690e:	f7fc fccd 	bl	80032ac <main>
  bx  lr    
 8006912:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8006914:	08006b38 	.word	0x08006b38
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8006918:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800691c:	200005a0 	.word	0x200005a0
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8006920:	200005a0 	.word	0x200005a0
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8006924:	20000d10 	.word	0x20000d10

08006928 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8006928:	f7ff bffe 	b.w	8006928 <ADC_IRQHandler>

0800692c <register_fini>:
 800692c:	4b02      	ldr	r3, [pc, #8]	; (8006938 <register_fini+0xc>)
 800692e:	b113      	cbz	r3, 8006936 <register_fini+0xa>
 8006930:	4802      	ldr	r0, [pc, #8]	; (800693c <register_fini+0x10>)
 8006932:	f000 b805 	b.w	8006940 <atexit>
 8006936:	4770      	bx	lr
 8006938:	00000000 	.word	0x00000000
 800693c:	0800694d 	.word	0x0800694d

08006940 <atexit>:
 8006940:	4601      	mov	r1, r0
 8006942:	2000      	movs	r0, #0
 8006944:	4602      	mov	r2, r0
 8006946:	4603      	mov	r3, r0
 8006948:	f000 b818 	b.w	800697c <__register_exitproc>

0800694c <__libc_fini_array>:
 800694c:	b538      	push	{r3, r4, r5, lr}
 800694e:	4d09      	ldr	r5, [pc, #36]	; (8006974 <__libc_fini_array+0x28>)
 8006950:	4c09      	ldr	r4, [pc, #36]	; (8006978 <__libc_fini_array+0x2c>)
 8006952:	1b64      	subs	r4, r4, r5
 8006954:	10a4      	asrs	r4, r4, #2
 8006956:	bf18      	it	ne
 8006958:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
 800695c:	d005      	beq.n	800696a <__libc_fini_array+0x1e>
 800695e:	3c01      	subs	r4, #1
 8006960:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8006964:	4798      	blx	r3
 8006966:	2c00      	cmp	r4, #0
 8006968:	d1f9      	bne.n	800695e <__libc_fini_array+0x12>
 800696a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800696e:	f000 b85f 	b.w	8006a30 <_fini>
 8006972:	bf00      	nop
 8006974:	08006b34 	.word	0x08006b34
 8006978:	08006b38 	.word	0x08006b38

0800697c <__register_exitproc>:
 800697c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800697e:	4c27      	ldr	r4, [pc, #156]	; (8006a1c <__register_exitproc+0xa0>)
 8006980:	6826      	ldr	r6, [r4, #0]
 8006982:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
 8006986:	b085      	sub	sp, #20
 8006988:	4607      	mov	r7, r0
 800698a:	2c00      	cmp	r4, #0
 800698c:	d041      	beq.n	8006a12 <__register_exitproc+0x96>
 800698e:	6865      	ldr	r5, [r4, #4]
 8006990:	2d1f      	cmp	r5, #31
 8006992:	dd1e      	ble.n	80069d2 <__register_exitproc+0x56>
 8006994:	4822      	ldr	r0, [pc, #136]	; (8006a20 <__register_exitproc+0xa4>)
 8006996:	b918      	cbnz	r0, 80069a0 <__register_exitproc+0x24>
 8006998:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800699c:	b005      	add	sp, #20
 800699e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80069a0:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80069a4:	9103      	str	r1, [sp, #12]
 80069a6:	9202      	str	r2, [sp, #8]
 80069a8:	9301      	str	r3, [sp, #4]
 80069aa:	f3af 8000 	nop.w
 80069ae:	9903      	ldr	r1, [sp, #12]
 80069b0:	9a02      	ldr	r2, [sp, #8]
 80069b2:	9b01      	ldr	r3, [sp, #4]
 80069b4:	4604      	mov	r4, r0
 80069b6:	2800      	cmp	r0, #0
 80069b8:	d0ee      	beq.n	8006998 <__register_exitproc+0x1c>
 80069ba:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
 80069be:	6025      	str	r5, [r4, #0]
 80069c0:	2000      	movs	r0, #0
 80069c2:	6060      	str	r0, [r4, #4]
 80069c4:	4605      	mov	r5, r0
 80069c6:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
 80069ca:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
 80069ce:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
 80069d2:	b93f      	cbnz	r7, 80069e4 <__register_exitproc+0x68>
 80069d4:	1cab      	adds	r3, r5, #2
 80069d6:	2000      	movs	r0, #0
 80069d8:	3501      	adds	r5, #1
 80069da:	6065      	str	r5, [r4, #4]
 80069dc:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
 80069e0:	b005      	add	sp, #20
 80069e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80069e4:	eb04 0085 	add.w	r0, r4, r5, lsl #2
 80069e8:	f04f 0c01 	mov.w	ip, #1
 80069ec:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
 80069f0:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
 80069f4:	fa0c f205 	lsl.w	r2, ip, r5
 80069f8:	4316      	orrs	r6, r2
 80069fa:	2f02      	cmp	r7, #2
 80069fc:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
 8006a00:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
 8006a04:	d1e6      	bne.n	80069d4 <__register_exitproc+0x58>
 8006a06:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
 8006a0a:	431a      	orrs	r2, r3
 8006a0c:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
 8006a10:	e7e0      	b.n	80069d4 <__register_exitproc+0x58>
 8006a12:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
 8006a16:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
 8006a1a:	e7b8      	b.n	800698e <__register_exitproc+0x12>
 8006a1c:	08006b28 	.word	0x08006b28
 8006a20:	00000000 	.word	0x00000000

08006a24 <_init>:
 8006a24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006a26:	bf00      	nop
 8006a28:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006a2a:	bc08      	pop	{r3}
 8006a2c:	469e      	mov	lr, r3
 8006a2e:	4770      	bx	lr

08006a30 <_fini>:
 8006a30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006a32:	bf00      	nop
 8006a34:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006a36:	bc08      	pop	{r3}
 8006a38:	469e      	mov	lr, r3
 8006a3a:	4770      	bx	lr
